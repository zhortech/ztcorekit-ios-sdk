// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2 effective-5.10 (swiftlang-6.2.0.19.9 clang-1700.3.19.1)
// swift-module-flags: -target arm64-apple-ios15.6 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name ZTCoreKit
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2
import Combine
import CoreBluetooth
import CoreData
import CoreTelephony
import CryptoKit
import Foundation
import Network
import OSLog
import ObjectiveC
import Swift
import SwiftUI
import SystemConfiguration
import UIKit
import UniformTypeIdentifiers
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os.log
import os
extension ZTCoreKit.ZTBaliston {
  public func startActivityChunksSync(userRequest: Swift.Bool = false) async
}
extension ZTCoreKit.ZTBaliston {
  public func directStartActivity() async
}
extension ZTCoreKit.ZTBaliston {
  public func startActivityWithRealTime(realtime: Swift.Bool = true, timeout: Swift.Double = 30) async throws
  public func startActivity(timeout: Swift.Double = 30) async throws
  #if compiler(>=5.3) && $NonescapableTypes
  public func startActivityCommand(attributes: [Swift.String : Any], userParameters: ZTCoreKit.ZTUserDataParameters? = nil) async throws
  #endif
}
extension ZTCoreKit.ZTBaliston {
  public func stopActivity(force: Swift.Bool = true) async throws
  public func stopAutomaticActivity(force: Swift.Bool = true) async throws
}
extension ZTCoreKit.ZTBaliston {
  public func setInactivityTimeout(seconds: Foundation.TimeInterval) async throws
  @available(*, unavailable)
  public func getInactivityTimeout() async throws -> Swift.Int
  public func unsafeCalibrateGravity(calibrationPoint: Swift.UInt8 = 1) async throws -> (success: Swift.Bool, leftSuccess: Swift.Bool)
  public func calibrateGravity(calibrationPoint: Swift.UInt8 = 1) async throws
  public func resetCalibration() async throws
  public func setTxPower(value: ZTCoreKit.ZTTXPower) async throws
}
extension ZTCoreKit.ZTBaliston {
  public func hardReset(restart: Swift.Bool = false) async throws
  #if compiler(>=5.3) && $NonescapableTypes
  public func updateUserParameters(timeout: Swift.Double = 15, userParameters: ZTCoreKit.ZTUserDataParameters?) async throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func readGeneralState(timeout: Swift.Double = 15, allowRightInsoleOnly: Swift.Bool) async throws -> ZTCoreKit.ZTDeviceActualState?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor public func setChunkIntervalCommand(seconds: Swift.Int? = nil, resetAfter: Swift.Int?, clearSchedule: Swift.Bool = false)
  #endif
}
extension ZTCoreKit.ZTBaliston {
  public func cleanMemory() async throws
}
extension ZTCoreKit.ZTBaliston {
  public typealias RawDataFlowState = ZTCoreKit.ZTRawDataFlowStates
  public func uploadRawData(for activityId: Swift.String) async throws
}
extension ZTCoreKit.ZTBaliston {
  public func initiateBackgroundDFU(isRestartRequired: Swift.Bool = false)
  public func initiateBackgroundDFU(path: Swift.String)
  public func reboot(completion: @escaping ZTCoreKit.ZTBaseResult)
}
extension ZTCoreKit.ZTBaliston {
  #if compiler(>=5.3) && $NonescapableTypes
  public func startMobilityScanV2(timeout: Swift.Double = 30, duration: Swift.Int = 60, numberOfStride: Swift.UInt8? = nil, chunckInterval: Swift.Int? = nil, userParameters: ZTCoreKit.ZTUserDataParameters?) async throws
  #endif
}
extension ZTCoreKit.ZTBaliston {
  #if compiler(>=5.3) && $NonescapableTypes
  public func stopMobilityScanV2(timeout: Swift.Double = 30, allowRightInsoleOnly: Swift.Bool = false, silently: Swift.Bool = false, meetMinimumRequirements: (([ZTCoreKit.ZhorthechPacket]) -> Swift.Bool)? = nil) async throws -> ZTCoreKit.ZhortechActivitySummary?
  #endif
}
extension ZTCoreKit.ZTBaliston {
  #if compiler(>=5.3) && $NonescapableTypes
  public func sendDirectMessage(message: [Swift.String : Any], completion: @escaping ([Swift.String : Any]?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getDirectMessages(completion: @escaping ([[Swift.String : Any]]?, (any Swift.Error)?) -> Swift.Void)
  #endif
  public func deleteDirectMessage(id: Swift.String, completion: @escaping ZTCoreKit.ZTBaseResult)
  #if compiler(>=5.3) && $NonescapableTypes
  public func sendCannedMessage(message: [Swift.String : Any], completion: @escaping (Any?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getCannedMessages(parameters: [Swift.String : Any], completion: @escaping ([[Swift.String : Any]]?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getTileMessage(name: Swift.String, parameters: [Swift.String : Any], completion: @escaping ([Swift.String : Any]?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getMobilityMessage(name: Swift.String, enqueue: Swift.Bool = true, completion: @escaping ([Swift.String : Any]?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getMyShoesData(completion: @escaping ([[Swift.String : Any]]?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getMyShoeData(code: Swift.String = "", completion: @escaping ([Swift.String : Any]?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func startListenMessages(onMessageReceived: @escaping (Swift.String?) -> Swift.Void, onDataReceived: @escaping (Foundation.Data?) -> Swift.Void)
  #endif
  public func stopListenMessages()
  #if compiler(>=5.3) && $NonescapableTypes
  public func postMobility(name: Swift.String, parameters: [Swift.String : Any] = [:], completion: @escaping (Any?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getActivity(name: Swift.String, parameters: [Swift.String : Any] = [:], completion: @escaping ([Swift.String : Any]?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getData(path: Swift.String, name: Swift.String, parameters: [Swift.String : Any] = [:], completion: @escaping (Any?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getDataArray(path: Swift.String, name: Swift.String, parameters: [Swift.String : Any] = [:], completion: @escaping ([Any]?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func postData(path: Swift.String, name: Swift.String, parameters: [Swift.String : Any] = [:], completion: @escaping (Any?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getSwingAnalysis(body: [Swift.String : Any], completion: @escaping ([[Swift.String : Any]]?, (any Swift.Error)?) -> Swift.Void)
  #endif
}
extension ZTCoreKit.ZTBaliston {
  public func enableRealtimeStreaming(startDate: Foundation.Date, interval: Swift.Int16 = 1, metrics: Swift.Set<ZTCoreKit.ZTRealtimeMetric>, side: ZTCoreKit.ZTRealtimeMessage.Side = .none) async throws
  #if compiler(>=5.3) && $NonescapableTypes
  public func enableRealtimeStreamingFromArray(startDate: Foundation.Date, force: Swift.Bool = false, interval: Swift.Int16 = 1, wantedMetrics: [ZTCoreKit.ZTRealtimeMetric]? = nil, side: ZTCoreKit.ZTRealtimeMessage.Side = .none) async throws
  #endif
  public func disableRealtimeStreaming(noCheckInsole: Swift.Bool = false) async throws
  public func pauseRealtimeStreaming(pause: Swift.Bool) async throws
  public func pauseRealtimeStreaming()
  public func resumeRealtimeStreaming()
  public func enableSingleMetric(noCheckInsole: Swift.Bool = false, metric: ZTCoreKit.ZTRealtimeMetric) async throws
}
public typealias ZTActivityResult = (Swift.String?, ZTCoreKit.ZTError?) -> Swift.Void
public typealias ZTBalistonActivitySummary = ZTCoreKit.ZhortechActivitySummary
public typealias ZTBalistonPacket = ZTCoreKit.ZhorthechPacket
public typealias ZTBalistonActivity = ZTCoreKit.ZhortechActivity
@available(*, deprecated, message: "This delegate will be replace")
public protocol ZTBalistonDfuDelegate {
}
@_hasMissingDesignatedInitializers public class ZTBaliston {
  public static let version: Swift.String
  public static let shared: ZTCoreKit.ZTBaliston
  public static let requiredFwVersion: Swift.String
  public var dfuDelegate: (any ZTCoreKit.ZTBalistonDfuDelegate)?
  #if compiler(>=5.3) && $NonescapableTypes
  public var connectedDevice: ZTCoreKit.ZTDevice? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var isActivityRunning: Swift.Bool? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var lastSerialNumber: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var currentActivity: ZTCoreKit.ZhortechActivity? {
    get async
  }
  #endif
  public var activityManager: ZTCoreKit.ZhortechActivityActor {
    get
  }
  public var signalManager: ZTCoreKit.ZhortechSignalManager {
    get
  }
  public func sendAllPendingPackets() async
  public var currentDfuState: ZTCoreKit.ZTMessageBootloaderInfo.DfuState {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var analyticsData: [Swift.String : Any]? {
    get
    set
  }
  #endif
  public var isObtainingData: Swift.Bool {
    get async
  }
  public var isActivityChunksSyncing: Swift.Bool {
    get async
  }
  public var isCheckingActivityState: Swift.Bool {
    get async
  }
  public var isCheckingMonitoredActivity: Swift.Bool {
    get async
  }
  public var disableAutomaticActivity: Swift.Bool {
    get
  }
  public var activityStarted: Swift.Bool {
    get async
  }
  public var isEnablingRealtimeStreaming: Swift.Bool {
    get async
  }
  public var isCheckingAnalyticsData: Swift.Bool {
    get async
  }
  public var defaultChunkDurationSeconds: Swift.Int {
    get async
  }
  public var isStreamingStarted: Swift.Bool {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var currentMode: ZTCoreKit.ZTActivityMode? {
    get async
  }
  #endif
  @objc deinit
  public func subscribeCoreEvents()
  #if compiler(>=5.3) && $NonescapableTypes
  public func readGeneralState(completion: @escaping (ZTCoreKit.ZTDeviceActualState?, ZTCoreKit.ZTError?) -> Swift.Void)
  #endif
}
extension ZTCoreKit.ZTBaliston {
  #if compiler(>=5.3) && $NonescapableTypes
  public var onActivityStateChange: ZTCoreKit.ZTSignal<(Swift.String?, ZTCoreKit.ZTDeviceActualState, (any Swift.Error)?)> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var onActivityStopped: ZTCoreKit.ZTSignal<(Swift.String?, ZTCoreKit.ZTDeviceActualState, (any Swift.Error)?)> {
    get
  }
  #endif
  public var onAnalyticsDataUpdated: ZTCoreKit.ZTSignal<()> {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var onActivityError: ZTCoreKit.ZTSignal<ZTCoreKit.ZTError?> {
    get
  }
  #endif
  public var onActivityDataReceived: ZTCoreKit.ZTSignal<()> {
    get
  }
  public var onDfuStateUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageBootloaderInfo.DfuState> {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var onDfuChanged: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTDFUState, ZTCoreKit.ZTError?)> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var onDfuUploadProgress: ZTCoreKit.ZTSignal<Swift.Float?> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var onChunksDownloadProgress: ZTCoreKit.ZTSignal<Swift.Float?> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var onActivityMetadataUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZhortechMessageActivityMetadata?> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var onChunkStatusUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZhortechMessageActivityMetadata?> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var onRealtimeMetricReceived: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTRealtimeMetric?, Any?)> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var onRawDataFlowStateChange: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTBaliston.RawDataFlowState?, (any Swift.Error)?)> {
    get
  }
  #endif
  public var onRawDataFlowProgresss: ZTCoreKit.ZTSignal<Swift.Float> {
    get
  }
}
extension ZTCoreKit.ZhortechActivityActor {
  #if compiler(>=5.3) && $NonescapableTypes
  public func updateActivity(metaData: ZTCoreKit.ZhortechMessageActivityMetadata?, device: (any ZTCoreKit.ZTDeviceProtocol)?) async
  #endif
}
extension ZTCoreKit.ZhortechActivityActor {
  public func syncTimestamp(time: ZTCoreKit.ZTMessageTime) async
  public func forceSyncTimestamp(time: ZTCoreKit.ZTMessageTime) async
}
extension ZTCoreKit.ZTActivity : @unchecked Swift.Sendable {
}
extension ZTCoreKit.ZTPacket : @unchecked Swift.Sendable {
}
extension ZTCoreKit.ZhortechActivity {
  public enum ActualStates : Swift.UInt8, Swift.Codable, Swift.Sendable {
    case activityNone
    case activityStarting
    case eraseMemory
    case activityRunning
    case activityPaused
    case activityStopping
    case activityPendData
    case activitySendData
    case unknown
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum StopReason : Swift.UInt8, Swift.Codable, Swift.Sendable {
    case undefined
    case userRequest
    case memoryFull
    case inactivity
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
public struct ZhortechMessageActivityMetadata : Swift.Codable, Swift.Equatable, Swift.Sendable, Swift.CustomStringConvertible {
  public typealias LastStopReason = ZTCoreKit.ZhortechActivity.StopReason
  public let bytes: [Swift.UInt8]
  public var lastStopReason: ZTCoreKit.ZhortechMessageActivityMetadata.LastStopReason
  public var chunkCount: Swift.Int16
  public var firstChunkId: Swift.Int16
  public var lastChunkId: Swift.Int16 {
    get
  }
  public var startTime: Swift.UInt32
  public var endTime: Swift.UInt32
  public init(bytes: [Swift.UInt8])
  public var description: Swift.String {
    get
  }
  public func toJSONString(prettyPrinted: Swift.Bool = false) throws -> Swift.String
  public init(jsonString: Swift.String) throws
  public static func fromJSONString(_ jsonString: Swift.String) throws -> ZTCoreKit.ZhortechMessageActivityMetadata
  public static func == (a: ZTCoreKit.ZhortechMessageActivityMetadata, b: ZTCoreKit.ZhortechMessageActivityMetadata) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension ZTCoreKit.ZhorthechPacket {
  public enum Status : Swift.Int16, Swift.Codable, Swift.Equatable, Swift.Sendable {
    case new
    case readyToSend
    case sending
    case sent
    case error
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.Int16)
    #endif
    public typealias RawValue = Swift.Int16
    public var rawValue: Swift.Int16 {
      get
    }
  }
  public enum TimestampType : Swift.UInt8, Swift.Codable, Swift.Sendable {
    case unknown
    case start
    case stop
    case pause
    case resume
    case reboot
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum BmTimestampType : Swift.UInt8, Swift.Codable, Swift.Sendable {
    case unknown
    case shoeWearOn
    case shoeWearOff
    case walkingStart
    case walkingStop
    case runningStart
    case runningStop
    case cyclingStart
    case cyclingStop
    case transportStart
    case transportStop
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum PacketType : Swift.UInt8, Swift.Codable, Swift.Sendable {
    public static let maxDataValue: Swift.UInt8
    case unknown
    case quantification
    case walkAnalysis
    case runAnalysis
    case stairs
    case cycling
    case jump
    case safety
    case staticActivity
    case debug
    case debugTelemetry
    case debugProba
    case bmTimestampPacket
    case fwTimestampPacket
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum Mode : Swift.UInt8, Swift.Codable, Swift.Sendable {
    case safety
    case walking
    case running
    case cycling
    case mobility
    case swing
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
extension ZTCoreKit.ZhorthechPacket.TimestampType {
  public var description: Swift.String {
    get
  }
  public var name: Swift.String {
    get
  }
}
extension ZTCoreKit.ZhorthechPacket.BmTimestampType {
  public var description: Swift.String {
    get
  }
  public var name: Swift.String {
    get
  }
}
extension ZTCoreKit.ZhorthechPacket.PacketType {
  public var description: Swift.String {
    get
  }
}
public protocol SignalNotificationProtocol : Swift.Sendable {
  var notificationName: Foundation.Notification.Name { get }
  var notificationCenter: Foundation.NotificationCenter { get }
}
extension ZTCoreKit.SignalNotificationProtocol {
  public var notificationCenter: Foundation.NotificationCenter {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public func post(_ device: (any ZTCoreKit.ZTDeviceProtocol)?)
  #endif
}
extension ZTCoreKit.ZTRealtimeMetric {
  #if compiler(>=5.3) && $NonescapableTypes
  public func value(content: Foundation.Data, side: ZTCoreKit.ZTRealtimeMessage.Side? = nil, userParamters: ZTCoreKit.ZTUserDataParameters?) async -> Any?
  #endif
}
extension ZTCoreKit.ZhortechActivityActor {
  public func handleMessage(message: ZTCoreKit.ZTRealtimeMessage, payload: Any, bytes: [Swift.UInt8], device: any ZTCoreKit.ZTDeviceProtocol) async
}
extension ZTCoreKit.ZTRealtimeMessage.Side : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension ZTCoreKit.ZTRealtimeMetric {
  public typealias MetricSide = ZTCoreKit.ZTRealtimeMessage.Side
  public struct Slope {
    public let slopeAngle: Swift.Float?
    public let directionAngle: Swift.Float?
    public let side: ZTCoreKit.ZTRealtimeMetric.MetricSide?
  }
}
extension ZTCoreKit.ZhortechActivity {
  #if compiler(>=5.3) && $NonescapableTypes
  public var stopReason: ZTCoreKit.ZhortechActivity.StopReason? {
    get
  }
  #endif
  public var duration: Swift.Double {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public func lastSavedChunkId(startId: Swift.Int16? = 0, lastId: Swift.Int16? = 0) async -> Swift.Int16
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getLastPacket() -> ZTCoreKit.ZhorthechPacket?
  #endif
  public func getPacketCount() -> Swift.Int
  #if compiler(>=5.3) && $NonescapableTypes
  public func getPackets(fromId startId: Swift.Int16? = nil, toId endId: Swift.Int16? = nil, withStatus status: ZTCoreKit.ZhorthechPacket.Status? = nil) -> [ZTCoreKit.ZhorthechPacket]
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getPacket(with packetId: Swift.UInt16) -> ZTCoreKit.ZhorthechPacket?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getPreviousPacket(beforePacket packetId: Swift.UInt16, withTimestamp timestamp: Swift.Int64) -> ZTCoreKit.ZhorthechPacket?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getPacketContainingLastFirmwareVersion(packetId: Swift.UInt16, startId: Swift.UInt16? = nil) -> ZTCoreKit.ZhorthechPacket?
  #endif
}
extension ZTCoreKit.ZhortechActivityActor {
  public func clearPackets() async throws
  @discardableResult
  public func setPackets(ids: [Swift.Int16]) async throws -> [ZTCoreKit.ZhorthechPacket]
  @discardableResult
  public func addPacket(packet: ZTCoreKit.ZhorthechPacket) async throws -> [ZTCoreKit.ZhorthechPacket]
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func update(with metaData: ZTCoreKit.ZhortechActivity.MessageActivityMetadata?, serial: Swift.String?, fwVersion: Swift.String?, isCheckingMonitoredActivity: Swift.Bool) async throws -> (sucess: Swift.Bool, outsideActivityDetected: Swift.Bool)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func createActivity(serialNumber: Swift.String, activityType: Swift.String, fwVersion: Swift.String?, appId: Swift.String, lastActivityStartTime: Swift.UInt32?) async throws -> ZTCoreKit.ZhortechActivity
  #endif
  public func update(activityState: ZTCoreKit.ZhortechActivityActor.ActualStates) async throws
}
extension ZTCoreKit.ZhortechActivityActor {
  public func canAutoStartMonitoredActivity(for device: any ZTCoreKit.ZTDeviceProtocol) -> Swift.Bool
  public var throttleActivityStart: Swift.Bool {
    get
  }
}
extension ZTCoreKit.ZTActivityAndDataState {
  public func canStartActivityChunksSyncing(for device: any ZTCoreKit.ZTDeviceProtocol) -> Swift.Bool
  public var shouldInterruptChunk: Swift.Bool {
    get
  }
}
extension ZTCoreKit.ZhortechActivityActor {
  public typealias FetchConfiguration = ZTCoreKit.ZhortechActivityFetchConfiguration
  public func checkUnsentPackets(packetThreshold: Swift.Int, sentHandler: ([ZTCoreKit.ZhortechActivityActor.Packet]) async throws -> [ZTCoreKit.ZhortechActivityActor.Packet]) async throws
  @discardableResult
  public func send(packets: [ZTCoreKit.ZhortechActivityActor.Packet], sentHandler: ([ZTCoreKit.ZhortechActivityActor.Packet]) async throws -> [ZTCoreKit.ZhortechActivityActor.Packet]) async throws -> [ZTCoreKit.ZhortechActivityActor.Packet]
  public func startFetchTimer(configuration: ZTCoreKit.ZhortechActivityActor.FetchConfiguration = .default, sentHandler: @escaping ([ZTCoreKit.ZhortechActivityActor.Packet]) async throws -> [ZTCoreKit.ZhortechActivityActor.Packet])
}
extension ZTCoreKit.ZhortechActivityActor {
  public func stop(force: Swift.Bool = false) async throws
  public func anchorTimestamp(_ value: Swift.Int64) async throws
  public func creatingActivity(_ value: Swift.Bool = false)
  public func startingActivity(_ value: Swift.Bool = false)
  public func resetAnchorTimestamp() async throws
  #if compiler(>=5.3) && $NonescapableTypes
  public func fwVersion(_ value: Swift.String?) async throws
  #endif
  public func clearMetaData() async throws
  public func update(actualState: ZTCoreKit.ZhortechActivityActor.ActualStates) async throws
  public func update(actualState: Swift.UInt8) async throws
  public func activityType(_ value: Swift.String) async throws
  public func customActivityStartTimestamp(_ value: Swift.Int64) async throws
  public func customActivityFirstChunkId(_ value: Swift.Int16) async throws
}
extension ZTCoreKit.ZhortechDeviceSignalManager {
  public struct GeneralStateUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let state: ZTCoreKit.ZTDeviceActualState
  }
  final public func notifyOnGeneralStateUpdated(device: any ZTCoreKit.ZTDeviceProtocol, state: ZTCoreKit.ZTDeviceActualState)
  public struct BatteryValueUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
  }
  final public func notifyOnBatteryValueUpdated(device: any ZTCoreKit.ZTDeviceProtocol)
  public struct TimeUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let time: ZTCoreKit.ZTMessageTime?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnTimeUpdated(device: any ZTCoreKit.ZTDeviceProtocol, time: ZTCoreKit.ZTMessageTime?)
  #endif
  public struct RealtimeMessageUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let message: ZTCoreKit.ZTRealtimeMessage?
    public let payload: [Swift.UInt8]?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnRealtimeMessageUpdated(device: any ZTCoreKit.ZTDeviceProtocol, message: ZTCoreKit.ZTRealtimeMessage?, payload: [Swift.UInt8]?)
  #endif
  public struct RealtimeMetricReceivedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let message: ZTCoreKit.ZTRealtimeMessage
    public let value: any Swift.Sendable
    public let data: [Swift.UInt8]
  }
  final public func notifyOnRealtimeMetricReceived(device: any ZTCoreKit.ZTDeviceProtocol, message: ZTCoreKit.ZTRealtimeMessage, value: Any, data: [Swift.UInt8])
  public struct RSSIChangedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let deviceRef: any ZTCoreKit.ZTDeviceProtocol
    public let rssi: Swift.Int
  }
  final public func notifyOnRSSIChanged(device: any ZTCoreKit.ZTDeviceProtocol, rssi: Swift.Int)
  public struct StateChangedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let deviceRef: (any ZTCoreKit.ZTDeviceProtocol)?
    public let error: (any Swift.Error)?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnStateChanged(device: any ZTCoreKit.ZTDeviceProtocol, deviceRef: (any ZTCoreKit.ZTDeviceProtocol)?, error: (any Swift.Error)?)
  #endif
  public struct ActivityInfoUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let info: ZTCoreKit.ZTMessageActivity?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnActivityInfoUpdated(device: any ZTCoreKit.ZTDeviceProtocol, info: ZTCoreKit.ZTMessageActivity?)
  #endif
  public struct BootloaderInfoUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let info: ZTCoreKit.ZTMessageBootloaderInfo?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnBootloaderInfoUpdated(device: any ZTCoreKit.ZTDeviceProtocol, info: ZTCoreKit.ZTMessageBootloaderInfo?)
  #endif
  public struct SoftwareUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let info: ZTCoreKit.ZTMessageSoftware?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnSoftwareUpdated(device: any ZTCoreKit.ZTDeviceProtocol, info: ZTCoreKit.ZTMessageSoftware?)
  #endif
  public struct NotifyValueUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let groupId: ZTCoreKit.ZTNotifyData.GroupID
    public let messageId: Swift.UInt8
    public let payload: [Swift.UInt8]?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnNotifyValueUpdated(device: any ZTCoreKit.ZTDeviceProtocol, groupId: ZTCoreKit.ZTNotifyData.GroupID, messageId: Swift.UInt8, payload: [Swift.UInt8]?)
  #endif
  public struct RawDataHeaderUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let data: Foundation.Data?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnRawDataHeaderUpdated(device: any ZTCoreKit.ZTDeviceProtocol, data: Foundation.Data?)
  #endif
  public struct RawDataFrameUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let data: Foundation.Data?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnRawDataFrameUpdated(device: any ZTCoreKit.ZTDeviceProtocol, data: Foundation.Data?)
  #endif
  public struct FirmwareErrorNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let error: ZTCoreKit.ZTError.Enums.FirmwareError
  }
  final public func notifyOnFirmwareError(device: any ZTCoreKit.ZTDeviceProtocol, error: ZTCoreKit.ZTError.Enums.FirmwareError)
  public struct NotifyCommonGroupUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let messageId: ZTCoreKit.ZTNotifyData.CommonMessageId
    public let payload: [Swift.UInt8]?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnNotifyCommonGroupUpdated(device: any ZTCoreKit.ZTDeviceProtocol, messageId: ZTCoreKit.ZTNotifyData.CommonMessageId, payload: [Swift.UInt8]?)
  #endif
  public struct NotifyWarmGroupUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let messageId: ZTCoreKit.ZTNotifyData.WarmMessageId
    public let data: Foundation.Data?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnNotifyWarmGroupUpdated(device: any ZTCoreKit.ZTDeviceProtocol, messageId: ZTCoreKit.ZTNotifyData.WarmMessageId, data: Foundation.Data?)
  #endif
  public struct NotifyRunningGroupUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let messageId: ZTCoreKit.ZTNotifyData.RunningMessageId
    public let payload: [Swift.UInt8]?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnNotifyRunningGroupUpdated(device: any ZTCoreKit.ZTDeviceProtocol, messageId: ZTCoreKit.ZTNotifyData.RunningMessageId, payload: [Swift.UInt8]?)
  #endif
  public struct NotifyCyclingGroupUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let messageId: ZTCoreKit.ZTNotifyData.CyclingMessageId
    public let payload: [Swift.UInt8]?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnNotifyCyclingGroupUpdated(device: any ZTCoreKit.ZTDeviceProtocol, messageId: ZTCoreKit.ZTNotifyData.CyclingMessageId, payload: [Swift.UInt8]?)
  #endif
  public struct NotifySafetyGroupUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let messageId: ZTCoreKit.ZTNotifyData.SafetyMessageId
    public let payload: [Swift.UInt8]?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnNotifySafetyGroupUpdated(device: any ZTCoreKit.ZTDeviceProtocol, messageId: ZTCoreKit.ZTNotifyData.SafetyMessageId, payload: [Swift.UInt8]?)
  #endif
  public struct NotifyGenericGroupUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let messageId: ZTCoreKit.ZTNotifyData.GenericMessageId
    public let payload: [Swift.UInt8]?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnNotifyGenericGroupUpdated(device: any ZTCoreKit.ZTDeviceProtocol, messageId: ZTCoreKit.ZTNotifyData.GenericMessageId, payload: [Swift.UInt8]?)
  #endif
  public struct CommandUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let response: ZTCoreKit.ZTCommandResponse?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnCommandUpdated(device: any ZTCoreKit.ZTDeviceProtocol, response: ZTCoreKit.ZTCommandResponse?)
  #endif
  public struct CommandAckNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let response: ZTCoreKit.ZTCommandResponse?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnCommandAck(device: any ZTCoreKit.ZTDeviceProtocol, response: ZTCoreKit.ZTCommandResponse?)
  #endif
  public struct IndicateValueUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let data: Foundation.Data?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnIndicateValueUpdated(device: any ZTCoreKit.ZTDeviceProtocol, data: Foundation.Data?)
  #endif
  public struct NotifyChunkSendStatusUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let status: ZTCoreKit.ZTMessageChunkSendStatus?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnNotifyChunkSendStatusUpdated(device: any ZTCoreKit.ZTDeviceProtocol, status: ZTCoreKit.ZTMessageChunkSendStatus?)
  #endif
  public struct NotifyChunkConfigUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let config: ZTCoreKit.ZTMessageChunkConfig?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnNotifyChunkConfigUpdated(device: any ZTCoreKit.ZTDeviceProtocol, config: ZTCoreKit.ZTMessageChunkConfig?)
  #endif
  public struct NotifyChunkDataUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let data: ZTCoreKit.ZTMessageChunkData?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnNotifyChunkDataUpdated(device: any ZTCoreKit.ZTDeviceProtocol, data: ZTCoreKit.ZTMessageChunkData?)
  #endif
  public struct InactivityTimeoutUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let info: ZTCoreKit.ZTMessageInactivityTimeout?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnInactivityTimeoutUpdated(device: any ZTCoreKit.ZTDeviceProtocol, info: ZTCoreKit.ZTMessageInactivityTimeout?)
  #endif
}
extension ZTCoreKit.ZhortechSignalManager {
  public struct ActivitStateChangeNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let activityID: Swift.String?
    public let state: ZTCoreKit.ZTDeviceActualState?
    public let error: (any Swift.Error)?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnActivityStateChange(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, activityID: Swift.String?, state: ZTCoreKit.ZTDeviceActualState, error: (any Swift.Error)?)
  #endif
  public struct ActivityStoppedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let activityID: Swift.String?
    public let state: ZTCoreKit.ZTDeviceActualState?
    public let error: (any Swift.Error)?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnActivityStopped(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, activityID: Swift.String?, state: ZTCoreKit.ZTDeviceActualState, error: (any Swift.Error)?)
  #endif
  public struct AnalyticsDataUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnAnalyticsDataUpdated(_ device: (any ZTCoreKit.ZTDeviceProtocol)?)
  #endif
  public struct ActivityErrorNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let error: ZTCoreKit.ZTError?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnActivityError(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, error: ZTCoreKit.ZTError?)
  #endif
  public struct ActivityDataReceivedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnActivityDataReceived(_ device: (any ZTCoreKit.ZTDeviceProtocol)?)
  #endif
  public struct ChunksDownloadProgressNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let progress: Swift.Float?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnChunksDownloadProgress(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, progress: Swift.Float?)
  #endif
  public struct ChunkStatusUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let metadata: ZTCoreKit.ZhortechMessageActivityMetadata?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnChunkStatusUpdated(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, metadata: ZTCoreKit.ZhortechMessageActivityMetadata?)
  #endif
  public struct ActivityMetadataUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let metadata: ZTCoreKit.ZhortechMessageActivityMetadata?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnActivityMetadataUpdated(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, metadata: ZTCoreKit.ZhortechMessageActivityMetadata?)
  #endif
  public struct RealtimeMetricReceivedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let metric: ZTCoreKit.ZTRealtimeMetric?
    public let value: (any Swift.Sendable)?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnRealtimeMetricReceived(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, metric: ZTCoreKit.ZTRealtimeMetric?, value: Any?)
  #endif
  public struct RawDataFlowStateChangeNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let state: ZTCoreKit.ZTRawDataFlowStates?
    public let error: (any Swift.Error)?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnRawDataFlowStateChange(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, state: ZTCoreKit.ZTRawDataFlowStates?, error: (any Swift.Error)?)
  #endif
  public struct RawDataFlowProgressNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let progress: Swift.Float
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnRawDataFlowProgress(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, progress: Swift.Float)
  #endif
  public struct KeyingAndDfuRequiredNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let required: Swift.Bool
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyKeyingAndDfuRequired(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, required: Swift.Bool)
  #endif
  public struct DfuStateUpdatedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let state: ZTCoreKit.ZTMessageBootloaderInfo.DfuState
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnDfuStateUpdated(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, state: ZTCoreKit.ZTMessageBootloaderInfo.DfuState)
  #endif
  public struct DfuUploadProgressNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let progress: Swift.Float?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnDfuUploadProgress(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, progress: Swift.Float?)
  #endif
  public struct DfuUploadProgressLeftNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let progress: Swift.Float?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnDfuUploadLeftProgress(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, progress: Swift.Float?)
  #endif
  public struct DfuUploadProgressRightNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let progress: Swift.Float?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnDfuUploadRightProgress(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, progress: Swift.Float?)
  #endif
  public struct DfuFinishedLeftNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let error: ZTCoreKit.ZTError?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnDfuFinishedLeft(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, error: ZTCoreKit.ZTError?)
  #endif
  public struct DfuFinishedRightNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let error: ZTCoreKit.ZTError?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnDfuFinishedRight(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, error: ZTCoreKit.ZTError?)
  #endif
  public struct DfuFinishedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let error: ZTCoreKit.ZTError?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnDfuFinished(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, error: ZTCoreKit.ZTError?)
  #endif
  public struct DfuCopiedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnDfuCopied(_ device: (any ZTCoreKit.ZTDeviceProtocol)?)
  #endif
  public struct DfuChangedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let state: ZTCoreKit.ZTDFUState
    public let error: ZTCoreKit.ZTError?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnDfuChanged(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, state: ZTCoreKit.ZTDFUState, error: ZTCoreKit.ZTError?)
  #endif
  public struct AuthorizationChangeNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let authorization: ZTCoreKit.ZTManagerAuthorization
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnAuthorizationChange(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, authorization: ZTCoreKit.ZTManagerAuthorization)
  #endif
  public struct BluetoothStateChangeNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let state: ZTCoreKit.ZTManagerState
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnBluetoothStateChange(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, state: ZTCoreKit.ZTManagerState)
  #endif
  public struct ScanFinishedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let error: (any Swift.Error)?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnScanFinished(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, error: (any Swift.Error)?)
  #endif
  public struct ReconnectFailedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let error: (any Swift.Error)?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnReconnectFailed(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, error: (any Swift.Error)?)
  #endif
  public struct CommandAckNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let response: ZTCoreKit.ZTCommandResponse?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnCommandAck(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, response: ZTCoreKit.ZTCommandResponse?)
  #endif
  public struct DeviceStateChangeNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let device: (any ZTCoreKit.ZTDeviceProtocol)?
    public let error: (any Swift.Error)?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnDeviceStateChange(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, error: (any Swift.Error)?)
  #endif
  public struct DeviceDiscoveredNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let device: any ZTCoreKit.ZTDeviceProtocol
  }
  final public func notifyOnDeviceDiscovered(_ device: any ZTCoreKit.ZTDeviceProtocol)
  public struct DeviceConnectionFailedNotification : ZTCoreKit.SignalNotificationProtocol {
    public let notificationName: Foundation.Notification.Name
    public let device: (any ZTCoreKit.ZTDeviceProtocol)?
    public let error: (any Swift.Error)?
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func notifyOnDeviceConnectionFailed(_ device: (any ZTCoreKit.ZTDeviceProtocol)?, error: (any Swift.Error)?)
  #endif
}
extension ZTCoreKit.ZhorthechPacket {
  public var rawDescription: Swift.String {
    get
  }
}
extension ZTCoreKit.ZhortechActivityActor {
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func updated(packet: ZTCoreKit.ZhortechActivityActor.Packet, for activity: ZTCoreKit.ZhortechActivityActor.Activity?) async throws -> ZTCoreKit.ZhortechActivityActor.Packet
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func contextualUpdated(packet: ZTCoreKit.ZhortechActivityActor.Packet, for activity: ZTCoreKit.ZhortechActivityActor.Activity?) async throws -> ZTCoreKit.ZhortechActivityActor.Packet
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func createPacket(data: Foundation.Data, name: Swift.String, activity: ZTCoreKit.ZhortechActivityActor.Activity?, fwVersion: Swift.String?, updateBlock: ((ZTCoreKit.ZhortechActivityActor.Packet) -> ZTCoreKit.ZhortechActivityActor.Packet)? = nil) async throws -> ZTCoreKit.ZhortechActivityActor.Packet
  #endif
}
extension ZTCoreKit.ZhortechActivityActor {
  public func checkMissedChunks(activityId: Swift.String) async throws -> Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  public func hasMissedChunks(activityId: Swift.String, startIndex: Swift.Int16?, endIndex: Swift.Int16?) async throws -> Swift.Bool
  #endif
  public func hasPreviousChunk(activityId: Swift.String, currentIndex: Swift.Int16) async throws -> Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  public func loadAllIds(activityId: Swift.String, startId: Swift.Int16, endId: Swift.Int16? = nil) async throws -> [Swift.Int16]
  #endif
  public func loadAll(for activityId: Swift.String) async throws -> [ZTCoreKit.ZhorthechPacket]
  public func loadAll(for activityId: Swift.String, startId: Swift.Int16) async throws -> [ZTCoreKit.ZhorthechPacket]
  public func loadUnsent(activityId: Swift.String) async throws -> [ZTCoreKit.ZhorthechPacket]
  public func count(for activityId: Swift.String) async throws -> Swift.Int
  public func count(for activity: ZTCoreKit.ZhortechActivity) async throws -> Swift.Int
  #if compiler(>=5.3) && $NonescapableTypes
  public func lastChunkID(for activityId: Swift.String) async throws -> Swift.Int16?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func loadPreviousTimestamps(activityId: Swift.String?, packetId: Swift.Int16, startId: Swift.Int16? = nil) async throws -> (id: Swift.Int16?, timestamp: Swift.Int64?, originalTimestamp: Swift.Int64?)?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func loadLastFwVersionEvent(activityId: Swift.String?, packetId: Swift.Int16, startId: Swift.Int16? = nil) async throws -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func loadPrevious(activityId: Swift.String?, chunkId: Swift.Int16, originalTimestamp: Swift.Int64) async throws -> ZTCoreKit.ZhorthechPacket?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getMinMissedChunk(activityId: Swift.String, chunkId: Swift.Int16, activityChunkRetryLimit: Swift.Int) async throws -> Swift.Int16?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getMissedPackets(activityId: Swift.String, startId: Swift.Int16, endId: Swift.Int16? = nil, activityChunkRetryLimit: Swift.Int) async throws -> [Swift.Int16]?
  #endif
  public func lastSegmentId(activityId: Swift.String) async throws -> Swift.Int
  public func segmentsCount(activityId: Swift.String) async throws -> Swift.Int
  public func loadOrphelin() async throws -> [ZTCoreKit.ZhorthechPacket]
  public func updateSegments(ids: [Swift.Int16], status: ZTCoreKit.ZhorthechPacket.Status, activityId: Swift.String) async throws
  public func updateSegments(ids: [Swift.Int16], status: ZTCoreKit.ZhorthechPacket.Status, activity: ZTCoreKit.ZhortechActivity) async throws
  #if compiler(>=5.3) && $NonescapableTypes
  public func updateSegmentsTimestamp(activityId: Swift.String, startId: Swift.Int16, anchorTime: Swift.Int64?) async throws
  #endif
  @discardableResult
  public func update(_ packets: [ZTCoreKit.ZhortechActivityActor.Packet], withNewStatus newStatus: ZTCoreKit.ZhortechActivityActor.Packet.Status) async throws -> [ZTCoreKit.ZhortechActivityActor.Packet]
  public func delete(_ packets: [ZTCoreKit.ZhortechActivityActor.Packet]) async throws
}
extension ZTCoreKit.ZhorthechPacket {
  @discardableResult
  public mutating func status(_ value: ZTCoreKit.ZhorthechPacket.Status) -> ZTCoreKit.ZhorthechPacket
  @discardableResult
  public mutating func fwVersion(_ value: Swift.String) -> ZTCoreKit.ZhorthechPacket
  @discardableResult
  public mutating func activityType(_ value: ZTCoreKit.ZhorthechPacket.Mode) -> ZTCoreKit.ZhorthechPacket
}
extension Foundation.Data {
  public var hexString: Swift.String {
    get
  }
}
public struct ZhortechActivity : Swift.Codable, Swift.Identifiable, Swift.Hashable, Swift.Equatable, Swift.Sendable, Swift.CustomStringConvertible {
  public typealias MessageActivityMetadata = ZTCoreKit.ZhortechMessageActivityMetadata
  public typealias Packet = ZTCoreKit.ZhorthechPacket
  public static let activityKey: Swift.String
  public let id: Swift.String
  public var activityIdentifier: Swift.String {
    get
  }
  public var appId: Swift.String {
    get
  }
  public var activityType: Swift.String {
    get
  }
  public var startDate: Foundation.Date {
    get
  }
  public var endDate: Foundation.Date? {
    get
  }
  public var startTimestamp: Swift.Int64 {
    get
  }
  public var endTimestamp: Swift.Int64 {
    get
  }
  public var tz: Swift.String? {
    get
  }
  public var state: ZTCoreKit.ZhortechActivity.ActualStates {
    get
  }
  public var packets: [ZTCoreKit.ZhortechActivity.Packet]? {
    get
  }
  public var metaData: ZTCoreKit.ZhortechActivity.MessageActivityMetadata? {
    get
  }
  public var isRawDataMode: Swift.Bool {
    get
  }
  public var isAutomatic: Swift.Bool {
    get
  }
  public var forceStop: Swift.Bool {
    get
  }
  public var isInterrupted: Swift.Bool {
    get
  }
  public var firstChunkId: Swift.Int16 {
    get
  }
  public var lastChunkId: Swift.Int16 {
    get
  }
  public var chunkCount: Swift.Int16 {
    get
  }
  public var anchorTimestamp: Swift.Int64 {
    get
  }
  public var customActivityStartTimestamp: Swift.Int64 {
    get
  }
  public var customActivityFirstChunkId: Swift.Int16 {
    get
  }
  public var fwVersion: Swift.String? {
    get
  }
  public var shoesSerial: Swift.String {
    get
  }
  public var isNew: Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: ZTCoreKit.ZhortechActivity, rhs: ZTCoreKit.ZhortechActivity) -> Swift.Bool
  public var description: Swift.String {
    get
  }
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension ZTCoreKit.ZhortechActivity {
  public var isValidAnchorTimestamp: Swift.Bool {
    get
  }
  public mutating func anchorTimestamp(_ value: Swift.Int64)
  public mutating func resetAnchorTimestamp()
  public mutating func forceStop(_ value: Swift.Bool)
  public mutating func isAutomatic(_ value: Swift.Bool)
  #if compiler(>=5.3) && $NonescapableTypes
  public mutating func fwVersion(_ value: Swift.String?)
  #endif
  public mutating func isInterrupted(_ value: Swift.Bool)
  public mutating func activityType(_ value: Swift.String)
  public mutating func customActivityStartTimestamp(_ value: Swift.Int64)
  public mutating func startTimestamp(_ value: Swift.Int64)
  public mutating func customActivityFirstChunkId(_ value: Swift.Int16)
  public mutating func clearMetaData()
  public mutating func lastChunkId(_ value: Swift.Int16)
  public mutating func update(actualState: ZTCoreKit.ZhortechActivity.ActualStates)
  #if compiler(>=5.3) && $NonescapableTypes
  public mutating func packets(_ value: [ZTCoreKit.ZhortechActivity.Packet]?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public mutating func metaData(_ value: ZTCoreKit.ZhortechActivity.MessageActivityMetadata?)
  #endif
  public mutating func firstChunkId(_ value: Swift.Int16)
}
extension Swift.Int16 {
  public static let invalid: Swift.Int16
}
extension Swift.Int64 {
  public static let invalid: Swift.Int64
}
public actor ZhortechActivityActor : Swift.Sendable {
  public typealias ActivityState = ZTCoreKit.ZTActivityAndDataState
  public typealias ActualStates = ZTCoreKit.ZhortechActivity.ActualStates
  public typealias Packet = ZTCoreKit.ZhorthechPacket
  public typealias Activity = ZTCoreKit.ZhortechActivity
  public static var logLevel: ZTCoreKit.ZTLogLevel
  nonisolated final public let signal: ZTCoreKit.ZhortechSignalManager
  public var activityState: ZTCoreKit.ZhortechActivityActor.ActivityState
  #if compiler(>=5.3) && $NonescapableTypes
  public init(with uuid: Swift.String, currentActivity: ZTCoreKit.ZhortechActivity? = nil)
  #endif
  final public let uuid: Swift.String
  public var currentActivity: ZTCoreKit.ZhortechActivity? {
    get
  }
  public var creatingActivity: Swift.Bool {
    get
  }
  public var startingActivity: Swift.Bool {
    get
  }
  public var activityStarted: Swift.Bool {
    get
  }
  public var errors: [Swift.String] {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public func update(activity: ZTCoreKit.ZhortechActivity?) async throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func set(current activity: ZTCoreKit.ZhortechActivity?) async throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func refreshActivity(force: Swift.Bool = false, startDate: Swift.UInt32? = nil) async throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func getLatestActivity(for serial: Swift.String, force: Swift.Bool = false, startDate: Swift.UInt32? = nil) async throws -> ZTCoreKit.ZhortechActivity?
  #endif
  public func cleanup() async throws
  public func hardReset() async throws
  #if compiler(>=5.3) && $NonescapableTypes
  public func fetchActivity(withId activtyId: Swift.String) async throws -> ZTCoreKit.ZhortechActivity?
  #endif
  public func deleteActivity(withID activtyId: Swift.String) async throws
  public func resetActivity() async throws
  @objc deinit
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  @_semantics("defaultActor") nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
public struct ZhortechActivityFetchConfiguration : Swift.Sendable {
  public static let `default`: ZTCoreKit.ZhortechActivityFetchConfiguration
  public let intervalBetween2Fetches: Swift.Double
  public let packetThreshold: Swift.Int
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class ZhortechDeviceSignalManager : ObjectiveC.NSObject {
  final public let uuid: Swift.String
  public init(_ value: Swift.String)
  final public let onGeneralStateUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTDeviceActualState>
  final public let onBatteryValueUpdated: ZTCoreKit.ZTSignal<()>
  final public let onTimeUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageTime?>
  final public let onRealtimeMetricReceived: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTRealtimeMessage, Any, [Swift.UInt8])>
  final public let onBootloaderInfoUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageBootloaderInfo?>
  final public let onSoftwareUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageSoftware?>
  final public let onFirmwareError: ZTCoreKit.ZTSignal<ZTCoreKit.ZTError.Enums.FirmwareError>
  final public let onNotifyChunkConfigUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageChunkConfig?>
  final public let onInactivityTimeoutUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageInactivityTimeout?>
  final public let onRealtimeMessageUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTRealtimeMessage?, [Swift.UInt8]?)>
  final public let onRSSIChanged: ZTCoreKit.ZTSignal<(any ZTCoreKit.ZTDeviceProtocol, Swift.Int)>
  final public let onStateChanged: ZTCoreKit.ZTSignal<((any ZTCoreKit.ZTDeviceProtocol)?, (any Swift.Error)?)>
  final public let onActivityInfoUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageActivity?>
  final public let onNotifyValueUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.GroupID, Swift.UInt8, [Swift.UInt8]?)>
  final public let onRawDataHeaderUpdated: ZTCoreKit.ZTSignal<Foundation.Data?>
  final public let onRawDataFrameUpdated: ZTCoreKit.ZTSignal<Foundation.Data?>
  final public let onNotifyChunkSendStatusUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageChunkSendStatus?>
  final public let onNotifyCommonGroupUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.CommonMessageId, [Swift.UInt8]?)>
  final public let onNotifyWarmGroupUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.WarmMessageId, Foundation.Data?)>
  final public let onNotifyRunningGroupUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.RunningMessageId, [Swift.UInt8]?)>
  final public let onNotifyCyclingGroupUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.CyclingMessageId, [Swift.UInt8]?)>
  final public let onNotifySafetyGroupUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.SafetyMessageId, [Swift.UInt8]?)>
  final public let onNotifyGenericGroupUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.GenericMessageId, [Swift.UInt8]?)>
  final public let onCommandUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTCommandResponse?>
  final public let onCommandAck: ZTCoreKit.ZTSignal<ZTCoreKit.ZTCommandResponse?>
  final public let onIndicateValueUpdated: ZTCoreKit.ZTSignal<Foundation.Data?>
  final public let onNotifyChunkDataUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageChunkData?>
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class ZhortechSignalManager : ObjectiveC.NSObject {
  final public let uuid: Swift.String
  public init(with value: Swift.String)
  final public let keyingAndDfuRequired: ZTCoreKit.ZTSignal<Swift.Bool>
  final public let onDfuStateUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageBootloaderInfo.DfuState>
  final public let onDfuUploadProgress: ZTCoreKit.ZTSignal<Swift.Float?>
  final public let onDfuUploadProgressLeft: ZTCoreKit.ZTSignal<Swift.Float?>
  final public let onDfuUploadProgressRight: ZTCoreKit.ZTSignal<Swift.Float?>
  final public let onDfuFinishedLeft: ZTCoreKit.ZTSignal<ZTCoreKit.ZTError?>
  final public let onDfuFinishedRight: ZTCoreKit.ZTSignal<ZTCoreKit.ZTError?>
  final public let onDfuFinished: ZTCoreKit.ZTSignal<ZTCoreKit.ZTError?>
  final public let onDfuCopied: ZTCoreKit.ZTSignal<()>
  final public let onDfuChanged: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTDFUState, ZTCoreKit.ZTError?)>
  final public var onRealtimeMetricReceived: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTRealtimeMetric?, Any?)>
  final public let onActivityStateChange: ZTCoreKit.ZTSignal<(Swift.String?, ZTCoreKit.ZTDeviceActualState, (any Swift.Error)?)>
  final public let onActivityStopped: ZTCoreKit.ZTSignal<(Swift.String?, ZTCoreKit.ZTDeviceActualState, (any Swift.Error)?)>
  final public let onAnalyticsDataUpdated: ZTCoreKit.ZTSignal<()>
  final public let onActivityError: ZTCoreKit.ZTSignal<ZTCoreKit.ZTError?>
  final public let onActivityDataReceived: ZTCoreKit.ZTSignal<()>
  final public let onActivityMetadataUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZhortechMessageActivityMetadata?>
  final public let onChunksDownloadProgress: ZTCoreKit.ZTSignal<Swift.Float?>
  final public let onChunkStatusUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZhortechMessageActivityMetadata?>
  final public let onRawDataFlowStateChange: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTRawDataFlowStates?, (any Swift.Error)?)>
  final public let onRawDataFlowProgresss: ZTCoreKit.ZTSignal<Swift.Float>
  final public let onAuthorizationChange: ZTCoreKit.ZTSignal<ZTCoreKit.ZTManagerAuthorization>
  final public let onBluetoothStateChange: ZTCoreKit.ZTSignal<ZTCoreKit.ZTManagerState>
  final public let onScanFinished: ZTCoreKit.ZTSignal<(any Swift.Error)?>
  final public let onReconnectFailed: ZTCoreKit.ZTSignal<(any Swift.Error)?>
  final public let onCommandAck: ZTCoreKit.ZTSignal<ZTCoreKit.ZTCommandResponse?>
  final public let onDeviceStateChange: ZTCoreKit.ZTSignal<((any ZTCoreKit.ZTDeviceProtocol)?, (any Swift.Error)?)>
  final public let onDeviceDiscovered: ZTCoreKit.ZTSignal<any ZTCoreKit.ZTDeviceProtocol>
  final public let onDeviceConnectionFailed: ZTCoreKit.ZTSignal<((any ZTCoreKit.ZTDeviceProtocol)?, (any Swift.Error)?)>
  @objc deinit
}
public struct ZhorthechPacket : Swift.Codable, Swift.Identifiable, Swift.Sendable {
  public typealias Activity = ZTCoreKit.ZhortechActivity
  public var id: Swift.Int16 {
    get
  }
  public var createdAt: Foundation.Date {
    get
  }
  public var dbCreated: Swift.Bool
  public var fulfilledAt: Foundation.Date? {
    get
  }
  public var scheduledDeleted: Foundation.Date? {
    get
  }
  public var sentAt: Foundation.Date? {
    get
  }
  public var rawData: Foundation.Data? {
    get
  }
  public var activityId: Swift.String? {
    get
  }
  public var activityType: ZTCoreKit.ZhorthechPacket.Mode? {
    get
  }
  public var status: ZTCoreKit.ZhorthechPacket.Status {
    get
  }
  public var timestampType: ZTCoreKit.ZhorthechPacket.TimestampType {
    get
  }
  public var bmTimestampType: ZTCoreKit.ZhorthechPacket.BmTimestampType {
    get
  }
  public var packetType: ZTCoreKit.ZhorthechPacket.PacketType {
    get
  }
  public var originalTimestamp: Swift.Int64 {
    get
  }
  public var packetsNumber: Swift.Int16 {
    get
  }
  public var fwVersion: Swift.String? {
    get
  }
  public var retryCount: Swift.Int16 {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init(data: Foundation.Data, activity: ZTCoreKit.ZhorthechPacket.Activity? = nil, fwVersion: Swift.String? = nil, name: Swift.String = "BA")
  #endif
  public var safeTimestamp: Swift.Int64 {
    get
  }
  public var safeDuration: Swift.Int64 {
    get
  }
  public var timestamp: Swift.Int64
  public var key: Swift.String {
    get
  }
  public mutating func forceDelete()
  public typealias ID = Swift.Int16
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ZTActivityAndDataState : Swift.Codable {
  public static func newState() -> ZTCoreKit.ZTActivityAndDataState
  public var isObtainingData: Swift.Bool {
    get
    set
  }
  public var isChecking: Swift.Bool {
    get
    set
  }
  public var isCheckingMonitoredActivity: Swift.Bool {
    get
    set
  }
  public var isActivityChunksSyncing: Swift.Bool {
    get
    set
  }
  public mutating func resetInProgresValues()
  public var currentRawDataFilePath: Foundation.URL?
  public var isObtainingRawData: Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  public var rawDataDirectory: Foundation.URL? {
    get
  }
  #endif
  public var isResetActivity: Swift.Bool {
    get
    set
  }
  public var isStartingActivity: Swift.Bool {
    get
    set
  }
  public var lastStartingActivity: Foundation.Date
  public var isStartingActivityForceAttempt: Swift.Int
  public var isCheckingAnalyticsData: Swift.Bool
  public var shouldStartActivity: Swift.Bool
  public var isEnablingRealtimeStreaming: Swift.Bool
  public var defaultChunkDurationSeconds: Swift.Int
  public var chunkDuration: Swift.Int {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var userDataParameters: ZTCoreKit.ZTUserDataParameters? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var isMonitoringActivity: Swift.Bool? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var lastFirmwareCheckDate: Foundation.Date? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var lastAnalyticsDataCheckDate: Foundation.Date? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var lastChunkInterruptionDate: Foundation.Date? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var currentMode: ZTCoreKit.ZTActivityMode? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public mutating func update(userData: ZTCoreKit.ZTUserDataParameters?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public mutating func update(userData newValue: ZTCoreKit.ZTActivityMode?)
  #endif
  public var currentPacketDownloadProgress: Swift.Float
  public var lastPacketDownloadProgress: Swift.Float
  public var totalPacketsToDownload: Swift.Int
  public mutating func resetChunkDownloadProgress()
  public mutating func interruptedChunk()
  public var isUserDataSet: Swift.Bool {
    get
  }
  public var isNotObtainingData: Swift.Bool {
    get
  }
  public static let defaultChunkDuration: Swift.Int
  public static let defaultChunkInterruptionTimeout: Swift.Double
  public static let defaultNumberOfStrides: Swift.UInt8
  public static let mobilityNumberOfStrides: Swift.UInt8
  public var mobilityScanState: ZTCoreKit.ZTMobilityScanState
  public var noMobilityScan: Swift.Bool {
    get
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension ZTCoreKit.ZhortechActivityActor {
  public func isObtainingData(_ value: Swift.Bool)
  public func isCheckingMonitoredActivity(_ value: Swift.Bool)
  public func isCheckingActivity(_ value: Swift.Bool)
  public func resetInProgresValues()
  public func isCheckingAnalyticsData(_ value: Swift.Bool)
  #if compiler(>=5.3) && $NonescapableTypes
  public func lastAnalyticsDataCheckDate(_ value: Foundation.Date?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func lastFirmwareCheckDate(_ value: Foundation.Date?)
  #endif
  public func lastStartingActivity(_ value: Foundation.Date)
  public func totalPacketsToDownload(_ value: Swift.Int)
  public func shouldStartActivity(_ value: Swift.Bool)
  public func isStartingActivity(_ value: Swift.Bool)
  public func isMonitoringActivity(_ value: Swift.Bool)
  public func isResetActivity(_ value: Swift.Bool)
  public func isActivityChunksSyncing(_ value: Swift.Bool)
  public func currentPacketDownloadProgress(_ value: Swift.Float)
  public func lastPacketDownloadProgress(_ value: Swift.Float)
  public func chunkDuration(_ value: Swift.Int)
  public func mobilityScanState(_ value: ZTCoreKit.ZTMobilityScanState)
  public func resetChunkDownloadProgress() -> Swift.Float
  #if compiler(>=5.3) && $NonescapableTypes
  public func update(userData: ZTCoreKit.ZTUserDataParameters?)
  #endif
  public func isEnablingRealtimeStreaming(_ value: Swift.Bool)
  public func interruptedChunk()
  public func isObtainingRawData(_ value: Swift.Bool)
  #if compiler(>=5.3) && $NonescapableTypes
  public func currentRawDataFilePath(_ value: Foundation.URL?)
  #endif
  public func startingActivityForceAttempt()
  public func resetActivityForceAttempt()
  public func defaultChunkDurationSeconds(_ value: Swift.Int)
}
@objc final public class ZTBleManager : ObjectiveC.NSObject {
  public init(manager: ZTCoreKit.ZhortechSignalManager)
  #if compiler(>=5.3) && $NonescapableTypes
  final public class var instance: ZTCoreKit.ZTBleManager? {
    get
  }
  #endif
  final public var managerState: ZTCoreKit.ZTBleManagerState {
    get
  }
  final public let signalManager: ZTCoreKit.ZhortechSignalManager
  #if compiler(>=5.3) && $NonescapableTypes
  final public var macAddress: Swift.String? {
    get
  }
  #endif
  final public var deviceInfo: ZTCoreKit.ZTDeviceInfo?
  final public var product: ZTCoreKit.ZTProductType? {
    get
    set
  }
  final public var connectedDevice: ZTCoreKit.ZTDevice? {
    get
  }
  final public var scanning: Swift.Bool {
    get
  }
  final public var isDfuMode: Swift.Bool {
    get
  }
  public static var authorization: ZTCoreKit.ZTManagerAuthorization {
    get
  }
  final public func stopScan()
  @objc deinit
}
extension ZTCoreKit.ZTBleManager {
  final public var onAuthorizationChange: ZTCoreKit.ZTSignal<ZTCoreKit.ZTManagerAuthorization> {
    get
  }
  final public var onBluetoothStateChange: ZTCoreKit.ZTSignal<ZTCoreKit.ZTManagerState> {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onScanFinished: ZTCoreKit.ZTSignal<(any Swift.Error)?> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onReconnectFailed: ZTCoreKit.ZTSignal<(any Swift.Error)?> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onCommandAck: ZTCoreKit.ZTSignal<ZTCoreKit.ZTCommandResponse?> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onDeviceStateChange: ZTCoreKit.ZTSignal<((any ZTCoreKit.ZTDeviceProtocol)?, (any Swift.Error)?)> {
    get
  }
  #endif
  final public var onDeviceDiscovered: ZTCoreKit.ZTSignal<any ZTCoreKit.ZTDeviceProtocol> {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onDeviceConnectionFailed: ZTCoreKit.ZTSignal<((any ZTCoreKit.ZTDeviceProtocol)?, (any Swift.Error)?)> {
    get
  }
  #endif
}
public protocol ZTDfuDelegate : AnyObject {
  #if compiler(>=5.3) && $NonescapableTypes
  func dfuDelegate(firmwareDownloaded: Swift.Bool, version: Swift.String?)
  #endif
  func dfuDelegate(didFinish: Swift.Bool)
  #if compiler(>=5.3) && $NonescapableTypes
  func dfuDelegate(didFail error: ZTCoreKit.ZTError?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func dfuDelegate(progress: Swift.Float?)
  #endif
  func dfuDelegate(leftProgress: Swift.Int)
  func dfuDelegate(rightProgress: Swift.Int)
  #if compiler(>=5.3) && $NonescapableTypes
  func dfuDelegate(leftDidFinish newVersion: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func dfuDelegate(rightDidFinish newVersion: Swift.String?)
  #endif
}
extension ZTCoreKit.ZTDfuDelegate {
  public func dfuDelegate(leftProgress: Swift.Int)
  public func dfuDelegate(rightProgress: Swift.Int)
}
public enum ZTPeripheralState : Swift.Int, Swift.Sendable {
  case disconnected
  case connecting
  case connected
  case disconnecting
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public protocol ZTPeripheralProtocol : AnyObject {
  var identifier: Foundation.UUID { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var name: Swift.String? { get }
  #endif
  var state: ZTCoreKit.ZTPeripheralState { get }
  func readRSSI()
}
extension ZTCoreKit.ZTPeripheralProtocol {
  public func readRSSI()
}
extension ZTCoreKit.ZTCore {
  final public func startDFU() async throws
  final public func updateFirmware()
  final public func updateFirmware(path: Swift.String)
}
extension ZTCoreKit.ZTCore {
  #if compiler(>=5.3) && $NonescapableTypes
  final public func isDummyFirmware(packageType: ZTCoreKit.ZTDfuPackageType? = nil, installFW: Swift.Bool = true)
  #endif
}
public enum ZhortechBaseException : Swift.Error {
  case requestTimeout
  case unknown
  public static func == (a: ZTCoreKit.ZhortechBaseException, b: ZTCoreKit.ZhortechBaseException) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension ZTCoreKit.ZhortechBaseException {
  public static func from(any error: any Swift.Error) -> ZTCoreKit.ZhortechBaseException
}
public enum ZTBaseError : Swift.Equatable, Swift.Error {
  case noDeviceConnectedMainSDK
  case noDeviceConnectedZhortechBase
  case failedDownloadingRawData
  case busy
  public static func == (a: ZTCoreKit.ZTBaseError, b: ZTCoreKit.ZTBaseError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ZTBaseRaw {
  public static let shared: ZTCoreKit.ZTBaseRaw
  public var active: Swift.Bool {
    get
  }
  @objc deinit
}
@available(*, deprecated, message: "This method is not needed anymore. You can remove it.")
extension ZTCoreKit.ZTBaseRaw {
  @discardableResult
  public func switchToZhortechBase() async throws -> Swift.Bool
  @discardableResult
  public func switchToZhortechSDK1() async throws -> Swift.Bool
}
extension ZTCoreKit.ZTBaseRaw {
  public func downloadProcessedData(from startIndex: Swift.Int32, to endIndex: Swift.Int32) async throws -> [Foundation.Data]
}
public struct ZTBaseRawDownload : Swift.Sendable {
  public var rawdataActivityKey: Swift.String {
    get
  }
  public var downloadingRight: Swift.Bool {
    get
  }
  public var downloadingLeft: Swift.Bool {
    get
  }
  public var progress: Swift.Float {
    get
  }
  public var totalBytesReceived: Swift.Int {
    get
  }
}
extension ZTCoreKit.ZTBaseRaw {
  public func downloadRawData(parallels: Swift.Bool = true) -> _Concurrency.AsyncThrowingStream<ZTCoreKit.ZTBaseRawDownload, any Swift.Error>
}
extension ZTCoreKit.ZTCore {
  #if compiler(>=5.3) && $NonescapableTypes
  final public func checkConnectedDevice(completion: ZTCoreKit.ConnectResultBlock? = nil)
  #endif
}
extension ZTCoreKit.ZTDevice {
  @discardableResult
  final public func getTimestamp() async throws -> ZTCoreKit.ZTMessageTime
  final public func resetAnchorTimestamp() async throws
  final public func checkAnchorTimestamp() async throws
  final public func startNewChunk() async throws
}
extension ZTCoreKit.ZTDevice {
  final public var isConnected: Swift.Bool {
    get
  }
  final public func refreshConnectedDevice() async
  @discardableResult
  final public func requestBattery() async throws -> ZTCoreKit.ZTBatteryLevel
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  final public func readGeneralState() async throws -> ZTCoreKit.ZTMessageGeneralState?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  final public func readFirmware() async throws -> (right: ZTCoreKit.ZTFirmwareRevision?, left: ZTCoreKit.ZTFirmwareRevision?)
  #endif
  @discardableResult
  final public func readMetaData() async throws -> ZTCoreKit.ZhortechMessageActivityMetadata
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  final public func readPeerMacAdress() async throws -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  final public func readHardwareVersion() async throws -> Swift.String?
  #endif
  @discardableResult
  final public func readTimeStamp() async throws -> ZTCoreKit.ZTMessageTime
  @discardableResult
  final public func startRawData() async throws -> Swift.Bool
  @discardableResult
  final public func stopRawData() async throws -> Swift.Bool
  final public func getPublicKey() async throws -> (right: Swift.String, left: Swift.String)
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  @available(*, unavailable)
  final public func readInactivityTimeout() async throws -> ZTCoreKit.ZTMessageInactivityTimeout?
  #endif
  final public func resetActivity() async throws
}
extension ZTCoreKit.ZTDevice {
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  final public func send(_ command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil, raw: Swift.Bool = false) async throws -> Swift.Bool
  #endif
  @discardableResult
  final public func sendRaw(bytes: [Swift.UInt8]) async throws -> Swift.Bool
  final public func startActivity(automatic: Swift.Bool = true, raw: Swift.Bool = false) async throws
  final public func stopActivity(raw: Swift.Bool = false) async throws
}
extension ZTCoreKit.ZTDevice {
  final public func listen(metrics: [ZTCoreKit.ZTRealtimeMetric])
  final public func listenRealTimeData()
  final public func stopAllRealtime()
}
public class ZTListner {
  public init()
  @objc deinit
}
@objc final public class ZTDevice : ObjectiveC.NSObject, @unchecked Swift.Sendable {
  final public var id: Swift.String
  final public var cbPeripheral: (any ZTCoreKit.ZTPeripheralProtocol)? {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var peripheral: (any ZTCoreKit.ZTPeripheralProtocol)? {
    get
  }
  #endif
  final public var serialNumber: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var name: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var qrCode: Swift.String? {
    get
  }
  #endif
  final public var rssi: Swift.Int {
    get
  }
  final public var macAddressRight: Swift.String?
  final public var macAddressLeft: Swift.String?
  final public var advertisementData: [Swift.String : Any]?
  final public var manufacturer: Swift.String? {
    get
  }
  final public var hardwareRevision: Swift.String? {
    get
  }
  final public var firmwareRevision: ZTCoreKit.ZTFirmwareRevision? {
    get
  }
  final public var autoIndicateChunkData: Swift.Bool
  final public var isDummyFirmware: Swift.Bool {
    get
  }
  final public var modelNumber: Swift.String? {
    get
  }
  final public var uuid: Swift.String {
    get
  }
  final public var isActivityRunning: Swift.Bool {
    get
  }
  final public var rawDataFlowInProgress: Swift.Bool
  final public var isDeviceReady: Swift.Bool {
    get
  }
  final public var info: ZTCoreKit.ZTDeviceInfo? {
    get
    set
  }
  final public var metaData: ZTCoreKit.ZhortechMessageActivityMetadata? {
    get
  }
  final public var timestamp: ZTCoreKit.ZTMessageTime? {
    get
  }
  final public var batterylevel: ZTCoreKit.ZTBatteryLevel? {
    get
  }
  final public var lastActivityDate: Foundation.Date {
    get
  }
  final public var generalState: ZTCoreKit.ZTMessageGeneralState? {
    get
    set
  }
  final public var activityNotStartedOnBothSide: Swift.Bool {
    get
  }
  final public var softwareInfo: (right: ZTCoreKit.ZTMessageSoftware?, left: ZTCoreKit.ZTMessageSoftware?) {
    get
    set
  }
  final public var lowSoftwareInfo: Swift.String {
    get
  }
  final public var activityInfo: ZTCoreKit.ZTMessageActivity? {
    get
    set
  }
  final public var bootloaderInfo: (right: ZTCoreKit.ZTMessageBootloaderInfo?, left: ZTCoreKit.ZTMessageBootloaderInfo?) {
    get
    set
  }
  final public var inactivityTimeout: ZTCoreKit.ZTMessageInactivityTimeout? {
    get
    set
  }
  final public var actualState: ZTCoreKit.ZTDeviceActualState {
    get
  }
  final public var previousState: ZTCoreKit.ZTDeviceActualState {
    get
  }
  final public func disconnect()
  final public var isReady: Swift.Bool
  required public init(peripheral: any ZTCoreKit.ZTPeripheralProtocol, manager: ZTCoreKit.ZhortechActivityActor)
  final public func readBatteryLevel()
  @available(*, deprecated, message: "Use `checkBattery() async throws` instead")
  final public func checkBattery(completion: @escaping (Swift.UInt8, Swift.UInt8, Swift.Bool) -> Swift.Void)
  final public func checkBattery() async throws -> (left: Swift.UInt8, right: Swift.UInt8, lowBattery: Swift.Bool)
  final public func readGeneralState()
  @objc deinit
}
extension ZTCoreKit.ZTDevice {
  public static func == (lhs: ZTCoreKit.ZTDevice, rhs: ZTCoreKit.ZTDevice) -> Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  final public var isLowBattery: Swift.Bool? {
    get
  }
  #endif
}
@available(*, deprecated, message: "Should not be use anymore... See device.")
extension ZTCoreKit.ZTDevice {
  #if compiler(>=5.3) && $NonescapableTypes
  final public func sendWithAck(_ command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil) async throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func sendWithRightAck(_ command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil) async throws
  #endif
}
@available(*, deprecated, message: "Should not be use anymore... See device.")
extension ZTCoreKit.ZTDevice {
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  final public func sendCommand(_ command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil) async -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  final public func sendCommandWithAck(_ command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil) async -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  final public func sendCommandWithRightAck(command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil) async -> Swift.Bool
  #endif
}
@available(*, deprecated, message: "Should not be use anymore... See device.")
extension ZTCoreKit.ZTDevice {
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  final public func sendCommandWithStateUpdate(_ command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil, timeout: Swift.Double = 15) async throws -> ZTCoreKit.ZTDeviceActualState?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  final public func sendCommandWithUpdate<T>(_ command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil, timeout: Swift.Double = 15, name: Swift.String?, signal: ZTCoreKit.ZTSignal<T>) async throws -> T?
  #endif
}
@available(*, deprecated, message: "Should not be use anymore... See device.")
extension ZTCoreKit.ZTCore {
  #if compiler(>=5.3) && $NonescapableTypes
  final public func sendToConnectedDevice(_ command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil) async throws
  #endif
}
@available(*, deprecated, message: "This method is deprecated. Use async version instead.")
extension ZTCoreKit.ZTDevice {
  #if compiler(>=5.3) && $NonescapableTypes
  final public func sendCommand(_ command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func sendCommandWithAck(command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil, completion: @escaping ZTCoreKit.ZTBaseResult)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func sendCommandWithRightAck(command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil, completion: @escaping ZTCoreKit.ZTBaseResult)
  #endif
}
extension ZTCoreKit.ZTDevice {
  final public var onGeneralStateUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTDeviceActualState> {
    get
  }
  final public var onBatteryValueUpdated: ZTCoreKit.ZTSignal<()> {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onTimeUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageTime?> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onRealtimeMessageUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTRealtimeMessage?, [Swift.UInt8]?)> {
    get
  }
  #endif
  final public var onRealtimeMetricReceived: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTRealtimeMessage, Any, [Swift.UInt8])> {
    get
  }
  final public var onRSSIChanged: ZTCoreKit.ZTSignal<(any ZTCoreKit.ZTDeviceProtocol, Swift.Int)> {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onStateChanged: ZTCoreKit.ZTSignal<((any ZTCoreKit.ZTDeviceProtocol)?, (any Swift.Error)?)> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onActivityInfoUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageActivity?> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onBootloaderInfoUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageBootloaderInfo?> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onSoftwareUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageSoftware?> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onNotifyValueUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.GroupID, Swift.UInt8, [Swift.UInt8]?)> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onRawDataHeaderUpdated: ZTCoreKit.ZTSignal<Foundation.Data?> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onRawDataFrameUpdated: ZTCoreKit.ZTSignal<Foundation.Data?> {
    get
  }
  #endif
  final public var onFirmwareError: ZTCoreKit.ZTSignal<ZTCoreKit.ZTError.Enums.FirmwareError> {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onNotifyCommonGroupUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.CommonMessageId, [Swift.UInt8]?)> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onNotifyWarmGroupUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.WarmMessageId, Foundation.Data?)> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onNotifyRunningGroupUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.RunningMessageId, [Swift.UInt8]?)> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onNotifyCyclingGroupUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.CyclingMessageId, [Swift.UInt8]?)> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onNotifySafetyGroupUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.SafetyMessageId, [Swift.UInt8]?)> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onNotifyGenericGroupUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.GenericMessageId, [Swift.UInt8]?)> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onCommandUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTCommandResponse?> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onCommandAck: ZTCoreKit.ZTSignal<ZTCoreKit.ZTCommandResponse?> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onIndicateValueUpdated: ZTCoreKit.ZTSignal<Foundation.Data?> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onNotifyChunkSendStatusUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageChunkSendStatus?> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onNotifyChunkConfigUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageChunkConfig?> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onNotifyChunkDataUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageChunkData?> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onInactivityTimeoutUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageInactivityTimeout?> {
    get
  }
  #endif
}
extension ZTCoreKit.ZTDevice : ZTCoreKit.ZTDeviceProtocol {
  #if compiler(>=5.3) && $NonescapableTypes
  final public var fwVersion: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var activityType: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var moduleSerialNo: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var deviceIdentifier: Swift.String? {
    get
  }
  #endif
}
public typealias ConnectResultBlock = (ZTCoreKit.ZTDevice?, (any Swift.Error)?) -> Swift.Void
public typealias ScanResultBlock = (ZTCoreKit.ZTDevice?, (any Swift.Error)?) -> Swift.Void
public typealias ScanFinishedBlock = ((any Swift.Error)?) -> Swift.Void
@_hasMissingDesignatedInitializers final public class ZTCore {
  public static let version: Swift.String
  final public var zcVersion: Swift.String {
    get
  }
  public static let shared: ZTCoreKit.ZTCore
  #if compiler(>=5.3) && $NonescapableTypes
  final public var bleManager: ZTCoreKit.ZTBleManager? {
    get
  }
  #endif
  final public var settings: ZTCoreKit.ZTSettings {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var appUserId: Swift.String? {
    get
  }
  #endif
  final public var lastCommand: ZTCoreKit.ZTCommand?
  final public var lastCommandResponses: [ZTCoreKit.ZTCommandResponse]
  #if compiler(>=5.3) && $NonescapableTypes
  final public var lastActivityId: Swift.String? {
    get
  }
  #endif
  final public var leftModuleCommandStatus: ZTCoreKit.ZTCommandStatus {
    get
  }
  final public var connectedDevice: ZTCoreKit.ZTDevice? {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var lastDeviceSerialNumber: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var lastDeviceQRCode: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var lastQRCode: Swift.String? {
    get
  }
  #endif
  final public var isDfuInProgress: Swift.Bool {
    get
  }
  final public var isSecureDfuInProgress: Swift.Bool {
    get
  }
  final public var longRangePHY: Swift.Bool {
    get
  }
  final public var agressiveConnInterval: Swift.Bool {
    get
  }
  final public var needImprovedConnectivity: Swift.Bool {
    get
  }
  final public var activityManager: ZTCoreKit.ZhortechActivityActor {
    get
  }
  final public var signalManager: ZTCoreKit.ZhortechSignalManager {
    get
  }
  final public var connecting: Swift.Bool {
    get
  }
  final public var backgroundDFUEnable: Swift.Bool {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var savedFirmware: Swift.String? {
    get
  }
  #endif
  weak final public var dfuDelegate: (any ZTCoreKit.ZTDfuDelegate)?
  final public var firmwareDfuState: ZTCoreKit.DFUState? {
    get
  }
  final public var currentDfuState: ZTCoreKit.ZTMessageBootloaderInfo.DfuState {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var savedDevice: ZTCoreKit.ZTSavedDevice? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func savedDevice(for serial: Swift.String) -> ZTCoreKit.ZTSavedDevice?
  #endif
  @objc deinit
}
extension ZTCoreKit.ZTCore {
  #if compiler(>=5.3) && $NonescapableTypes
  final public func setup(apiKey: Swift.String, secret: Swift.String, appId: Swift.String, completion: (((any Swift.Error)?) -> Swift.Void)? = nil)
  #endif
  final public func clearUser()
  #if compiler(>=5.3) && $NonescapableTypes
  final public func updateOrganization(code: Swift.String? = nil, appType: Swift.String? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func connect(withCode code: Swift.String, timeout: Swift.Double? = 20) async throws -> ZTCoreKit.ZTDevice
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func getDeviceInfo(code: Swift.String, completion: @escaping (ZTCoreKit.ZTDeviceInfo?, (any Swift.Error)?) -> Swift.Void)
  #endif
  @discardableResult
  final public func getDeviceInfo(code: Swift.String) async throws -> ZTCoreKit.ZTDeviceInfo
  #if compiler(>=5.3) && $NonescapableTypes
  final public func tryReconnect(completion: ZTCoreKit.ConnectResultBlock? = nil)
  #endif
  final public func setDeepSleepMode() async throws
}
extension ZTCoreKit.ZTCore {
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, renamed: "connect(withCode:timeout:)", message: "Use Swift concurrency Async/Await instead of completion.")
  final public func connectWithCode(_ code: Swift.String, timeout: Swift.Double? = 20, completion: @escaping ZTCoreKit.ConnectResultBlock)
  #endif
}
extension ZTCoreKit.ZTCore {
  #if compiler(>=5.3) && $NonescapableTypes
  final public func isPendingEmbeddedActivity(completion: @escaping (Swift.Bool, ZTCoreKit.ZTError?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func pushPendingEmbeddedActivities(completion: @escaping (ZTCoreKit.ZTError?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func createActivity(metaJSON: Swift.String? = nil) async
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func update(currentActivity: ZTCoreKit.ZhortechActivity?) async throws
  #endif
}
@available(iOS 16.0, *)
extension ZTCoreKit.ZTCore {
  public typealias UserData = ZTCoreKit.ZTCoreUserData
  final public func postUserData(model: Swift.String, objects: [ZTCoreKit.ZTCore.UserData]) async throws
  final public func patchUserData(model: Swift.String, objectId: ZTCoreKit.ZTCore.UserData.ID, objects: [ZTCoreKit.ZTCore.UserData]) async throws
  final public func deleteUserData(model: Swift.String, objectId: ZTCoreKit.ZTCore.UserData.ID) async throws
  final public func getUserData(model: Swift.String, objectId: ZTCoreKit.ZTCore.UserData.ID) async throws -> [ZTCoreKit.ZTCore.UserData]
  #if compiler(>=5.3) && $NonescapableTypes
  final public func getUserDataLatestID(model: Swift.String) async throws -> ZTCoreKit.ZTCore.UserData.ID?
  #endif
}
extension ZTCoreKit.ZTCore {
  final public func improvedConnectivity(_ value: Swift.Bool, for timeInterval: Foundation.TimeInterval = 0)
}
@available(iOS 16.0, *)
extension ZTCoreKit.ZTCore {
  final public func setTxPower(value: ZTCoreKit.ZTTXPower) async throws
  final public func setPHYLongRange(active: Swift.Bool = true) async throws
  final public func setAgressiveConnInterval(active: Swift.Bool = true) async throws
  final public func schedule(delay: Foundation.TimeInterval, cancelOnSleeep: Swift.Bool = false, commands: [Swift.UInt8]) async throws
  final public func clearSchedule() async throws
  @discardableResult
  final public func increaseLeftRightConnIntervalWithAck() async throws -> Swift.Bool
  @discardableResult
  final public func increaseAckTimeoutWithAck() async throws -> Swift.Bool
}
extension ZTCoreKit.ZTCore {
  @available(*, deprecated, message: "Use set `setTxPower(value: ZTTXPower)`.")
  final public func setTxPowerWithAck(value: ZTCoreKit.ZTTXPower) async throws -> Swift.Bool
}
extension ZTCoreKit.ZTCore {
  #if compiler(>=5.3) && $NonescapableTypes
  final public func isFirmwareUpdateRequired(firmwareRevision: ZTCoreKit.ZTFirmwareRevision, completion: @escaping (Swift.Bool, ZTCoreKit.ZTError?) -> Swift.Void)
  #endif
  final public func isFirmwareUpdateRequired(firmwareRevision: ZTCoreKit.ZTFirmwareRevision) async throws -> Swift.Bool
}
extension ZTCoreKit.ZTApi {
  #if compiler(>=5.3) && $NonescapableTypes
  final public func checkFirmwareUpdate(completion: @escaping (Swift.Bool, ZTCoreKit.ZTError?) -> Swift.Void)
  #endif
}
extension ZTCoreKit.ZTCore {
  final public var keyingAndDfuRequired: ZTCoreKit.ZTSignal<Swift.Bool> {
    get
  }
  final public var onDfuStateUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageBootloaderInfo.DfuState> {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onDfuUploadProgress: ZTCoreKit.ZTSignal<Swift.Float?> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onDfuFinishedLeft: ZTCoreKit.ZTSignal<ZTCoreKit.ZTError?> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onDfuFinishedRight: ZTCoreKit.ZTSignal<ZTCoreKit.ZTError?> {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var onDfuFinished: ZTCoreKit.ZTSignal<ZTCoreKit.ZTError?> {
    get
  }
  #endif
  final public var onDfuCopied: ZTCoreKit.ZTSignal<()> {
    get
  }
}
extension ZTCoreKit.ZTSettings {
  final public func clear()
}
final public class CentralManager : Swift.Sendable {
  final public var bluetoothState: CoreBluetooth.CBManagerState {
    get
  }
  final public var isScanning: Swift.Bool {
    get async
  }
  final public var eventPublisher: Combine.AnyPublisher<ZTCoreKit.CentralManagerEvent, Swift.Never> {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init(dispatchQueue: Dispatch.DispatchQueue? = nil, options: [Swift.String : Any]? = nil)
  #endif
  final public func waitUntilReady() async throws
  #if compiler(>=5.3) && $NonescapableTypes
  final public func scanForPeripherals(withServices serviceUUIDs: [CoreBluetooth.CBUUID]?, options: [Swift.String : any Swift.Sendable]? = nil) async throws -> _Concurrency.AsyncStream<ZTCoreKit.ScanData>
  #endif
  final public func stopScan() async
  #if compiler(>=5.3) && $NonescapableTypes
  final public func connect(_ peripheral: ZTCoreKit.Peripheral, options: [Swift.String : any Swift.Sendable]? = nil) async throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(macOS, unavailable)
  final public func registerForConnectionEvents(options: [CoreBluetooth.CBConnectionEventMatchingOption : Any]? = nil)
  #endif
  final public func cancelPeripheralConnection(_ peripheral: ZTCoreKit.Peripheral) async throws
  final public func retrievePeripherals(withIdentifiers identifiers: [Foundation.UUID]) -> [ZTCoreKit.Peripheral]
  final public func retrieveConnectedPeripherals(withServices serviceUUIDs: [CoreBluetooth.CBUUID]) -> [ZTCoreKit.Peripheral]
  final public func cancelAllOperations() async
  @available(macOS, unavailable)
  public static func supports(_ features: CoreBluetooth.CBCentralManager.Feature) -> Swift.Bool
  @objc deinit
}
public enum CentralManagerEvent {
  case didUpdateState(state: CoreBluetooth.CBManagerState)
  case willRestoreState(state: [Swift.String : Any])
  case didConnectPeripheral(peripheral: ZTCoreKit.Peripheral)
  case didDisconnectPeripheral(peripheral: ZTCoreKit.Peripheral, isReconnecting: Swift.Bool = false, error: (any Swift.Error)?)
  @available(macOS, unavailable)
  case connectionEventDidOccur(connectionEvent: CoreBluetooth.CBConnectionEvent, peripheral: ZTCoreKit.Peripheral)
}
public struct ScanData : Swift.Sendable {
  public let peripheral: ZTCoreKit.Peripheral
  public let advertisementData: [Swift.String : any Swift.Sendable]
  public let rssi: Foundation.NSNumber
}
public protocol PeripheralDataConvertible {
  #if compiler(>=5.3) && $NonescapableTypes
  static func fromData(_ data: Foundation.Data) -> Self?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func toData() -> Foundation.Data?
  #endif
}
extension Swift.String : ZTCoreKit.PeripheralDataConvertible {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func fromData(_ data: Foundation.Data) -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func toData() -> Foundation.Data?
  #endif
}
extension Swift.Bool : ZTCoreKit.PeripheralDataConvertible {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func fromData(_ data: Foundation.Data) -> Swift.Bool?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func toData() -> Foundation.Data?
  #endif
}
extension Foundation.Data : ZTCoreKit.PeripheralDataConvertible {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func fromData(_ data: Foundation.Data) -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func toData() -> Foundation.Data?
  #endif
}
extension ZTCoreKit.PeripheralDataConvertible where Self : Swift.Numeric {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func fromData(_ data: Foundation.Data) -> Self?
  #endif
}
extension Swift.Int : ZTCoreKit.PeripheralDataConvertible {
  #if compiler(>=5.3) && $NonescapableTypes
  public func toData() -> Foundation.Data?
  #endif
}
extension Swift.Double : ZTCoreKit.PeripheralDataConvertible {
  #if compiler(>=5.3) && $NonescapableTypes
  public func toData() -> Foundation.Data?
  #endif
}
extension Swift.Float : ZTCoreKit.PeripheralDataConvertible {
  #if compiler(>=5.3) && $NonescapableTypes
  public func toData() -> Foundation.Data?
  #endif
}
extension ZTCoreKit.Characteristic {
  #if compiler(>=5.3) && $NonescapableTypes
  public func parsedValue<T>() throws -> T? where T : ZTCoreKit.PeripheralDataConvertible
  #endif
}
extension ZTCoreKit.CharacteristicValueUpdateEventData {
  #if compiler(>=5.3) && $NonescapableTypes
  public func parsedValue<T>() throws -> T? where T : ZTCoreKit.PeripheralDataConvertible
  #endif
}
extension ZTCoreKit.Peripheral {
  #if compiler(>=5.3) && $NonescapableTypes
  final public func readValue<Value>(forCharacteristicWithUUID characteristicUUID: Foundation.UUID, ofServiceWithUUID serviceUUID: Foundation.UUID) async throws -> Value? where Value : ZTCoreKit.PeripheralDataConvertible
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func readValue<Value>(forCharacteristicWithCBUUID characteristicCBUUID: CoreBluetooth.CBUUID, ofServiceWithCBUUID serviceCBUUID: CoreBluetooth.CBUUID) async throws -> Value? where Value : ZTCoreKit.PeripheralDataConvertible
  #endif
  final public func writeValue<Value>(_ value: Value, forCharacteristicWithUUID characteristicUUID: Foundation.UUID, ofServiceWithUUID serviceUUID: Foundation.UUID, type: CoreBluetooth.CBCharacteristicWriteType = .withResponse) async throws where Value : ZTCoreKit.PeripheralDataConvertible
  final public func writeValue<Value>(_ value: Value, forCharacteristicWithCBUUID characteristicCBUUID: CoreBluetooth.CBUUID, ofServiceWithCBUUID serviceCBUUID: CoreBluetooth.CBUUID, type: CoreBluetooth.CBCharacteristicWriteType = .withResponse) async throws where Value : ZTCoreKit.PeripheralDataConvertible
  final public func setNotifyValue(_ enabled: Swift.Bool, forCharacteristicWithUUID characteristicUUID: Foundation.UUID, ofServiceWithUUID serviceUUID: Foundation.UUID) async throws
  final public func setNotifyValue(_ enabled: Swift.Bool, forCharacteristicWithCBUUID characteristicCBUUID: CoreBluetooth.CBUUID, ofServiceWithCBUUID serviceCBUUID: CoreBluetooth.CBUUID) async throws
}
public enum BluetoothUnavailableReason {
  case poweredOff
  case unauthorized
  case unsupported
  case unknown
  public static func == (a: ZTCoreKit.BluetoothUnavailableReason, b: ZTCoreKit.BluetoothUnavailableReason) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum BluetoothError : Swift.Error {
  case bluetoothUnavailable(ZTCoreKit.BluetoothUnavailableReason)
  case connectingInProgress
  case disconnectingInProgress
  case cancelledConnectionToPeripheral
  case errorConnectingToPeripheral(error: (any Swift.Error)?)
  case characteristicNotFound
  case unableToParseCharacteristicValue
  case unableToConvertValueToData
  case noConnectionToPeripheralExists
  case operationCancelled
}
public struct Characteristic : Swift.Sendable {
  public let cbCharacteristic: CoreBluetooth.CBCharacteristic
  public init(_ cbCharacteristic: CoreBluetooth.CBCharacteristic)
  public var uuid: CoreBluetooth.CBUUID {
    get
  }
  public var properties: CoreBluetooth.CBCharacteristicProperties {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var value: Foundation.Data? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var descriptors: [ZTCoreKit.Descriptor]? {
    get
  }
  #endif
  public var isNotifying: Swift.Bool {
    get
  }
}
public struct CharacteristicValueUpdateEventData {
  public let characteristic: ZTCoreKit.Characteristic
  public let value: Foundation.Data?
}
public struct Descriptor {
  public var uuid: CoreBluetooth.CBUUID {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var value: Any? {
    get
  }
  #endif
}
final public class Peripheral : Swift.Sendable {
  final public var characteristicValueUpdatedPublisher: Combine.AnyPublisher<ZTCoreKit.CharacteristicValueUpdateEventData, Swift.Never> {
    get
  }
  final public var invalidatedServices: Combine.AnyPublisher<[ZTCoreKit.Service], Swift.Never> {
    get
  }
  final public var identifier: Foundation.UUID {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var name: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var discoveredServices: [ZTCoreKit.Service]? {
    get
  }
  #endif
  final public var state: CoreBluetooth.CBPeripheralState {
    get
  }
  final public var ancsAuthorized: Swift.Bool {
    get
  }
  final public let cbPeripheral: CoreBluetooth.CBPeripheral
  public init(_ cbPeripheral: CoreBluetooth.CBPeripheral)
  final public func readRSSI() async throws -> Foundation.NSNumber
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 11.0, *)
  final public func openL2CAPChannel(_ PSM: CoreBluetooth.CBL2CAPPSM) async throws -> CoreBluetooth.CBL2CAPChannel?
  #endif
  final public func cancelAllOperations() async
  #if compiler(>=5.3) && $NonescapableTypes
  final public func discoverServices(_ serviceUUIDs: [CoreBluetooth.CBUUID]?) async throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func discoverIncludedServices(_ includedServiceUUIDs: [CoreBluetooth.CBUUID]?, for service: ZTCoreKit.Service) async throws
  #endif
  final public func maximumWriteValueLength(for type: CoreBluetooth.CBCharacteristicWriteType) -> Swift.Int
  final public func setNotifyValue(_ enabled: Swift.Bool, for characteristic: ZTCoreKit.Characteristic) async throws
  #if compiler(>=5.3) && $NonescapableTypes
  final public func discoverCharacteristics(_ characteristicUUIDs: [CoreBluetooth.CBUUID]?, for service: ZTCoreKit.Service) async throws
  #endif
  final public func readValue(for characteristic: ZTCoreKit.Characteristic) async throws
  final public func writeValue(_ data: Foundation.Data, for characteristic: ZTCoreKit.Characteristic, type: CoreBluetooth.CBCharacteristicWriteType) async throws
  final public func discoverDescriptors(for characteristic: ZTCoreKit.Characteristic) async throws
  final public func readValue(for descriptor: ZTCoreKit.Descriptor) async throws
  final public func writeValue(_ data: Foundation.Data, for descriptor: ZTCoreKit.Descriptor) async throws
  @objc deinit
}
public struct Service : Swift.Sendable {
  public var uuid: CoreBluetooth.CBUUID {
    get
  }
  public var isPrimary: Swift.Bool {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var discoveredIncludedServices: [ZTCoreKit.Service]? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var discoveredCharacteristics: [ZTCoreKit.Characteristic]? {
    get
  }
  #endif
  public init(_ cbService: CoreBluetooth.CBService)
}
extension CoreBluetooth.CBUUID : @unchecked @retroactive Swift.Sendable {
}
@_hasMissingDesignatedInitializers final public class AsyncBluetoothLogging : Swift.Sendable {
  public static func setEnabled(_ isEnabled: Swift.Bool)
  @objc deinit
}
public struct AsyncBluetooth {
}
public struct ZTFirmware {
  public init(main: Swift.String, right: Swift.String, left: Swift.String)
}
public struct ZTModuleDetails {
}
extension Swift.Dictionary where Key == Swift.String, Value == Any {
  #if compiler(>=5.3) && $NonescapableTypes
  public var advDate: Foundation.Date? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var ztAdvMac: Swift.String? {
    get
  }
  #endif
}
extension Swift.Dictionary where Key == Swift.String, Value == any Swift.Sendable {
  #if compiler(>=5.3) && $NonescapableTypes
  public var advDate: Foundation.Date? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var ztAdvMac: Swift.String? {
    get
  }
  #endif
}
extension Foundation.Data {
  public enum Zhortech : Swift.UInt8 {
    case stopNewActivity
    case reboot
    case startDFURight
    case startDFULeft
    case hardwareInformation
    case firmwareInformation
    case bootloaderVersion
    case freeMemory
    case resetActivity
    case deepSleep
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum ZhortechBLE {
    case inhibitSleep(timeInterval: Swift.UInt32)
    case hardResetAndSleep
    case writeKey
  }
  public enum NofityCommandStatus : Swift.UInt8 {
    case success
    case busy
    case invalidParam
    case invalidState
    case forbidden
    case notSupported
    case unknownCommand
    case commandInProgress
    case noPeerresponse
    public var description: Swift.String {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum NofityCommandSide : Swift.UInt8 {
    case left
    case right
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
extension Foundation.Data {
  #if compiler(>=5.3) && $NonescapableTypes
  public var asciiString: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var utf8String: Swift.String? {
    get
  }
  #endif
  public var hexValues: Swift.String {
    get
  }
}
extension Foundation.Data {
  public static func command(for type: Foundation.Data.Zhortech) -> Foundation.Data
  public static func command(for types: [Foundation.Data.Zhortech]) -> Foundation.Data
  public static func read(for type: Foundation.Data.Zhortech) -> Foundation.Data
}
extension Foundation.Data {
  #if compiler(>=5.3) && $NonescapableTypes
  public func ztAdvMacAddress(isDFU: Swift.Bool) -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var ztMacRead: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var ztFWread: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var ztSide: Foundation.Data.NofityCommandSide? {
    get
  }
  #endif
  public var ztCommandStatus: Foundation.Data.NofityCommandStatus {
    get
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public var dottedInts: Swift.String {
    get
  }
}
extension Swift.UInt8 {
  public var intValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers public class BluetoothManager : ObjectiveC.NSObject, Combine.ObservableObject {
  @objc override dynamic public init()
  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  @objc deinit
}
public struct ProgressSectionViewEntity {
  public let bootloaderStatus: ZTCoreKit.DfuUiStateStatus
  public let dfuStatus: ZTCoreKit.DfuUiStateStatus
  public let installationStatus: ZTCoreKit.DfuInstallationStatus
  public let resultStatus: ZTCoreKit.DfuResultStatus
  public func isRunning() -> Swift.Bool
}
public struct DfuProgress {
  public let part: Swift.Int
  public let totalParts: Swift.Int
  public let progress: Swift.Int
  public let currentSpeedBytesPerSecond: Swift.Double
  public let avgSpeedBytesPerSecond: Swift.Double
  public func percantageProgress() -> Swift.Float
  public func avgSpeed() -> Swift.Double
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class DfuSelectModel : ObjectiveC.NSObject, Foundation.ObservableObject {
  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  @objc deinit
}
public struct DfuUiError {
}
public struct ZipFile {
  public let name: Swift.String
  public let size: Swift.Int
  public let url: Foundation.URL
  public init(name: Swift.String, size: Swift.Int, url: Foundation.URL)
}
public enum DfuInstallationStatus {
  case idle
  case success
  case progress(ZTCoreKit.DfuProgress)
  case error
}
public enum DfuResultStatus {
  case idle
  case success
  case error(ZTCoreKit.DfuUiError)
}
public enum DfuUiStateStatus {
  case idle
  case success
  case progress
  case error
  public static func == (a: ZTCoreKit.DfuUiStateStatus, b: ZTCoreKit.DfuUiStateStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct TextAlert {
  public var title: Swift.String
  public var message: Swift.String
  public var placeholder: Swift.String
  public var accept: Swift.String
  public var cancel: Swift.String?
  public var secondaryActionTitle: Swift.String?
  public var keyboardType: UIKit.UIKeyboardType
  public var action: (Swift.String?) -> Swift.Void
  public var secondaryAction: (() -> Swift.Void)?
}
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func alert(isPresented: SwiftUICore.Binding<Swift.Bool>, _ alert: ZTCoreKit.TextAlert) -> some SwiftUICore.View
  
}
open class ZTDFUHelper {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(qrCode: Swift.String?)
  #endif
  final public let qrCode: Swift.String?
  #if compiler(>=5.3) && $NonescapableTypes
  open func matchDevice(name: Swift.String?, mac: Swift.String) -> Swift.Bool
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func dfuDelegate(firmwareDownloaded: Swift.Bool, version: Swift.String?)
  #endif
  open func dfuDelegate(didFinish: Swift.Bool)
  #if compiler(>=5.3) && $NonescapableTypes
  open func dfuDelegate(didFail error: ZTCoreKit.ZTError?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func dfuDelegate(progress: Swift.Float?)
  #endif
  open func dfuDelegate(leftProgress: Swift.Int)
  open func dfuDelegate(rightProgress: Swift.Int)
  #if compiler(>=5.3) && $NonescapableTypes
  open func dfuDelegate(leftDidFinish newVersion: Swift.String?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func dfuDelegate(rightDidFinish newVersion: Swift.String?)
  #endif
  open func hasFinishDFU()
  @objc deinit
}
extension ZTCoreKit.ZTDFUHelper {
  public func loadZip(at fileUrl: Foundation.URL) throws
  public func startScan(for macAdress: Swift.String) async
}
public struct BluetoothDeviceDFUProgress {
  public var progress: Swift.Float
  public var part: Swift.Int
  public var totalParts: Swift.Int
  public var avgSpeedBytesPerSecond: Swift.Double
  public var isDone: Swift.Bool
  public var errorMessage: Swift.String?
}
public enum ZTActivityLastStopReason : Swift.UInt8, Swift.Codable {
  case undefined
  case userRequest
  case memoryFull
  case inactivity
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.UInt8)
  #endif
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct ZTBatteryLevel : ZTCoreKit.ZTNotifyDataMessage {
  public var rawData: Foundation.Data?
  public var right: Swift.UInt8
  public var left: Swift.UInt8
  public var description: Swift.String {
    get
  }
  public var min: Swift.UInt8 {
    get
  }
  public init()
  public init(data: Foundation.Data)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension Foundation.Data {
  #if compiler(>=5.3) && $NonescapableTypes
  public var ztBatteriesLevel: ZTCoreKit.ZTBatteryLevel? {
    get
  }
  #endif
}
public struct ZTMessageChunkSendStatus : Swift.CustomStringConvertible, Swift.Codable, Swift.Sendable {
  public enum Status : Swift.UInt8, Swift.Codable, Swift.Sendable {
    case success
    case errorOutOfRange
    case errorSendFailed
    case errorUnexpected
    case errorNotFound
    case unknown
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public let bytes: [Swift.UInt8]
  public var status: ZTCoreKit.ZTMessageChunkSendStatus.Status?
  public var chunkId: Swift.UInt16?
  public init(bytes: [Swift.UInt8])
  public var description: Swift.String {
    get
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum ZTCommand : Swift.UInt8, Swift.CaseIterable, Swift.Identifiable {
  public var id: Swift.UInt8 {
    get
  }
  case generalState
  case startNewActivity
  case stopNewActivity
  case resendData
  case deepSleep
  case reboot
  case detailedBattery
  case hardwareInformation
  case firmwareInformation
  case bootloaderVersion
  case setInactivityTimeout
  case setDFUInstall
  case setDFUMode
  case setChunkConfig
  case setChunkMinutesInterval
  case setChunkSecondsInterval
  case selectAlgorithm
  case freeMemory
  case getTimestamp
  case passthroughAlgo
  case resetActivity
  case getActivityMetadata
  case disableHeating
  case setHeating
  case setTimer
  case getTemperature
  case getTimer
  case startPostureCalibration
  case setUserParameters
  case resetCalibration
  case getCalibrationState
  case rawDataSend
  case rawDataEnable
  case rawDataLookup
  case rawDataDebug
  case calibrateStatic
  case clearCalibrateStatic
  case cancelCalibrateStatic
  case getCalibrateStaticMessage
  case getCalibrateStaticData
  case testCalibrateStatic
  case memsConfig
  case updateTxPower
  case updatePhy
  case disconnect
  case leftRightConnectionInterval
  case ackTimeOut
  case startDFURight
  case startDFULeft
  case enablePeerConnection
  case factoryReset
  case scheduleAdd
  case clearlSchedule
  case setDFUKey
  case setDFUPubkey
  case setDFUKeySecure
  case getDevicePubkey
  public var description: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.UInt8)
  #endif
  public typealias AllCases = [ZTCoreKit.ZTCommand]
  public typealias ID = Swift.UInt8
  public typealias RawValue = Swift.UInt8
  nonisolated public static var allCases: [ZTCoreKit.ZTCommand] {
    get
  }
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct ZTCommandResponse : Swift.Codable, Swift.Sendable {
  public let bytes: [Swift.UInt8]
  public var rightModule: Swift.Bool {
    get
  }
  public var leftModule: Swift.Bool {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var command: ZTCoreKit.ZTCommand? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var status: ZTCoreKit.ZTCommandStatus? {
    get
  }
  #endif
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum ZTCommandStatus : Swift.UInt8 {
  case success
  case busy
  case invalidParam
  case invalidState
  case forbidden
  case notSupported
  case unknownCommand
  case commandInProgress
  case noPeerresponse
  public var description: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.UInt8)
  #endif
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum ZTDfuPackageType : Swift.String {
  case APP
  case BL
  case SD
  case SD_BL
  case SD_BL_APP
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class ZTFirmwareRevision : Swift.Codable {
  public var fwSystemVersion: Swift.String? {
    get
  }
  public var productType: ZTCoreKit.ZTProductCodeType? {
    get
  }
  public var bmVersion: Swift.String? {
    get
  }
  public var date: Foundation.Date? {
    get
  }
  public var code: Swift.String {
    get
  }
  public var fwVersion: Swift.String {
    get
  }
  public var versions: ZTCoreKit.ZTFwBmVersion? {
    get
  }
  public var version: Swift.Int
  public init(code: Swift.String)
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
  required public init(from decoder: any Swift.Decoder) throws
}
extension ZTCoreKit.ZTFirmwareRevision : Swift.Equatable {
  public static func == (lhs: ZTCoreKit.ZTFirmwareRevision, rhs: ZTCoreKit.ZTFirmwareRevision) -> Swift.Bool
  public static func < (lhs: ZTCoreKit.ZTFirmwareRevision, rhs: ZTCoreKit.ZTFirmwareRevision) -> Swift.Bool
  public static func >= (lhs: ZTCoreKit.ZTFirmwareRevision, rhs: ZTCoreKit.ZTFirmwareRevision) -> Swift.Bool
}
public struct ZTFwBmVersion : Swift.Codable {
  public var fwSystemMajorVersion: Swift.Int
  public var fwSystemMinorVersion: Swift.Int
  public var fwSystemBuildVersion: Swift.Int
  public var bmMajorVersion: Swift.Int
  public var bmMinorVersion: Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension ZTCoreKit.ZTFirmwareRevision {
  public var fwSystemMajorVersion: Swift.Int {
    get
  }
  public var fwSystemMinorVersion: Swift.Int {
    get
  }
  public var fwSystemBuildVersion: Swift.Int {
    get
  }
  public var bmMajorVersion: Swift.Int {
    get
  }
  public var bmMinorVersion: Swift.Int {
    get
  }
}
public struct ZTMessageActivity : Swift.CustomStringConvertible, Swift.Codable, Swift.Sendable {
  public init(bytes: [Swift.UInt8])
  public var isRight: Swift.Bool {
    get
  }
  public var isLeft: Swift.Bool {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var selectedMode: ZTCoreKit.ZTActivityMode? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var timeInterval: Swift.Int? {
    get
  }
  #endif
  public var description: Swift.String {
    get
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ZTMessageBootloaderInfo : Swift.CustomStringConvertible, Swift.Codable, Swift.Sendable {
  public init(bytes: [Swift.UInt8])
  public var side: ZTCoreKit.ZTModuleSide {
    get
  }
  public var bootloaderVersion: Swift.UInt8 {
    get
  }
  public var appSupportVersion: Swift.UInt8 {
    get
  }
  public var softDeviceId: Swift.UInt8 {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var dfuState: ZTCoreKit.ZTMessageBootloaderInfo.DfuState? {
    get
  }
  #endif
  public var description: Swift.String {
    get
  }
  public enum DfuState : Swift.UInt8, Swift.Sendable {
    case none
    case inProgress
    case received
    case readyForCopy
    case activation
    case done
    case error
    case validationError
    case activationError
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ZTMessageChunkConfig : Swift.CustomStringConvertible, Swift.Codable, Swift.Sendable {
  #if compiler(>=5.3) && $NonescapableTypes
  public var byte0: Swift.UInt8? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var byte1: Swift.UInt8? {
    get
  }
  #endif
  public init(bytes: [Swift.UInt8])
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension ZTCoreKit.ZTMessageChunkConfig {
  public var side: ZTCoreKit.ZTModuleSide {
    get
  }
  public var flag: Swift.UInt8 {
    get
  }
  public var description: Swift.String {
    get
  }
}
public struct ZTMessageChunkData : Swift.CustomStringConvertible, Swift.Codable, Swift.Sendable {
  public enum Mode : Swift.UInt8 {
    case manual
    case automatic
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var byte0: Swift.UInt8? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var byte1: Swift.UInt8? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var byte2: Swift.UInt8? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var byte3: Swift.UInt8? {
    get
  }
  #endif
  public init(bytes: [Swift.UInt8])
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension ZTCoreKit.ZTMessageChunkData {
  public var side: ZTCoreKit.ZTModuleSide {
    get
  }
  public var mode: ZTCoreKit.ZTMessageChunkData.Mode {
    get
  }
  public var length: Swift.UInt8 {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var payload: Foundation.Data? {
    get
  }
  #endif
  public var description: Swift.String {
    get
  }
}
public struct ZTMessageInactivityTimeout : Swift.CustomStringConvertible, Swift.Codable, Swift.Sendable {
  public var left: Swift.UInt32
  public var right: Swift.UInt32
  public init(bytes: [Swift.UInt8])
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension ZTCoreKit.ZTMessageInactivityTimeout {
  public var description: Swift.String {
    get
  }
}
public struct ZTMessageSoftware : Swift.CustomStringConvertible, Swift.Codable, Swift.Sendable {
  public init(bytes: [Swift.UInt8])
  public var side: ZTCoreKit.ZTModuleSide {
    get
  }
  public var baseMajor: Swift.UInt8 {
    get
  }
  public var baseMinor: Swift.UInt8 {
    get
  }
  public var baseBuild: Swift.UInt16 {
    get
  }
  public var app: Swift.String {
    get
  }
  public var appMajor: Swift.UInt8 {
    get
  }
  public var appMinor: Swift.UInt8 {
    get
  }
  public var version: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ZTMessageTime : Swift.CustomStringConvertible, Swift.Sendable, Swift.Equatable, Swift.Codable {
  public var timestamp: Swift.Int64
  public var side: ZTCoreKit.ZTModuleSide
  public init(bytes: [Swift.UInt8])
  public var description: Swift.String {
    get
  }
  public var anchor: Swift.Int64 {
    get
  }
  public static func == (a: ZTCoreKit.ZTMessageTime, b: ZTCoreKit.ZTMessageTime) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum ZTNotifyData {
  public enum GroupID : Swift.UInt8, Swift.Codable, Swift.Sendable {
    case common
    case warm
    case running
    case cycling
    case safety
    case generic
    case standardize
    public var description: Swift.String {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum CommonMessageId : Swift.UInt8, Swift.Codable, Swift.Sendable {
    case MSG_GENERAL_STATES
    case MSG_BATTERY_LEVEL
    case MSG_MEMS
    case MSG_FLASH
    case MSG_TIME
    case MSG_HARDWARE
    case MSG_SOFTWARE
    case MSG_ACTIVITY_INFO
    case MSG_ACTIVITY_METADATA
    case MSG_RAWDATA_HEADER
    case MSG_RAWDATA_FRAME
    case MSG_BTLOADER_INFO
    case MSG_INACTIVITY_TIMEOUT
    case MSG_CHUNK_SEND_STATUS
    case MSG_CHUNK_DATA
    case MSG_CHUNK_CONFIG
    case MSG_DEBUG
    public var description: Swift.String {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
extension ZTCoreKit.ZTNotifyData {
  public enum WarmMessageId : Swift.UInt8, Swift.Codable, Swift.Sendable {
    case MSG_HEATING_TEMP_1
    case MSG_HEATING_TEMP_2
    case MSG_HEATING_STEP_R_CNT
    case MSG_HEATING_STEP_L_CNT
    case MSG_HEATING_SETPOINT_R
    case MSG_HEATING_SETPOINT_L
    case MSG_GET_HEAT_TIMER
    case MSG_HEATING_DEBUG_R
    case MSG_HEATING_DEBUG_L
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
extension ZTCoreKit.ZTNotifyData {
  public enum RunningMessageId : Swift.UInt8, Swift.Codable, Swift.Sendable {
    case UNKNOWN
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
extension ZTCoreKit.ZTNotifyData {
  public enum CyclingMessageId : Swift.UInt8, Swift.Codable, Swift.Sendable {
    case MSG_CADENCE
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
extension ZTCoreKit.ZTNotifyData {
  public enum SafetyMessageId : Swift.UInt8, Swift.Codable, Swift.Sendable {
    case MSG_CALIBRATION_SAFETY
    case MSG_ALGO_RT_EVENT
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
extension ZTCoreKit.ZTNotifyData {
  public enum GenericMessageId : Swift.UInt8, Swift.Codable, Swift.Sendable {
    case MSG_ALGO_RT_EVENT
    public var description: Swift.String {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum StandardizeMessageId : Swift.UInt8, Swift.Codable, Swift.Sendable {
    case MSG_GET_DEVICE_PUBKEY
    public var description: Swift.String {
      get
    }
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
public protocol ZTNotifyDataMessage : Swift.Decodable, Swift.Encodable {
  #if compiler(>=5.3) && $NonescapableTypes
  var rawData: Foundation.Data? { get set }
  #endif
}
public enum ZTSamplingMode : Swift.UInt8, Swift.Codable {
  case jump
  case run
  case walk
  public var parameters: [Swift.UInt8] {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.UInt8)
  #endif
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public typealias ZTScannerResultBlock = (ZTCoreKit.ZTScannerResult) -> Swift.Void
public enum ZTScannerResult {
  case success(device: any ZTCoreKit.ZTDeviceProtocol)
  case cancelled
  case failed((any Swift.Error)?)
}
public enum ZTActivityMode : Swift.UInt8, Swift.Codable, Swift.Sendable {
  case safety
  case walking
  case running
  case cycling
  case mobility
  case swing
  public var name: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.UInt8)
  #endif
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum ZTTXPower : Swift.UInt8 {
  case dBm0
  case dBm2
  case dBm3
  case dBm4
  case dBm5
  case dBm6
  case dBm7
  case dBm8
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.UInt8)
  #endif
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct ZTRealtimeMessage : Swift.Sendable, Swift.CustomStringConvertible, Swift.Codable {
  public var description: Swift.String {
    get
  }
  public enum Side : Swift.UInt8, Swift.Codable, Swift.Sendable {
    case none
    case left
    case right
    case both
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public var senderSide: ZTCoreKit.ZTRealtimeMessage.Side?
  public var concernedSide: ZTCoreKit.ZTRealtimeMessage.Side?
  public var eventType: ZTCoreKit.ZTRealtimeMessageEventType?
  public var content: [Swift.UInt8] {
    get
  }
  public var status: ZTCoreKit.ZTRealtimeMessage.Status?
  public var acknowledgment: ZTCoreKit.ZTRealtimeMessage.Acknowledgment?
  public var realtimeEvent: ZTCoreKit.ZTRealtimeMessage.Event?
  public var realtimeMetrics: ZTCoreKit.ZTRealtimeMessage.Metrics?
  public init(bytes: [Swift.UInt8])
  #if compiler(>=5.3) && $NonescapableTypes
  public init(senderSide: ZTCoreKit.ZTRealtimeMessage.Side? = nil, concernedSide: ZTCoreKit.ZTRealtimeMessage.Side? = nil, eventType: ZTCoreKit.ZTRealtimeMessageEventType? = nil, status: ZTCoreKit.ZTRealtimeMessage.Status? = nil, acknowledgment: ZTCoreKit.ZTRealtimeMessage.Acknowledgment? = nil, realtimeEvent: ZTCoreKit.ZTRealtimeMessage.Event? = nil, realtimeMetrics: ZTCoreKit.ZTRealtimeMessage.Metrics? = nil)
  #endif
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension ZTCoreKit.ZTRealtimeMessage {
  public struct Acknowledgment : Swift.CustomStringConvertible, Swift.Codable, Swift.Sendable {
    #if compiler(>=5.3) && $NonescapableTypes
    public var command: ZTCoreKit.ZTAlgoCommand? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var status: ZTCoreKit.ZTAlgoAcknowledgmentStatus? {
      get
    }
    #endif
    public var description: Swift.String {
      get
    }
    public init(data: Foundation.Data)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension ZTCoreKit.ZTRealtimeMessage {
  public struct Event : Swift.CustomStringConvertible, Swift.Codable, Swift.Sendable {
    #if compiler(>=5.3) && $NonescapableTypes
    public var timestamp: Swift.UInt32? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var eventType: ZTCoreKit.ZTRealtimeMessage.Event.EventType? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var motionId: ZTCoreKit.ZTRealtimeMessage.Event.MotionId? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var intensity: ZTCoreKit.ZTRealtimeMessage.Event.MotionIntensity? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var arguments: [Swift.UInt8]? {
      get
    }
    #endif
    public var description: Swift.String {
      get
    }
    public init(data: Foundation.Data)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension ZTCoreKit.ZTRealtimeMessage {
  public struct Metrics : Swift.CustomStringConvertible, Swift.Codable, Swift.Sendable {
    public var activityType: ZTCoreKit.ZTActivityType?
    public var metricId: Swift.UInt8?
    public var metric: ZTCoreKit.ZTRealtimeMetric?
    public var value: [Swift.UInt8]?
    public var description: Swift.String {
      get
    }
    public init(data: Foundation.Data)
    #if compiler(>=5.3) && $NonescapableTypes
    public init(activityType: ZTCoreKit.ZTActivityType? = nil, metricId: Swift.UInt8? = nil, metric: ZTCoreKit.ZTRealtimeMetric? = nil, value: [Swift.UInt8]? = nil)
    #endif
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension ZTCoreKit.ZTRealtimeMessage {
  public struct Status : Swift.CustomStringConvertible, Swift.Codable, Swift.Sendable {
    #if compiler(>=5.3) && $NonescapableTypes
    public var code: ZTCoreKit.ZTAlgoStatus? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var timestamp: Swift.UInt32? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var algoMode: ZTCoreKit.ZTAlgoMode? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var precisionMode: ZTCoreKit.ZTAlgoPrecisionMode? {
      get
    }
    #endif
    #if compiler(>=5.3) && $NonescapableTypes
    public var consecutiveSteps: Swift.UInt8? {
      get
    }
    #endif
    public var description: Swift.String {
      get
    }
    public init(data: Foundation.Data)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension ZTCoreKit.ZTRealtimeMessage.Event {
  public enum EventType : Swift.UInt8, ZTCoreKit.ZTEnum {
    case motion
    case transition
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum MotionId : Swift.UInt8, ZTCoreKit.ZTEnum {
    case undefined
    case stepForward
    case stepBackward
    case stepSideLeft
    case stepSideRight
    case stepUp
    case stepDown
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum MotionIntensity : Swift.UInt8, ZTCoreKit.ZTEnum {
    case undefined
    case low
    case medium
    case high
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
public enum ZTRealtimeMessageEventType : Swift.UInt8, ZTCoreKit.ZTEnum, Swift.Codable {
  case status
  case acknowledgment
  case realTimeEvent
  case realTimeMetrics
  case warning
  case error
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.UInt8)
  #endif
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension Swift.Array where Element == ZTCoreKit.ZTRealtimeMetric {
  public static var walk: [ZTCoreKit.ZTRealtimeMetric] {
    get
  }
  public static var all: [ZTCoreKit.ZTRealtimeMetric] {
    get
  }
}
public enum ZTRealtimeMetric : Swift.String, Swift.Codable, Swift.CaseIterable, Swift.Sendable {
  case duration
  case steps
  case cycleDuration
  case stepCadence
  case stepSpeed
  case distance
  case footDistance
  case energySum
  case walkingQualityScore
  case stairsClimbed
  case intenseActivity
  case slope
  case accelerationFoot
  case strideLength
  case relativePronationAngleFoot
  case pronationAngleFFI
  case pronationAngleFFO
  case plantarFlexionAngularSpeedMaxPropulsion
  case symmetry
  public func value() -> Swift.UInt8
  public var activityType: ZTCoreKit.ZTActivityType {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias AllCases = [ZTCoreKit.ZTRealtimeMetric]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [ZTCoreKit.ZTRealtimeMetric] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
extension ZTCoreKit.ZTRealtimeMetric {
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(value: Swift.UInt8, activityType: ZTCoreKit.ZTActivityType? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(name: Swift.String)
  #endif
}
public enum ZTRealtimeSide : Swift.UInt8 {
  case none
  case left
  case right
  case both
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.UInt8)
  #endif
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum ZTActivityType : Swift.UInt8, ZTCoreKit.ZTEnum {
  case staticType
  case dynamic
  case walking
  case running
  case cycling
  case jump
  case stairsUp
  case stairsDown
  case staticOther
  case kneel
  case tiptoe
  case vibration
  case trampling
  case crawling
  case dynamicOther
  case slip
  case trip
  case active
  case inactive
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.UInt8)
  #endif
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension ZTCoreKit.ZTActivityType {
  public static func from(rawValue: Swift.String) -> ZTCoreKit.ZTActivityType
}
public enum ZTAlgoAcknowledgmentStatus : Swift.UInt8, ZTCoreKit.ZTEnum {
  case success
  case busy
  case invalidParam
  case invalidState
  case fwResForbidden
  case notSupported
  case unknownCommand
  case commandInProgress
  case noPeerResponse
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.UInt8)
  #endif
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum ZTAlgoCommand : Swift.UInt8, ZTCoreKit.ZTEnum {
  case getStatus
  case startNewChunk
  case changeProductMode
  case setPrecisionMode
  case setMinimumNumberOfStrides
  case enableStreamingOfValues
  case setDisconnectionDelay
  case setUserInfo
  case setDailyTimestamp
  case getPositionOfPods
  case enableSpecificPacket
  case holdRealtimeStreaming
  case getSingleTimeMetrics
  case calibrateGravity
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.UInt8)
  #endif
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum ZTAlgoMode : Swift.UInt8, ZTCoreKit.ZTEnum {
  case monitoring
  case gaming
  public var parameters: [Swift.UInt8] {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.UInt8)
  #endif
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum ZTAlgoPrecisionMode : Swift.UInt8, ZTCoreKit.ZTEnum {
  case defaultMode
  case economicMode
  case performanceMode
  public var parameters: [Swift.UInt8] {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.UInt8)
  #endif
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum ZTAlgoState : Swift.UInt8, ZTCoreKit.ZTEnum {
  case undefined
  case walking
  case running
  case pedaling
  case jump
  case stairsUp
  case stairsDown
  case standing
  case sitting
  case kneeling
  case tiptoe
  case vibration
  case slip
  case incident
  case freewheel
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.UInt8)
  #endif
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum ZTAlgoStatus : Swift.UInt8, ZTCoreKit.ZTEnum {
  case timestamp
  case modeId
  case precisionMode
  case numberOfSteps
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.UInt8)
  #endif
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public protocol ZTEnum : Swift.Decodable, Swift.Encodable, Swift.Sendable {
  var description: Swift.String { get }
}
extension ZTCoreKit.ZTEnum {
  public var description: Swift.String {
    get
  }
}
public enum ZTPassthroughAlgo : ZTCoreKit.ZTEnum {
  case status(id: ZTCoreKit.ZTAlgoStatus)
  case startNewChunk
  case changeProductMode(mode: ZTCoreKit.ZTAlgoMode)
  case setPrecisionMode(mode: ZTCoreKit.ZTAlgoPrecisionMode)
  case setMinimumStepsForAnalysis(activityType: ZTCoreKit.ZTActivityType, steps: Swift.Int)
  case setMinimumStridesForAnalysis(activityType: ZTCoreKit.ZTActivityType, strides: Swift.Int)
  case setStreamingMode(interval: Swift.UInt16, activityType: ZTCoreKit.ZTActivityType, metricsId: Swift.UInt8)
  public var parameters: [Swift.UInt8] {
    get
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
#if compiler(>=5.3) && $NonescapableTypes
public func isBitSet(number: Swift.UInt8?, index: Swift.Int) -> Swift.Bool
#endif
public enum ZTEnvironment {
  case dev
  case staging
  case production
  case zcdev
  case zcstaging
  case zcproduction
  case cnzcdev
  case cnzcqa
  case cnzcproduction
  public var name: Swift.String {
    get
  }
  public var isDEV: Swift.Bool {
    get
  }
  public var isZC: Swift.Bool {
    get
  }
  public var needPut: Swift.Bool {
    get
  }
  public static func == (a: ZTCoreKit.ZTEnvironment, b: ZTCoreKit.ZTEnvironment) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum FirmwareModule : Swift.UInt8 {
  case left
  case right
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.UInt8)
  #endif
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum ZTModuleSide : Swift.String, Swift.Codable, Swift.Sendable, Swift.Equatable {
  case left
  case right
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension ZTCoreKit.ZTEnvironment {
  public static var active: ZTCoreKit.ZTEnvironment {
    get
  }
  public var apiUrl: Swift.String {
    get
  }
  public var websocketUrl: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ZTSettings {
  public static let apiVersion: Swift.String
  public static let shared: ZTCoreKit.ZTSettings
  final public var version: Swift.String?
  final public var apiKey: Swift.String?
  final public var apiSecret: Swift.String?
  final public var logLevel: ZTCoreKit.ZTLogLevel
  final public var environment: ZTCoreKit.ZTEnvironment
  final public var autoConnect: Swift.Bool
  final public var enableEventLogging: Swift.Bool
  final public var shouldObtaineMissedChunks: Swift.Bool
  final public var enableRawDataCheck: Swift.Bool
  final public var shouldAutoResendData: Swift.Bool
  final public var activityDataSyncThreshold: Swift.Int
  final public var enableBackgroundDFU: Swift.Bool
  final public var enableBackgroundDataStreaming: Swift.Bool
  final public var activityChunkStoreForFreeMemory: Swift.Int
  final public var activityChunkRetryLimit: Swift.Int
  final public var checkFirmwareUpdatePeriod: Swift.Int
  final public var enableAnalyticsData: Swift.Bool
  final public var autorestartBackgroundDfu: Swift.Bool
  final public var getChunksOnApplicationDidBecomeActive: Swift.Bool
  final public var enablePacketsDataLogging: Swift.Bool
  final public var cachedPacketsBatchUploadSize: Swift.Int
  #if compiler(>=5.3) && $NonescapableTypes
  final public var chunkDuration: Swift.Int? {
    get
    set
  }
  #endif
  final public var disableAutomaticActivity: Swift.Bool
  final public var allowAntennaOptimization: Swift.Bool
  final public var realTimeOnly: Swift.Bool
  final public var disablePLister: Swift.Bool
  final public let minimalBatteryLevel: Swift.UInt8
  final public var enableActivityCloudSync: Swift.Bool
  @objc deinit
}
public enum ZTDataTransforms {
}
extension Swift.Double {
  public func roundTo(places: Swift.Int = 2) -> Swift.Double
}
extension Swift.Float {
  public func roundTo(places: Swift.Int = 2) -> Swift.Float
}
#if compiler(>=5.3) && $NonescapableTypes
public func decodeData<T>(_ data: Foundation.Data, for type: T.Type) -> T? where T : Swift.Decodable, T : Swift.Encodable
#endif
public func encodeData<T>(for type: T) -> Foundation.Data where T : Swift.Decodable, T : Swift.Encodable
extension Swift.String {
  public func serialNumber() -> Swift.String
}
extension Swift.String {
  public func binary(with character: Swift.String = "0", toLength length: Swift.Int = 8) -> Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  public var fromBase64: Swift.String? {
    get
  }
  #endif
  public var toBase64: Swift.String {
    get
  }
  public func substring(from: Swift.Int, to: Swift.Int) -> Swift.String
  public func substring(range: Foundation.NSRange) -> Swift.String
  public func matches(regex: Swift.String) -> [Swift.String]
  public static func random(length: Swift.Int = 9) -> Swift.String
  public func split(usingRegex pattern: Swift.String) -> [Swift.String]
  public func fileName() -> Swift.String
  public func incrementedMacAddress() -> Swift.String
}
extension Swift.String {
  #if compiler(>=5.3) && $NonescapableTypes
  public func toByteArray() -> [Swift.UInt8]?
  #endif
}
extension Swift.Int {
  public func toByteArray(size: Swift.Int = 4) -> [Swift.UInt8]
}
extension Swift.UInt8 {
  public var bits: [Swift.UInt8] {
    get
  }
  public var hexValue: Swift.String {
    get
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public var hexString: Swift.String {
    get
  }
}
extension Swift.UInt16 {
  public func toByteArray(size: Swift.Int = 2) -> [Swift.UInt8]
}
extension Swift.UInt32 {
  public func toByteArray(size: Swift.Int = 4) -> [Swift.UInt8]
}
extension Swift.UInt64 {
  public func toByteArray(size: Swift.Int = 8) -> [Swift.UInt8]
}
extension Swift.Double {
  public var milliseconds: Swift.Int64 {
    get
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public var hex: Swift.String {
    get
  }
}
extension Swift.Dictionary {
  public func merge(dict: [Key : Value]) -> [Key : Value]
}
extension Swift.Int64 {
  public var readableTimeStamp: Swift.String {
    get
  }
}
extension Swift.UInt32 {
  public var readableTimeStamp: Swift.String {
    get
  }
}
extension Foundation.Date {
  public var timestamp: Swift.Int64 {
    get
  }
  public var apiFormat: Swift.String {
    get
  }
  public var logFormat: Swift.String {
    get
  }
  public func toISO8601() -> Swift.String
  public func toLocalTime() -> Foundation.Date
}
extension Foundation.NSRegularExpression {
  convenience public init(_ pattern: Swift.String)
  public func matches(_ string: Swift.String) -> Swift.Bool
}
extension Foundation.Bundle {
  public static var isTestflight: Swift.Bool {
    get
  }
  public static var appVersion: Swift.String {
    get
  }
  public static var buildVersion: Swift.String {
    get
  }
}
extension Swift.Array {
  public func chunked(into size: Swift.Int = 1000) -> [[Element]]
  public var isNotEmpty: Swift.Bool {
    get
  }
}
extension Swift.Array where Element == Swift.String {
  public func stringify() -> Swift.String
}
extension Swift.Collection where Self.Element == Swift.UInt8, Self.Index == Swift.Int {
  public func object<T>(at offset: Swift.Int = 0) -> T
}
extension Foundation.Data {
  #if compiler(>=5.3) && $NonescapableTypes
  public func macAddress() -> Swift.String?
  #endif
  public var bytes: [Swift.UInt8] {
    get
  }
  public var hexDescription: Swift.String {
    get
  }
  public var hexDescriptionColumn: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(hex: Swift.String)
  #endif
  public func getUInt(offset: Swift.Int) -> Swift.UInt16
  public func getUInt32(offset: Swift.Int) -> Swift.UInt32
  public func getFloat(offset: Swift.Int) -> Swift.Float
  public func getByte(at index: Swift.Int) -> Swift.Int8
  public func getUnsignedInteger(at index: Swift.Int, bigEndian: Swift.Bool = true) -> Swift.UInt32
  public func getUnsignedInt16(at index: Swift.Int) -> Swift.UInt16
  public func getUnsignedInt32(at index: Swift.Int, bigEndian: Swift.Bool = true) -> Swift.UInt32
  public func getUnsignedLong(at index: Swift.Int, bigEndian: Swift.Bool = true) -> Swift.UInt64
  public mutating func append(byte data: Swift.Int8)
  public mutating func append(unsignedInteger data: Swift.UInt32, bigEndian: Swift.Bool = true)
  public mutating func append(unsignedLong data: Swift.UInt64, bigEndian: Swift.Bool = true)
}
extension Foundation.Data {
  public func dataObject<T>(at index: Foundation.Data.Index = 0) -> T
  public func subdata<R>(in range: R) -> Foundation.Data where R : Swift.RangeExpression, R.Bound == Swift.Int
  public func object<T>(at offset: Swift.Int) -> T
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor @preconcurrency public var stringModel: Swift.String {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var family: Swift.String {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var carrier: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @_Concurrency.MainActor @preconcurrency public func ipAddress() -> Swift.String?
  #endif
  @_Concurrency.MainActor @preconcurrency public var os: Swift.String {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var osVersion: Swift.String {
    get
  }
}
final public class ZTSignal<T> {
  public typealias ZTSignalCallback = (T) -> Swift.Void
  final public var fireCount: Swift.Int {
    get
  }
  final public var retainLastData: Swift.Bool {
    get
    set
  }
  final public var lastDataFired: T? {
    get
  }
  final public var observers: [Swift.AnyObject] {
    get
  }
  public init(retainLastData: Swift.Bool = false)
  @discardableResult
  final public func subscribe(with observer: Swift.AnyObject, callback: @escaping ZTCoreKit.ZTSignal<T>.ZTSignalCallback) -> ZTCoreKit.ZTSignalSubscription<T>
  @discardableResult
  final public func subscribeOnce(with observer: Swift.AnyObject, callback: @escaping ZTCoreKit.ZTSignal<T>.ZTSignalCallback) -> ZTCoreKit.ZTSignalSubscription<T>
  @discardableResult
  final public func subscribePast(with observer: Swift.AnyObject, callback: @escaping ZTCoreKit.ZTSignal<T>.ZTSignalCallback) -> ZTCoreKit.ZTSignalSubscription<T>
  @discardableResult
  final public func subscribePastOnce(with observer: Swift.AnyObject, callback: @escaping ZTCoreKit.ZTSignal<T>.ZTSignalCallback) -> ZTCoreKit.ZTSignalSubscription<T>
  final public func fire(_ data: T)
  final public func cancelSubscription(for observer: Swift.AnyObject)
  final public func cancelAllSubscriptions()
  final public func clearLastData()
  @objc deinit
}
extension ZTCoreKit.ZTSignal where T == () {
  final public func fire()
}
@_hasMissingDesignatedInitializers final public class ZTSignalSubscription<T> {
  public typealias ZTSignalCallback = (T) -> Swift.Void
  public typealias ZTSignalFilter = (T) -> Swift.Bool
  weak final public var observer: Swift.AnyObject?
  final public var once: Swift.Bool
  @discardableResult
  final public func filter(_ predicate: @escaping ZTCoreKit.ZTSignalSubscription<T>.ZTSignalFilter) -> ZTCoreKit.ZTSignalSubscription<T>
  @discardableResult
  final public func sample(every sampleInterval: Foundation.TimeInterval) -> ZTCoreKit.ZTSignalSubscription<T>
  @discardableResult
  final public func onQueue(_ queue: Dispatch.DispatchQueue) -> ZTCoreKit.ZTSignalSubscription<T>
  final public func cancel()
  @objc deinit
}
infix operator => : AssignmentPrecedence
public func => <T>(signal: ZTCoreKit.ZTSignal<T>, data: T)
public actor ZTTaskManager {
  public var isRunningTask: Swift.Bool
  public func runTask(data: Foundation.Data, activityId: Swift.String, parsePacketData: @escaping (Foundation.Data, Foundation.UUID, Swift.String) async -> Swift.Void) async
  public init()
  @objc deinit
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  @_semantics("defaultActor") nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
public class ZTDateTransform : ZTCoreKit.ZTTransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.String
  public init()
  #if compiler(>=5.3) && $NonescapableTypes
  public func transformFromJSON(_ value: Any?) -> Foundation.Date?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func transformToJSON(_ value: Foundation.Date?) -> Swift.String?
  #endif
  @objc deinit
}
public class ZTDateTransformUTC : ZTCoreKit.ZTTransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.String
  public init()
  #if compiler(>=5.3) && $NonescapableTypes
  public func transformFromJSON(_ value: Any?) -> Foundation.Date?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func transformToJSON(_ value: Foundation.Date?) -> Swift.String?
  #endif
  @objc deinit
}
public protocol ZhortechEventsProtocol {
  #if compiler(>=5.3) && $NonescapableTypes
  func trackEvent(name: Swift.String, data: [Swift.String : Any]?, timestamp: Swift.Int64?, attributes: [Swift.String : Any]?)
  #endif
  func log(severity: ZTCoreKit.ZTLoggerSeverity, component: ZTCoreKit.ZTLoggerComponent, message: Swift.String)
}
@_hasMissingDesignatedInitializers public actor ZhortechEvent {
  public static func setEventTracker(_ tracker: any ZTCoreKit.ZhortechEventsProtocol)
  public static func log(severity: ZTCoreKit.ZTLoggerSeverity = ZTLoggerSeverity.debug, component: ZTCoreKit.ZTLoggerComponent = ZTLoggerComponent.sdk, message: Swift.String)
  @objc deinit
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  @_semantics("defaultActor") nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
@objc public enum DFUState : Swift.Int {
  case connecting
  case starting
  case enablingDfuMode
  case uploading
  case validating
  case disconnecting
  case completed
  case aborted
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension ZTCoreKit.DFUState : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public typealias ZTManagerAuthorization = CoreBluetooth.CBManagerAuthorization
public typealias ZTManagerState = CoreBluetooth.CBManagerState
public enum ZTBleManagerState : Swift.CustomStringConvertible {
  case off
  case on
  case idle
  case scanning
  case unauthorized
  case resetting
  case unknown
  case unsupported
  public var description: Swift.String {
    get
  }
  public static func == (a: ZTCoreKit.ZTBleManagerState, b: ZTCoreKit.ZTBleManagerState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class ZTDefaultsStore<T> where T : Swift.Decodable, T : Swift.Encodable, T : ZTCoreKit.ZTStorable {
  final public let uniqueIdentifier: Swift.String
  open var encoder: Foundation.JSONEncoder
  open var decoder: Foundation.JSONDecoder
  #if compiler(>=5.3) && $NonescapableTypes
  required public init?(uniqueIdentifier: Swift.String, encoder: Foundation.JSONEncoder = .init(), decoder: Foundation.JSONDecoder = .init())
  #endif
  public func save(_ object: T) throws
  #if compiler(>=5.3) && $NonescapableTypes
  public func save(_ optionalObject: T?) throws
  #endif
  public func save(_ objects: [T]) throws
  #if compiler(>=5.3) && $NonescapableTypes
  public func object(withId id: T.ID) -> T?
  #endif
  public func objects(withIds ids: [T.ID]) -> [T]
  public func allObjects() -> [T]
  public func delete(withId id: T.ID)
  public func delete(withIds ids: [T.ID])
  public func deleteAll()
  public func hasObject(withId id: T.ID) -> Swift.Bool
  public func forEach(_ object: (T) -> Swift.Void)
  @objc deinit
}
public enum ZTDeviceActualState : Swift.UInt8, Swift.Codable, Swift.Hashable, Swift.Sendable, Swift.Equatable {
  case activityNone
  case activityStarting
  case eraseMemory
  case activityRunning
  case activityPaused
  case activityStopping
  case activityPendData
  case activitySendData
  case unknown
  public var description: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.UInt8)
  #endif
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public class ZTDeviceUpgradeInfo {
  public var code: Swift.String
  public var fwArch: Swift.String
  public var fwVersion: Swift.String
  public init(code: Swift.String, fwArch: Swift.String, fwVersion: Swift.String)
  @objc deinit
}
public enum ZTDFUState : Swift.Int, Swift.Sendable {
  case started
  case startedLeft
  case completedLeft
  case startedRight
  case completedRight
  case completed
  case error
  public var description: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum ZTError : Swift.Equatable, Swift.Error {
  case scanning(type: ZTCoreKit.ZTError.Enums.ScanningError)
  case ble(type: ZTCoreKit.ZTError.Enums.BleError)
  case network(type: ZTCoreKit.ZTError.Enums.NetworkError)
  case store(type: ZTCoreKit.ZTError.Enums.StoreError)
  case custom(errorDescription: Swift.String?, error: (any Swift.Error)? = nil)
  case decoding(type: ZTCoreKit.ZTError.Enums.DecodableError)
  case activity(type: ZTCoreKit.ZTError.Enums.ActivityError)
  case dfu(type: ZTCoreKit.ZTError.Enums.DfuError)
  @_hasMissingDesignatedInitializers public class Enums {
    @objc deinit
  }
  public static func == (lhs: ZTCoreKit.ZTError, rhs: ZTCoreKit.ZTError) -> Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  public var error: (any Swift.Error)? {
    get
  }
  #endif
}
extension ZTCoreKit.ZTError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
extension ZTCoreKit.ZTError.Enums {
  public enum ScanningError {
    case cameraPermission
    case wrongCode
    case unknown
    case notLinkedUser
    public static func == (a: ZTCoreKit.ZTError.Enums.ScanningError, b: ZTCoreKit.ZTError.Enums.ScanningError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension ZTCoreKit.ZTError.Enums.ScanningError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
extension ZTCoreKit.ZTError.Enums {
  public enum BleError {
    case invalidState
    case resetting
    case poweredOff
    case unsupported
    case timeout
    case unauthorized
    case notConnected
    case notConnectedLeft
    case activityIsRunning
    case busy
    case dfu
    case commandError
    public static func == (a: ZTCoreKit.ZTError.Enums.BleError, b: ZTCoreKit.ZTError.Enums.BleError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension ZTCoreKit.ZTError.Enums.BleError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
extension ZTCoreKit.ZTError.Enums {
  public enum FirmwareError {
    case differentFirmware
    case memsError
    case leftNoConnected
    case restartRequired
    case recoverFromDfu
    case minimumFwVersion
    case updateRequired
    case unsupported
    case wrongProductType
    case firstChunkIdIsGreater
    case startTimeZero
    public static func == (a: ZTCoreKit.ZTError.Enums.FirmwareError, b: ZTCoreKit.ZTError.Enums.FirmwareError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension ZTCoreKit.ZTError.Enums.FirmwareError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
extension ZTCoreKit.ZTError.Enums {
  public enum DfuError {
    case noLeftModule
    case noUpdate
    case wrongFile
    case noStart
    case aborted
    case abortedRight
    case abortedLeft
    case unsupported
    case lowBattery
    case inProgress
    case updateRequired
    case wrongProductType
    public static func == (a: ZTCoreKit.ZTError.Enums.DfuError, b: ZTCoreKit.ZTError.Enums.DfuError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension ZTCoreKit.ZTError.Enums.DfuError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
extension ZTCoreKit.ZTError.Enums {
  public enum StoreError {
    case missing(Swift.String)
    case invalid(Swift.String, Any?)
    case wrong(Swift.String)
    case unknown
  }
}
extension ZTCoreKit.ZTError.Enums.StoreError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
extension ZTCoreKit.ZTError.Enums {
  public enum ActivityError {
    case notStarted
    case notStartedLeft
    case notStopped
    case unknown
    case modeNotSetActivityIsRunning
    case previousNotStopped
    case previousRestoring
    case noUserParametersSet
    case rawDataFlowIsRunning
    case invalidMobilityScanResults
    case outsideActivityDetected
    case anomalyDetected
    case mobility
    public static func == (a: ZTCoreKit.ZTError.Enums.ActivityError, b: ZTCoreKit.ZTError.Enums.ActivityError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension ZTCoreKit.ZTError.Enums.ActivityError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
extension ZTCoreKit.ZTError.Enums {
  public enum NetworkError {
    case userLinkError
    case inaccessible
    case urlError(Foundation.URLError)
    case generalError(any Swift.Error)
    case noResponse
    case invalidResponseType(Foundation.URLResponse)
    case noResponseData(Foundation.HTTPURLResponse)
    case endpointError(Foundation.HTTPURLResponse, Foundation.Data?)
    case custom(errorCode: Swift.Int?, errorDescription: Swift.String?)
  }
}
extension ZTCoreKit.ZTError.Enums.NetworkError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
extension ZTCoreKit.ZTError.Enums {
  public enum DecodableError {
    case invalidKeyPath
    case emptyKeyPath
    case invalidJSON
    public static func == (a: ZTCoreKit.ZTError.Enums.DecodableError, b: ZTCoreKit.ZTError.Enums.DecodableError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension ZTCoreKit.ZTError.Enums.DecodableError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
public enum ZTEventLoggerName : Swift.String {
  case command
  case startActivity
  case stopActivity
  case connect
  case scan
  case bleNotify
  case bleIndicate
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ZTLoggerComponent : Swift.String {
  case api
  case app
  case sdk
  case firmware
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ZTLoggerSeverity : Swift.String {
  case debug
  case error
  case info
  case warn
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct ZTManufacturerData : Swift.Codable {
  public var uuid: Swift.String
  public var macaddress: Swift.String
  public init(uuid: Swift.String, macaddress: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct ZTMessageGeneralState : Swift.CustomStringConvertible, Swift.Codable, Swift.Sendable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public var byte0: Swift.UInt8? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var byte1: Swift.UInt8? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var byte2: Swift.UInt8? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var byte3: Swift.UInt8? {
    get
  }
  #endif
  public init(bytes: [Swift.UInt8])
  public static func == (a: ZTCoreKit.ZTMessageGeneralState, b: ZTCoreKit.ZTMessageGeneralState) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension ZTCoreKit.ZTMessageGeneralState {
  public var activityStartedRight: Swift.Bool {
    get
  }
  public var activityStartedLeft: Swift.Bool {
    get
  }
  public var pairIsConnected: Swift.Bool {
    get
  }
  public var memsHasError: Swift.Bool {
    get
  }
  public var firmwareDifferent: Swift.Bool {
    get
  }
  public var actualState: ZTCoreKit.ZTDeviceActualState {
    get
  }
  public var previousState: ZTCoreKit.ZTDeviceActualState {
    get
  }
  public var description: Swift.String {
    get
  }
}
extension ZTCoreKit.ZTMessageGeneralState {
  public var activityNotStartedOnBothSide: Swift.Bool {
    get
  }
}
public enum ZTMobilityScanState : Swift.Codable, Swift.Sendable {
  case starting
  case running
  case stopping
  case none
  public static func == (a: ZTCoreKit.ZTMobilityScanState, b: ZTCoreKit.ZTMobilityScanState) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct ZTSavedDevice : Swift.Codable, ZTCoreKit.ZTStorable {
  public static let idKey: Swift.WritableKeyPath<ZTCoreKit.ZTSavedDevice, Swift.String>
  public var serialNumber: Swift.String
  public var code: Swift.String
  public var fwVersion: Swift.String?
  public var hwType: Swift.String?
  public var modelNumber: Swift.String?
  public var productType: Swift.String?
  public var macAddressRight: Swift.String?
  public var macAddressLeft: Swift.String?
  public var activityId: Swift.String?
  public var activityStartTime: Swift.UInt32?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(serialNumber: Swift.String, code: Swift.String, fwVersion: Swift.String? = nil, hwType: Swift.String? = nil, modelNumber: Swift.String? = nil, productType: Swift.String? = nil, macAddressRight: Swift.String? = nil, macAddressLeft: Swift.String? = nil, activityId: Swift.String? = nil, activityStartTime: Swift.UInt32? = nil)
  #endif
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension ZTCoreKit.ZTSavedDevice : ZTCoreKit.ZTDeviceProtocol {
  public var actualState: ZTCoreKit.ZTDeviceActualState {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var moduleSerialNo: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var qrCode: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var deviceIdentifier: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var activityType: Swift.String? {
    get
  }
  #endif
  public var isConnected: Swift.Bool {
    get
  }
  public var isDeviceReady: Swift.Bool {
    get
  }
}
public class ZTUser : ZTCoreKit.ZTMappable {
  public var attributes: [Swift.String : Any]
  public var id: Swift.String?
  public var organizationId: Swift.String?
  public var appId: Swift.String?
  public var createdAt: Swift.String?
  public var updatedAt: Swift.String?
  public var userId: Swift.String?
  #if compiler(>=5.3) && $NonescapableTypes
  required public init?(map: ZTCoreKit.ZTMap)
  #endif
  public func mapping(map: ZTCoreKit.ZTMap)
  @objc deinit
}
final public class ZTUserDataParameters : Swift.Codable, Swift.CustomStringConvertible {
  final public var description: Swift.String {
    get
  }
  public enum Gender : Swift.UInt8, Swift.Codable {
    case male
    case female
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  final public var threadmillSpeed: Swift.Int?
  final public var bodyWeight: Swift.Int?
  final public var bodyHeight: Swift.Int?
  final public var shoeSize: Swift.Int?
  final public var age: Swift.Int?
  final public var gender: ZTCoreKit.ZTUserDataParameters.Gender?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(threadmillSpeed: Swift.Int? = nil, bodyWeight: Swift.Int?, bodyHeight: Swift.Int?, shoeSize: Swift.Int?, age: Swift.Int?, gender: ZTCoreKit.ZTUserDataParameters.Gender?)
  #endif
  public enum Parameters : Swift.UInt8 {
    case threadmillSpeed
    case bodyWeight
    case bodyHeight
    case shoeSize
    case age
    case gender
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Swift.UInt8)
    #endif
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public class ZTAchievement : ZTCoreKit.ZTMappable {
  public var id: Swift.String?
  public var type: Swift.String?
  public var activityId: Swift.String?
  public var code: Swift.String?
  public var appuserId: Swift.String?
  public var data: [Swift.String : Any]?
  public var duration: Swift.Int64?
  public var calories: Swift.Double?
  public var createdAt: Foundation.Date?
  #if compiler(>=5.3) && $NonescapableTypes
  required public init?(map: ZTCoreKit.ZTMap)
  #endif
  public func mapping(map: ZTCoreKit.ZTMap)
  @objc deinit
}
public struct ZTActivityAppData : Swift.Codable, ZTCoreKit.ZTStorable {
  public static let idKey: Swift.WritableKeyPath<ZTCoreKit.ZTActivityAppData, Swift.Int64>
  public init(activityId: Swift.String, timestamp: Swift.Int64, data: [Any])
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public typealias ID = Swift.Int64
}
extension ZTCoreKit.ZTActivityAppData {
  public static func prepareActivityAppData(activities: [ZTCoreKit.ZTActivityAppData]) -> [Swift.String : Any]
}
public class ZTActivityComment : ZTCoreKit.ZTMappable {
  public var id: Swift.String?
  public var timeZone: Swift.String?
  public var timestamp: Foundation.Date?
  public var text: Swift.String?
  public var activityId: Swift.String?
  public var createdAt: Foundation.Date?
  public var updatedAt: Foundation.Date?
  public var mediaFiles: [ZTCoreKit.ZTMediaFile]?
  #if compiler(>=5.3) && $NonescapableTypes
  required public init?(map: ZTCoreKit.ZTMap)
  #endif
  public func mapping(map: ZTCoreKit.ZTMap)
  @objc deinit
}
public enum ZTActivitySummaryStatus : Swift.String {
  case started
  case complete
  case processing
  case errored
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
open class ZTActivitySummary : ZTCoreKit.ZTMappable {
  public var id: Swift.String
  public var activityType: Swift.String
  public var activityIdentifier: Swift.String
  public var start: Swift.String?
  public var end: Swift.String?
  public var duration: Swift.Int?
  public var tz: Swift.String?
  public var startDate: Foundation.Date?
  public var endDate: Foundation.Date?
  public var status: ZTCoreKit.ZTActivitySummaryStatus?
  #if compiler(>=5.3) && $NonescapableTypes
  required public init?(map: ZTCoreKit.ZTMap)
  #endif
  open func mapping(map: ZTCoreKit.ZTMap)
  @objc deinit
}
open class ZTApiService {
  public typealias Parameters = [Swift.String : Any]
  public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ZTAttribute {
  public var asDictionary: [Swift.String : Any] {
    get
  }
  @objc deinit
}
public class ZTAuthResponse : ZTCoreKit.ZTMappable {
  public var accessToken: Swift.String?
  public var refreshToken: Swift.String?
  public var expires: Swift.Double?
  public var expiresDate: Foundation.Date
  public var appAttributes: [Swift.String : Any]?
  #if compiler(>=5.3) && $NonescapableTypes
  required public init?(map: ZTCoreKit.ZTMap)
  #endif
  public func mapping(map: ZTCoreKit.ZTMap)
  @objc deinit
}
@_inheritsConvenienceInitializers final public class ZhortechActivitySummary : ZTCoreKit.ZTActivitySummary {
  final public var data: [Swift.String : Any]?
  final public var attributes: [Swift.String : Any]?
  #if compiler(>=5.3) && $NonescapableTypes
  required public init?(map: ZTCoreKit.ZTMap)
  #endif
  override final public func mapping(map: ZTCoreKit.ZTMap)
  @objc deinit
}
public class ZTConnectResponse : ZTCoreKit.ZTMappable {
  #if compiler(>=5.3) && $NonescapableTypes
  required public init?(map: ZTCoreKit.ZTMap)
  #endif
  public func mapping(map: ZTCoreKit.ZTMap)
  @objc deinit
}
final public class ZTDeviceInfo : @unchecked Swift.Sendable {
  final public var project: ZTCoreKit.ZTProjectCodeType? {
    get
  }
  final public var productCode: ZTCoreKit.ZTProductCodeType? {
    get
  }
  final public var manufacturer: ZTCoreKit.ZTManufacturerCodeType? {
    get
  }
  final public var productType: ZTCoreKit.ZTProductTypeCode? {
    get
  }
  final public var hardwareVersion: Swift.Int8? {
    get
  }
  final public var boardVersion: Swift.Int8? {
    get
  }
  final public var testeur: Swift.String? {
    get
  }
  final public var sizeRaw: Swift.String? {
    get
  }
  final public var year: Swift.Int? {
    get
  }
  final public var week: Swift.Int? {
    get
  }
  final public var SN: Swift.String? {
    get
  }
  final public var serialNumber: Swift.String
  final public var deviceIdentifier: Swift.String?
  final public var macAddressRight: Swift.String? {
    get
  }
  final public var macAddressLeft: Swift.String? {
    get
  }
  final public var code: Swift.String? {
    get
  }
  public init(code: Swift.String)
  @objc deinit
}
extension ZTCoreKit.ZTDeviceInfo {
  #if compiler(>=5.3) && $NonescapableTypes
  final public var size: Swift.Int? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var gender: Swift.String? {
    get
  }
  #endif
}
extension ZTCoreKit.ZTDeviceInfo : ZTCoreKit.ZTDeviceProtocol {
  final public var actualState: ZTCoreKit.ZTDeviceActualState {
    get
  }
  final public var isConnected: Swift.Bool {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var fwVersion: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var activityType: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var moduleSerialNo: Swift.String? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var qrCode: Swift.String? {
    get
  }
  #endif
  final public var isDeviceReady: Swift.Bool {
    get
  }
}
public enum ZTProductType : Swift.String {
  case sports
  case warm
  case safety
  case podoSmart
  case dfu
  case ztDfu
  case baliston
  public var activityType: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ZTProjectCodeType : Swift.String {
  case zt1
  case zt2
  case zt3
  case zt4
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ZTProductCodeType : Swift.String, Swift.Codable {
  case WS, WM
  case SP
  case SF
  case PS
  case SI
  case BA
  case XX
  public var name: Swift.String {
    get
  }
  public var activityType: Swift.String {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ZTManufacturerCodeType : Swift.String {
  case a
  case b
  case c
  case d
  case e
  case f
  case z
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ZTProductTypeCode : Swift.String {
  case ix
  case sx
  case xx
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ZTGenderCodeType : Swift.String {
  case man
  case woman
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ZTGenderSizeCodeType : Swift.String {
  case a
  case b
  case c
  case d
  case e
  case f
  case g
  case h
  case i
  case j
  case n
  case o
  case p
  case q
  case r
  case s
  case t
  case u
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ZTUnitSizeCodeType : Swift.String {
  case a
  case b
  case c
  case d
  case e
  case f
  case n
  case o
  case p
  case q
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public class ZTDFUKeyResponse : ZTCoreKit.ZTMappable {
  public var mac: Swift.String?
  public var serial: Swift.String?
  public var encKey: Swift.String?
  public var backendPubKey: Swift.String?
  #if compiler(>=5.3) && $NonescapableTypes
  required public init?(map: ZTCoreKit.ZTMap)
  #endif
  public func mapping(map: ZTCoreKit.ZTMap)
  @objc deinit
}
@_inheritsConvenienceInitializers public class ZTDynamicUserAttribute : ZTCoreKit.ZTAttribute {
  public var lastActive: Swift.String
  public var appVersion: Swift.String
  public var buildVersion: Swift.String
  public var country: Swift.String
  public var ip: Swift.String
  public var carrier: Swift.String
  public var language: Swift.String
  public var region: Swift.String
  public var tz: Swift.String
  public init()
  @objc deinit
}
public class ZTMediaFile : ZTCoreKit.ZTMappable {
  public var id: Swift.String?
  public var name: Swift.String?
  public var mimeType: Swift.String?
  public var key: Swift.String?
  public var url: Swift.String?
  public var mfableId: Swift.String?
  public var mfableType: Swift.String?
  public var createdAt: Foundation.Date?
  public var updatedAt: Foundation.Date?
  #if compiler(>=5.3) && $NonescapableTypes
  required public init?(map: ZTCoreKit.ZTMap)
  #endif
  public func mapping(map: ZTCoreKit.ZTMap)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ZTMediaFileTemplate : ZTCoreKit.ZTMappable {
  public var name: Swift.String
  public var description: Swift.String?
  public var mimeType: Swift.String?
  public var key: Swift.String?
  public var url: Swift.String?
  public var data: Foundation.Data?
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init(data: Foundation.Data? = nil, fileName: Swift.String? = nil, mimeType: Swift.String? = nil, description: Swift.String? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  required convenience public init?(map: ZTCoreKit.ZTMap)
  #endif
  public func mapping(map: ZTCoreKit.ZTMap)
  @objc deinit
}
public enum ZTPeriod : Swift.String {
  case day
  case week
  case month
  case year
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct ZTSavedRequest : Swift.Codable, ZTCoreKit.ZTStorable {
  public static let idKey: Swift.WritableKeyPath<ZTCoreKit.ZTSavedRequest, Swift.Int64>
  public var id: Swift.Int64
  public var method: Swift.String
  public var parameters: [Swift.String : Any]
  public var route: Swift.String
  public var timestamp: Swift.Double
  public init(method: Swift.String, parameters: [Swift.String : Any], route: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public typealias ID = Swift.Int64
}
@_hasMissingDesignatedInitializers public class ZTShoesAttribute : ZTCoreKit.ZTAttribute {
  public init(device: any ZTCoreKit.ZTDeviceProtocol)
  @objc deinit
}
public enum ZTPairingType : Swift.String {
  case QRCode
  case BLE
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class ZTStaticUserAttribute : ZTCoreKit.ZTAttribute {
  public var appType: Swift.String
  public var unitType: Swift.String
  public var platform: Swift.String
  public var deviceFamily: Swift.String
  public var deviceType: Swift.String
  public var deviceId: Swift.String
  public var startAppVersion: Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  public init(device: (any ZTCoreKit.ZTDeviceProtocol)?)
  #endif
  @objc deinit
}
public enum ZTUnitType : Swift.String {
  case imperial
  case metric
  public static let current: ZTCoreKit.ZTUnitType
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct ZTUpdateFirmwareResponse : Swift.Codable {
  public var updatable: Swift.Bool
  public var unsupported: Swift.Bool
  public var url: Swift.String?
  public var type: Swift.String?
  public var arch: Swift.String?
  public var version: Swift.String?
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public class ZTUserShoe : ZTCoreKit.ZTMappable {
  public var id: Swift.String?
  public var code: Swift.String?
  public var attributes: [Swift.String : Any]?
  public var firmware: ZTCoreKit.ZTUserShoe.Firmware?
  public var organizationId: Swift.String?
  public var createdAt: Foundation.Date?
  public var updatedAt: Foundation.Date?
  #if compiler(>=5.3) && $NonescapableTypes
  required public init?(map: ZTCoreKit.ZTMap)
  #endif
  public func mapping(map: ZTCoreKit.ZTMap)
  public class Firmware : ZTCoreKit.ZTMappable {
    public var type: Swift.String?
    public var arch: Swift.String?
    public var version: Swift.String?
    public var updatedAt: Foundation.Date?
    #if compiler(>=5.3) && $NonescapableTypes
    required public init?(map: ZTCoreKit.ZTMap)
    #endif
    public func mapping(map: ZTCoreKit.ZTMap)
    @objc deinit
  }
  @objc deinit
}
public protocol ZTDeviceProtocol : Swift.Sendable {
  #if compiler(>=5.3) && $NonescapableTypes
  var macAddressRight: Swift.String? { get }
  #endif
  var serialNumber: Swift.String { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var moduleSerialNo: Swift.String? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var qrCode: Swift.String? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var deviceIdentifier: Swift.String? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var activityType: Swift.String? { get }
  #endif
  var isConnected: Swift.Bool { get }
  #if compiler(>=5.3) && $NonescapableTypes
  var fwVersion: Swift.String? { get }
  #endif
  var isDeviceReady: Swift.Bool { get }
  var actualState: ZTCoreKit.ZTDeviceActualState { get }
}
public protocol ZTStorable {
  associatedtype ID
  static var idKey: Swift.WritableKeyPath<Self, Self.ID> { get }
}
extension Foundation.UserDefaults {
  public static var shared: Foundation.UserDefaults {
    get
  }
}
extension ZTCoreKit.ZTDefaults {
  public static var shared: Foundation.UserDefaults {
    get
  }
  public static let apiKey: ZTCoreKit.ZTDefaultsKey<Swift.String>
  public static let apiSecret: ZTCoreKit.ZTDefaultsKey<Swift.String>
  public static let appId: ZTCoreKit.ZTDefaultsKey<Swift.String>
  public static let orgCode: ZTCoreKit.ZTDefaultsKey<Swift.String>
  public static let appType: ZTCoreKit.ZTDefaultsKey<Swift.String>
  public static let authToken: ZTCoreKit.ZTDefaultsKey<Swift.String>
  public static let refreshToken: ZTCoreKit.ZTDefaultsKey<Swift.String>
  public static let tokenExpire: ZTCoreKit.ZTDefaultsKey<Foundation.Date>
  public static let appUserId: ZTCoreKit.ZTDefaultsKey<Swift.String>
  public static let chunkDuration: ZTCoreKit.ZTDefaultsKey<Swift.Int>
  public static let authData: ZTCoreKit.ZTDefaultsKey<Swift.String>
  public static let lastDeviceSerialNumber: ZTCoreKit.ZTDefaultsKey<Swift.String?>
  public static let lastActivityId: ZTCoreKit.ZTDefaultsKey<Swift.String?>
  public static let lastDeviceQRCode: ZTCoreKit.ZTDefaultsKey<Swift.String?>
  public static let lastQRCode: ZTCoreKit.ZTDefaultsKey<Swift.String?>
  public static let startAppVersion: ZTCoreKit.ZTDefaultsKey<Swift.String>
  public static let deviceId: ZTCoreKit.ZTDefaultsKey<Swift.String>
  public static let pairingMethod: ZTCoreKit.ZTDefaultsKey<Swift.String>
  public static let pairingDate: ZTCoreKit.ZTDefaultsKey<Swift.String>
  public static let startFwVersion: ZTCoreKit.ZTDefaultsKey<Swift.String?>
  public static let startFwType: ZTCoreKit.ZTDefaultsKey<Swift.String?>
  public static let fwVersion: ZTCoreKit.ZTDefaultsKey<Swift.String?>
  public static let fwType: ZTCoreKit.ZTDefaultsKey<Swift.String?>
  public static let wasDfuCopied: ZTCoreKit.ZTDefaultsKey<Swift.Bool?>
  public static let isStorageUpdated: ZTCoreKit.ZTDefaultsKey<Swift.Bool>
  public static let isPHYLongRange: ZTCoreKit.ZTDefaultsKey<Swift.Bool>
  public static let isAgessiveConnection: ZTCoreKit.ZTDefaultsKey<Swift.Bool>
}
extension ZTCoreKit.ZTDefaults {
  public static let lastSafetyActivityID: ZTCoreKit.ZTDefaultsKey<Swift.String?>
  public static let isMonitoringActivity: ZTCoreKit.ZTDefaultsKey<Swift.Bool?>
  public static let userDataParameters: ZTCoreKit.ZTDefaultsKey<Foundation.Data?>
  public static let lastFirmwareCheckDate: ZTCoreKit.ZTDefaultsKey<Foundation.Date?>
  public static let lastAnalyticsDataCheckDate: ZTCoreKit.ZTDefaultsKey<Foundation.Date?>
  public static let lastChunkInterruptionDate: ZTCoreKit.ZTDefaultsKey<Foundation.Date?>
  public static let analyticsData: ZTCoreKit.ZTDefaultsKey<Foundation.Data?>
  public static let streamingMetrics: ZTCoreKit.ZTDefaultsKey<[Swift.String]?>
  public static let currentStreamingMetricSide: ZTCoreKit.ZTDefaultsKey<Swift.UInt8?>
  public static let isStreamingStarted: ZTCoreKit.ZTDefaultsKey<Swift.Bool?>
  public static let realtimeMetricsStartDate: ZTCoreKit.ZTDefaultsKey<Foundation.Date?>
}
public enum ZTRawDataFlowStates : Swift.String, Swift.Codable, Swift.Sendable {
  case prepareRightModule
  case startRightModule
  case endRightModule
  case disconnectRightModule
  case startPeerConnection
  case connectLeftModule
  case prepareLeftModule
  case startLeftModule
  case endLeftModule
  case disconnectLeftModule
  case reconnectRightmodule
  case uploadData
  case none
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension ZTCoreKit.ZTManufacturerData : ZTCoreKit.ZTStorable {
  public static let idKey: Swift.WritableKeyPath<ZTCoreKit.ZTManufacturerData, Swift.String>
  public typealias ID = Swift.String
}
public typealias ZTBaseResult = (_ error: (any Swift.Error)?) -> Swift.Void
public typealias ZTResultObject<T> = (T?, (any Swift.Error)?) -> Swift.Void
public typealias ZTResultArray<T> = ([T]?, (any Swift.Error)?) -> Swift.Void
public typealias ZTCompletion = () -> Swift.Void
public typealias ZTAuthResult = (_ authResponse: ZTCoreKit.ZTAuthResponse?, _ error: (any Swift.Error)?) -> Swift.Void
public typealias Completed = (() -> Swift.Void)?
public typealias ZTBaseAPIResult = (_ error: (any Swift.Error)?) -> Swift.Void
open class ZTCodableTransform<T> : ZTCoreKit.ZTTransformType where T : Swift.Decodable, T : Swift.Encodable {
  public typealias Object = T
  public typealias JSON = Any
  public init()
  #if compiler(>=5.3) && $NonescapableTypes
  open func transformFromJSON(_ value: Any?) -> ZTCoreKit.ZTCodableTransform<T>.Object?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func transformToJSON(_ value: T?) -> Any?
  #endif
  @objc deinit
}
open class ZTCustomDateFormatTransform : ZTCoreKit.ZTDateFormatterTransform {
  public init(formatString: Swift.String)
  @objc deinit
}
open class ZTDataTransform : ZTCoreKit.ZTTransformType {
  public typealias Object = Foundation.Data
  public typealias JSON = Swift.String
  public init()
  #if compiler(>=5.3) && $NonescapableTypes
  open func transformFromJSON(_ value: Any?) -> Foundation.Data?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func transformToJSON(_ value: Foundation.Data?) -> Swift.String?
  #endif
  @objc deinit
}
open class ZTDateFormatterTransform : ZTCoreKit.ZTTransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.String
  final public let dateFormatter: Foundation.DateFormatter
  public init(dateFormatter: Foundation.DateFormatter)
  #if compiler(>=5.3) && $NonescapableTypes
  open func transformFromJSON(_ value: Any?) -> Foundation.Date?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func transformToJSON(_ value: Foundation.Date?) -> Swift.String?
  #endif
  @objc deinit
}
open class ZTDateDefaultTransform : ZTCoreKit.ZTTransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.Double
  public enum Unit : Foundation.TimeInterval {
    case seconds
    case milliseconds
    #if compiler(>=5.3) && $NonescapableTypes
    public init?(rawValue: Foundation.TimeInterval)
    #endif
    public typealias RawValue = Foundation.TimeInterval
    public var rawValue: Foundation.TimeInterval {
      get
    }
  }
  public init(unit: ZTCoreKit.ZTDateDefaultTransform.Unit = .seconds)
  #if compiler(>=5.3) && $NonescapableTypes
  open func transformFromJSON(_ value: Any?) -> Foundation.Date?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func transformToJSON(_ value: Foundation.Date?) -> Swift.Double?
  #endif
  @objc deinit
}
public struct ZTDictionaryTransform<Key, Value> : ZTCoreKit.ZTTransformType where Key : Swift.Hashable, Key : Swift.RawRepresentable, Value : ZTCoreKit.ZTMappable, Key.RawValue == Swift.String {
  public init()
  #if compiler(>=5.3) && $NonescapableTypes
  public func transformFromJSON(_ value: Any?) -> [Key : Value]?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func transformToJSON(_ value: [Key : Value]?) -> Any?
  #endif
  public typealias JSON = Any
  public typealias Object = [Key : Value]
}
public func <<- <T>(left: inout T, right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
public func ->> <T>(left: T, right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
#if compiler(>=5.3) && $NonescapableTypes
public func <<- <T>(left: inout T?, right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
#endif
#if compiler(>=5.3) && $NonescapableTypes
public func ->> <T>(left: T?, right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
#endif
public func <<- <T>(left: inout [T], right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
public func ->> <T>(left: [T], right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
#if compiler(>=5.3) && $NonescapableTypes
public func <<- <T>(left: inout [T]?, right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
#endif
#if compiler(>=5.3) && $NonescapableTypes
public func ->> <T>(left: [T]?, right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
#endif
public func <<- <T>(left: inout [Swift.String : T], right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
public func ->> <T>(left: [Swift.String : T], right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
#if compiler(>=5.3) && $NonescapableTypes
public func <<- <T>(left: inout [Swift.String : T]?, right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
#endif
#if compiler(>=5.3) && $NonescapableTypes
public func ->> <T>(left: [Swift.String : T]?, right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
#endif
open class ZTEnumTransform<T> : ZTCoreKit.ZTTransformType where T : Swift.RawRepresentable {
  public typealias Object = T
  public typealias JSON = T.RawValue
  public init()
  #if compiler(>=5.3) && $NonescapableTypes
  open func transformFromJSON(_ value: Any?) -> T?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func transformToJSON(_ value: T?) -> T.RawValue?
  #endif
  @objc deinit
}
open class ZTHexColorTransform : ZTCoreKit.ZTTransformType {
  public typealias Object = UIKit.UIColor
  public typealias JSON = Swift.String
  public init(prefixToJSON: Swift.Bool = false, alphaToJSON: Swift.Bool = false)
  #if compiler(>=5.3) && $NonescapableTypes
  open func transformFromJSON(_ value: Any?) -> ZTCoreKit.ZTHexColorTransform.Object?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func transformToJSON(_ value: ZTCoreKit.ZTHexColorTransform.Object?) -> ZTCoreKit.ZTHexColorTransform.JSON?
  #endif
  @objc deinit
}
public protocol ZTImmutableMappable : ZTCoreKit.ZTBaseMappable {
  init(map: ZTCoreKit.ZTMap) throws
}
extension ZTCoreKit.ZTImmutableMappable {
  public func mapping(map: ZTCoreKit.ZTMap)
  #if compiler(>=5.3) && $NonescapableTypes
  public init(JSONString: Swift.String, context: (any ZTCoreKit.ZTMapContext)? = nil) throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(JSON: [Swift.String : Any], context: (any ZTCoreKit.ZTMapContext)? = nil) throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(JSONObject: Any, context: (any ZTCoreKit.ZTMapContext)? = nil) throws
  #endif
}
extension ZTCoreKit.ZTMap {
  #if compiler(>=5.3) && $NonescapableTypes
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> Transform.Object where Transform : ZTCoreKit.ZTTransformType
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T where T : Swift.RawRepresentable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T? where T : Swift.RawRepresentable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T] where T : Swift.RawRepresentable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T]? where T : Swift.RawRepresentable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T where T : ZTCoreKit.ZTBaseMappable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T? where T : ZTCoreKit.ZTBaseMappable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T] where T : ZTCoreKit.ZTBaseMappable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T]? where T : ZTCoreKit.ZTBaseMappable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Transform.Object] where Transform : ZTCoreKit.ZTTransformType
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Swift.String : T] where T : ZTCoreKit.ZTBaseMappable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Swift.String : T]? where T : ZTCoreKit.ZTBaseMappable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Swift.String : Transform.Object] where Transform : ZTCoreKit.ZTTransformType
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [[T]]? where T : ZTCoreKit.ZTBaseMappable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [[T]] where T : ZTCoreKit.ZTBaseMappable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [[Transform.Object]] where Transform : ZTCoreKit.ZTTransformType
  #endif
}
extension ZTCoreKit.ZTMapper where N : ZTCoreKit.ZTImmutableMappable {
  final public func map(JSON: [Swift.String : Any]) throws -> N
  final public func map(JSONString: Swift.String) throws -> N
  final public func map(JSONObject: Any) throws -> N
  final public func mapArray(JSONArray: [[Swift.String : Any]]) throws -> [N]
  final public func mapArray(JSONString: Swift.String) throws -> [N]
  final public func mapArray(JSONObject: Any) throws -> [N]
  final public func mapDictionary(JSONString: Swift.String) throws -> [Swift.String : N]
  #if compiler(>=5.3) && $NonescapableTypes
  final public func mapDictionary(JSONObject: Any?) throws -> [Swift.String : N]
  #endif
  final public func mapDictionary(JSON: [Swift.String : [Swift.String : Any]]) throws -> [Swift.String : N]
  #if compiler(>=5.3) && $NonescapableTypes
  final public func mapDictionaryOfArrays(JSONObject: Any?) throws -> [Swift.String : [N]]
  #endif
  final public func mapDictionaryOfArrays(JSON: [Swift.String : [[Swift.String : Any]]]) throws -> [Swift.String : [N]]
  #if compiler(>=5.3) && $NonescapableTypes
  final public func mapArrayOfArrays(JSONObject: Any?) throws -> [[N]]
  #endif
}
public func <<- <T>(left: inout T, right: ZTCoreKit.ZTMap) where T : Swift.SignedInteger
#if compiler(>=5.3) && $NonescapableTypes
public func <<- <T>(left: inout T?, right: ZTCoreKit.ZTMap) where T : Swift.SignedInteger
#endif
public func <<- <T>(left: inout T, right: ZTCoreKit.ZTMap) where T : Swift.UnsignedInteger
#if compiler(>=5.3) && $NonescapableTypes
public func <<- <T>(left: inout T?, right: ZTCoreKit.ZTMap) where T : Swift.UnsignedInteger
#endif
extension Foundation.DateFormatter {
  convenience public init(withFormat format: Swift.String, locale: Swift.String)
}
open class ZTISO8601DateTransform : ZTCoreKit.ZTDateFormatterTransform {
  public init()
  @objc deinit
}
public protocol ZTMapContext {
}
final public class ZTMap {
  final public let mappingType: ZTCoreKit.ZTMappingType
  final public var JSON: [Swift.String : Any] {
    get
  }
  final public var isKeyPresent: Swift.Bool {
    get
  }
  final public var currentValue: Any? {
    get
  }
  final public var currentKey: Swift.String? {
    get
  }
  final public var nestedKeyDelimiter: Swift.String {
    get
  }
  final public var context: (any ZTCoreKit.ZTMapContext)?
  final public var shouldIncludeNilValues: Swift.Bool
  final public let toObject: Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  public init(mappingType: ZTCoreKit.ZTMappingType, JSON: [Swift.String : Any], toObject: Swift.Bool = false, context: (any ZTCoreKit.ZTMapContext)? = nil, shouldIncludeNilValues: Swift.Bool = false)
  #endif
  final public subscript(key: Swift.String) -> ZTCoreKit.ZTMap {
    get
  }
  final public subscript(key: Swift.String, delimiter delimiter: Swift.String) -> ZTCoreKit.ZTMap {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool) -> ZTCoreKit.ZTMap {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool, delimiter delimiter: Swift.String) -> ZTCoreKit.ZTMap {
    get
  }
  final public subscript(key: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> ZTCoreKit.ZTMap {
    get
  }
  final public subscript(key: Swift.String, delimiter delimiter: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> ZTCoreKit.ZTMap {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool, ignoreNil ignoreNil: Swift.Bool) -> ZTCoreKit.ZTMap {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public subscript(key: Swift.String, nested nested: Swift.Bool?, delimiter delimiter: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> ZTCoreKit.ZTMap {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func value<T>() -> T?
  #endif
  @objc deinit
}
extension ZTCoreKit.ZTMap {
  final public func value<T>(_ key: Swift.String, default: T.Object, using transform: T) throws -> T.Object where T : ZTCoreKit.ZTTransformType
  final public func value<T>(_ key: Swift.String, default: T) throws -> T
  final public func value<T>(_ key: Swift.String, default: [T]) -> [T] where T : ZTCoreKit.ZTBaseMappable
  final public func value<T>(_ key: Swift.String, default: T) throws -> T where T : ZTCoreKit.ZTBaseMappable
}
public struct ZTMapError : Swift.Error {
  public var key: Swift.String?
  public var currentValue: Any?
  public var reason: Swift.String?
  public var file: Swift.StaticString?
  public var function: Swift.StaticString?
  public var line: Swift.UInt?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(key: Swift.String?, currentValue: Any?, reason: Swift.String?, file: Swift.StaticString? = nil, function: Swift.StaticString? = nil, line: Swift.UInt? = nil)
  #endif
}
extension ZTCoreKit.ZTMapError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol ZTBaseMappable {
  mutating func mapping(map: ZTCoreKit.ZTMap)
}
public protocol ZTMappable : ZTCoreKit.ZTBaseMappable {
  #if compiler(>=5.3) && $NonescapableTypes
  init?(map: ZTCoreKit.ZTMap)
  #endif
}
public protocol ZTStaticMappable : ZTCoreKit.ZTBaseMappable {
  #if compiler(>=5.3) && $NonescapableTypes
  static func objectForMapping(map: ZTCoreKit.ZTMap) -> (any ZTCoreKit.ZTBaseMappable)?
  #endif
}
extension ZTCoreKit.ZTMappable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(JSONString: Swift.String, context: (any ZTCoreKit.ZTMapContext)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(JSON: [Swift.String : Any], context: (any ZTCoreKit.ZTMapContext)? = nil)
  #endif
}
extension ZTCoreKit.ZTBaseMappable {
  public func toJSON() -> [Swift.String : Any]
  #if compiler(>=5.3) && $NonescapableTypes
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
  #endif
}
extension Swift.Array where Element : ZTCoreKit.ZTBaseMappable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(JSONString: Swift.String, context: (any ZTCoreKit.ZTMapContext)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(JSONArray: [[Swift.String : Any]], context: (any ZTCoreKit.ZTMapContext)? = nil)
  #endif
  public func toJSON() -> [[Swift.String : Any]]
  #if compiler(>=5.3) && $NonescapableTypes
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
  #endif
}
extension Swift.Set where Element : ZTCoreKit.ZTBaseMappable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(JSONString: Swift.String, context: (any ZTCoreKit.ZTMapContext)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(JSONArray: [[Swift.String : Any]], context: (any ZTCoreKit.ZTMapContext)? = nil)
  #endif
  public func toJSON() -> [[Swift.String : Any]]
  #if compiler(>=5.3) && $NonescapableTypes
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
  #endif
}
public enum ZTMappingType {
  case fromJSON
  case toJSON
  public static func == (a: ZTCoreKit.ZTMappingType, b: ZTCoreKit.ZTMappingType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class ZTMapper<N> where N : ZTCoreKit.ZTBaseMappable {
  final public var context: (any ZTCoreKit.ZTMapContext)?
  final public var shouldIncludeNilValues: Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  public init(context: (any ZTCoreKit.ZTMapContext)? = nil, shouldIncludeNilValues: Swift.Bool = false)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func map(JSONObject: Any?, toObject object: N) -> N
  #endif
  final public func map(JSONString: Swift.String, toObject object: N) -> N
  final public func map(JSON: [Swift.String : Any], toObject object: N) -> N
  #if compiler(>=5.3) && $NonescapableTypes
  final public func map(JSONString: Swift.String) -> N?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func map(JSONObject: Any?) -> N?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func map(JSON: [Swift.String : Any]) -> N?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func mapArray(JSONString: Swift.String) -> [N]?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func mapArray(JSONObject: Any?) -> [N]?
  #endif
  final public func mapArray(JSONArray: [[Swift.String : Any]]) -> [N]
  #if compiler(>=5.3) && $NonescapableTypes
  final public func mapDictionary(JSONString: Swift.String) -> [Swift.String : N]?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func mapDictionary(JSONObject: Any?) -> [Swift.String : N]?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func mapDictionary(JSON: [Swift.String : [Swift.String : Any]]) -> [Swift.String : N]?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func mapDictionary(JSONObject: Any?, toDictionary dictionary: [Swift.String : N]) -> [Swift.String : N]
  #endif
  final public func mapDictionary(JSON: [Swift.String : [Swift.String : Any]], toDictionary dictionary: [Swift.String : N]) -> [Swift.String : N]
  #if compiler(>=5.3) && $NonescapableTypes
  final public func mapDictionaryOfArrays(JSONObject: Any?) -> [Swift.String : [N]]?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func mapDictionaryOfArrays(JSON: [Swift.String : [[Swift.String : Any]]]) -> [Swift.String : [N]]?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func mapArrayOfArrays(JSONObject: Any?) -> [[N]]?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func parseJSONStringIntoDictionary(JSONString: Swift.String) -> [Swift.String : Any]?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func parseJSONString(JSONString: Swift.String) -> Any?
  #endif
  @objc deinit
}
extension ZTCoreKit.ZTMapper {
  #if compiler(>=5.3) && $NonescapableTypes
  final public func map(JSONfile: Swift.String) -> N?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func mapArray(JSONfile: Swift.String) -> [N]?
  #endif
}
extension ZTCoreKit.ZTMapper {
  final public func toJSON(_ object: N) -> [Swift.String : Any]
  final public func toJSONArray(_ array: [N]) -> [[Swift.String : Any]]
  final public func toJSONDictionary(_ dictionary: [Swift.String : N]) -> [Swift.String : [Swift.String : Any]]
  final public func toJSONDictionaryOfArrays(_ dictionary: [Swift.String : [N]]) -> [Swift.String : [[Swift.String : Any]]]
  #if compiler(>=5.3) && $NonescapableTypes
  final public func toJSONString(_ object: N, prettyPrint: Swift.Bool = false) -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func toJSONString(_ array: [N], prettyPrint: Swift.Bool = false) -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func toJSONString(_ JSONObject: Any, prettyPrint: Swift.Bool) -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public static func toJSONData(_ JSONObject: Any, options: Foundation.JSONSerialization.WritingOptions) -> Foundation.Data?
  #endif
}
extension ZTCoreKit.ZTMapper where N : Swift.Hashable {
  #if compiler(>=5.3) && $NonescapableTypes
  final public func mapSet(JSONString: Swift.String) -> Swift.Set<N>?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func mapSet(JSONObject: Any?) -> Swift.Set<N>?
  #endif
  final public func mapSet(JSONArray: [[Swift.String : Any]]) -> Swift.Set<N>
  final public func toJSONSet(_ set: Swift.Set<N>) -> [[Swift.String : Any]]
  #if compiler(>=5.3) && $NonescapableTypes
  final public func toJSONString(_ set: Swift.Set<N>, prettyPrint: Swift.Bool = false) -> Swift.String?
  #endif
}
open class ZTNSDecimalNumberTransform : ZTCoreKit.ZTTransformType {
  public typealias Object = Foundation.NSDecimalNumber
  public typealias JSON = Swift.String
  public init()
  #if compiler(>=5.3) && $NonescapableTypes
  open func transformFromJSON(_ value: Any?) -> Foundation.NSDecimalNumber?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func transformToJSON(_ value: Foundation.NSDecimalNumber?) -> Swift.String?
  #endif
  @objc deinit
}
infix operator <<- : DefaultPrecedence
infix operator ->> : DefaultPrecedence
public func <<- <T>(left: inout T, right: ZTCoreKit.ZTMap)
public func ->> <T>(left: T, right: ZTCoreKit.ZTMap)
#if compiler(>=5.3) && $NonescapableTypes
public func <<- <T>(left: inout T?, right: ZTCoreKit.ZTMap)
#endif
#if compiler(>=5.3) && $NonescapableTypes
public func ->> <T>(left: T?, right: ZTCoreKit.ZTMap)
#endif
public func <<- <T>(left: inout T, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func ->> <T>(left: T, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
#if compiler(>=5.3) && $NonescapableTypes
public func <<- <T>(left: inout T?, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
#endif
#if compiler(>=5.3) && $NonescapableTypes
public func ->> <T>(left: T?, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
#endif
public func <<- <T>(left: inout [Swift.String : T], right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func ->> <T>(left: [Swift.String : T], right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
#if compiler(>=5.3) && $NonescapableTypes
public func <<- <T>(left: inout [Swift.String : T]?, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
#endif
#if compiler(>=5.3) && $NonescapableTypes
public func ->> <T>(left: [Swift.String : T]?, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
#endif
public func <<- <T>(left: inout [Swift.String : [T]], right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func ->> <T>(left: [Swift.String : [T]], right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
#if compiler(>=5.3) && $NonescapableTypes
public func <<- <T>(left: inout [Swift.String : [T]]?, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
#endif
#if compiler(>=5.3) && $NonescapableTypes
public func ->> <T>(left: [Swift.String : [T]]?, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
#endif
public func <<- <T>(left: inout [T], right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func ->> <T>(left: [T], right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
#if compiler(>=5.3) && $NonescapableTypes
public func <<- <T>(left: inout [T]?, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
#endif
#if compiler(>=5.3) && $NonescapableTypes
public func ->> <T>(left: [T]?, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
#endif
public func <<- <T>(left: inout [[T]], right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func ->> <T>(left: [[T]], right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
#if compiler(>=5.3) && $NonescapableTypes
public func <<- <T>(left: inout [[T]]?, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
#endif
#if compiler(>=5.3) && $NonescapableTypes
public func ->> <T>(left: [[T]]?, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
#endif
public func <<- <T>(left: inout Swift.Set<T>, right: ZTCoreKit.ZTMap) where T : Swift.Hashable, T : ZTCoreKit.ZTBaseMappable
public func ->> <T>(left: Swift.Set<T>, right: ZTCoreKit.ZTMap) where T : Swift.Hashable, T : ZTCoreKit.ZTBaseMappable
#if compiler(>=5.3) && $NonescapableTypes
public func <<- <T>(left: inout Swift.Set<T>?, right: ZTCoreKit.ZTMap) where T : Swift.Hashable, T : ZTCoreKit.ZTBaseMappable
#endif
#if compiler(>=5.3) && $NonescapableTypes
public func ->> <T>(left: Swift.Set<T>?, right: ZTCoreKit.ZTMap) where T : Swift.Hashable, T : ZTCoreKit.ZTBaseMappable
#endif
open class ZTTransformOf<ObjectType, JSONType> : ZTCoreKit.ZTTransformType {
  public typealias Object = ObjectType
  public typealias JSON = JSONType
  #if compiler(>=5.3) && $NonescapableTypes
  public init(fromJSON: @escaping (JSONType?) -> ObjectType?, toJSON: @escaping (ObjectType?) -> JSONType?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func transformFromJSON(_ value: Any?) -> ObjectType?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func transformToJSON(_ value: ObjectType?) -> JSONType?
  #endif
  @objc deinit
}
public func <<- <Transform>(left: inout Transform.Object, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
public func ->> <Transform>(left: Transform.Object, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
#if compiler(>=5.3) && $NonescapableTypes
public func <<- <Transform>(left: inout Transform.Object?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
#endif
#if compiler(>=5.3) && $NonescapableTypes
public func ->> <Transform>(left: Transform.Object?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
#endif
public func <<- <Transform>(left: inout [Transform.Object], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
public func ->> <Transform>(left: [Transform.Object], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
#if compiler(>=5.3) && $NonescapableTypes
public func <<- <Transform>(left: inout [Transform.Object]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
#endif
#if compiler(>=5.3) && $NonescapableTypes
public func ->> <Transform>(left: [Transform.Object]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
#endif
public func <<- <Transform>(left: inout [Swift.String : Transform.Object], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
public func ->> <Transform>(left: [Swift.String : Transform.Object], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
#if compiler(>=5.3) && $NonescapableTypes
public func <<- <Transform>(left: inout [Swift.String : Transform.Object]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
#endif
#if compiler(>=5.3) && $NonescapableTypes
public func ->> <Transform>(left: [Swift.String : Transform.Object]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
#endif
public func <<- <Transform>(left: inout Transform.Object, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
public func ->> <Transform>(left: Transform.Object, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
#if compiler(>=5.3) && $NonescapableTypes
public func <<- <Transform>(left: inout Transform.Object?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
#endif
#if compiler(>=5.3) && $NonescapableTypes
public func ->> <Transform>(left: Transform.Object?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
#endif
public func <<- <Transform>(left: inout [Swift.String : Transform.Object], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
public func ->> <Transform>(left: [Swift.String : Transform.Object], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
#if compiler(>=5.3) && $NonescapableTypes
public func <<- <Transform>(left: inout [Swift.String : Transform.Object]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
#endif
#if compiler(>=5.3) && $NonescapableTypes
public func ->> <Transform>(left: [Swift.String : Transform.Object]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
#endif
public func <<- <Transform>(left: inout [Swift.String : [Transform.Object]], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
public func ->> <Transform>(left: [Swift.String : [Transform.Object]], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
#if compiler(>=5.3) && $NonescapableTypes
public func <<- <Transform>(left: inout [Swift.String : [Transform.Object]]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
#endif
#if compiler(>=5.3) && $NonescapableTypes
public func ->> <Transform>(left: [Swift.String : [Transform.Object]]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
#endif
public func <<- <Transform>(left: inout [Transform.Object], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
public func ->> <Transform>(left: [Transform.Object], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
#if compiler(>=5.3) && $NonescapableTypes
public func <<- <Transform>(left: inout [Transform.Object]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
#endif
#if compiler(>=5.3) && $NonescapableTypes
public func ->> <Transform>(left: [Transform.Object]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
#endif
public func <<- <Transform>(left: inout [[Transform.Object]], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
public func ->> <Transform>(left: [[Transform.Object]], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
#if compiler(>=5.3) && $NonescapableTypes
public func <<- <Transform>(left: inout [[Transform.Object]]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
#endif
#if compiler(>=5.3) && $NonescapableTypes
public func ->> <Transform>(left: [[Transform.Object]]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
#endif
public func <<- <Transform>(left: inout Swift.Set<Transform.Object>, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : Swift.Hashable, Transform.Object : ZTCoreKit.ZTBaseMappable
public func ->> <Transform>(left: Swift.Set<Transform.Object>, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : Swift.Hashable, Transform.Object : ZTCoreKit.ZTBaseMappable
#if compiler(>=5.3) && $NonescapableTypes
public func <<- <Transform>(left: inout Swift.Set<Transform.Object>?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : Swift.Hashable, Transform.Object : ZTCoreKit.ZTBaseMappable
#endif
#if compiler(>=5.3) && $NonescapableTypes
public func ->> <Transform>(left: Swift.Set<Transform.Object>?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : Swift.Hashable, Transform.Object : ZTCoreKit.ZTBaseMappable
#endif
public protocol ZTTransformType {
  associatedtype Object
  associatedtype JSON
  #if compiler(>=5.3) && $NonescapableTypes
  func transformFromJSON(_ value: Any?) -> Self.Object?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func transformToJSON(_ value: Self.Object?) -> Self.JSON?
  #endif
}
open class ZTURLTransform : ZTCoreKit.ZTTransformType {
  public typealias Object = Foundation.URL
  public typealias JSON = Swift.String
  public init(shouldEncodeURLString: Swift.Bool = false, allowedCharacterSet: Foundation.CharacterSet = .urlQueryAllowed)
  #if compiler(>=5.3) && $NonescapableTypes
  open func transformFromJSON(_ value: Any?) -> Foundation.URL?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func transformToJSON(_ value: Foundation.URL?) -> Swift.String?
  #endif
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class ZTDataManager {
  public static let instance: ZTCoreKit.ZTDataManager
  public static let storageMainBundleName: Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  final public var appAttributes: [Swift.String : Any]? {
    get
    set
  }
  #endif
  final public let devicesStoreNew: ZTCoreKit.ZTDefaultsStore<ZTCoreKit.ZTSavedDevice>?
  final public let requestsStore: ZTCoreKit.ZTDefaultsStore<ZTCoreKit.ZTSavedRequest>?
  final public let activityAppDataStore: ZTCoreKit.ZTDefaultsStore<ZTCoreKit.ZTActivityAppData>?
  final public let manufacturerDataStoreNew: ZTCoreKit.ZTDefaultsStore<ZTCoreKit.ZTManufacturerData>?
  final public var activityAppDataStoreCount: Swift.Int
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ZTDefaults {
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ZTDefaultsKey<T> : ZTCoreKit.ZTDefaults {
  final public let stringValue: Swift.String
  public init(_ value: Swift.String)
  @objc deinit
}
extension Foundation.UserDefaults {
  public subscript(key: ZTCoreKit.ZTDefaultsKey<Swift.Float>) -> Swift.Float {
    get
    set
  }
  public subscript(key: ZTCoreKit.ZTDefaultsKey<Swift.Double>) -> Swift.Double {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public subscript<T>(key: ZTCoreKit.ZTDefaultsKey<T>) -> T? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public subscript(key: ZTCoreKit.ZTDefaultsKey<Swift.String>) -> Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public subscript(key: ZTCoreKit.ZTDefaultsKey<Foundation.Data>) -> Foundation.Data? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public subscript(key: ZTCoreKit.ZTDefaultsKey<Foundation.Date>) -> Foundation.Date? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public subscript(key: ZTCoreKit.ZTDefaultsKey<Foundation.URL>) -> Foundation.URL? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public subscript(key: ZTCoreKit.ZTDefaultsKey<[Foundation.URL]>) -> [Foundation.URL]? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public subscript(key: ZTCoreKit.ZTDefaultsKey<[Swift.String : Foundation.URL]>) -> [Swift.String : Foundation.URL]? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public subscript<T>(key: ZTCoreKit.ZTDefaultsKey<T>) -> T? where T : Swift.Decodable, T : Swift.Encodable {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public subscript(key: Swift.String) -> Any? {
    get
    set(value)
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func value<T>(forKey key: Swift.String) -> T?
  #endif
  public func clear(_ key: Swift.String)
  public func clear<T>(_ key: ZTCoreKit.ZTDefaultsKey<T>)
  public func clearAll()
}
@_hasMissingDesignatedInitializers public class ZTHelpers : @unchecked Swift.Sendable {
  public static let version: Swift.String
  public static let apiVersion: Swift.String
  public static var zcVersion: Swift.String
  public static let bundle: Swift.String
  public static let name: Swift.String
  @objc deinit
}
public struct ZTMeasureEllapsedTime {
  public static func measureElapsedTime(_ operation: () throws -> Swift.Void) throws -> Swift.UInt64
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public static func measure<R>(functionName: Swift.String = #function, debug: ((Swift.String) -> Swift.Void)? = nil, body: () throws -> R) rethrows -> R
  #endif
}
public func withTimeout<T>(_ seconds: Foundation.TimeInterval, operation: @escaping () async throws -> T) async throws -> T
public func checkCondtion(timeout: Foundation.TimeInterval, nanoSecondsCheckInterval: Swift.UInt64 = 100_000, _ check: @escaping () async throws -> Swift.Bool) async throws -> Swift.Bool
public struct TimeoutError : Swift.Error {
}
public protocol ZhortechLoggerProtocol {
  nonisolated func ztDebugPrint(_ message: Swift.String)
  nonisolated func debug(_ message: Swift.StaticString, _ args: any Swift.CVarArg...)
  nonisolated func info(_ message: Swift.StaticString, _ args: any Swift.CVarArg...)
  nonisolated func error(_ message: Swift.StaticString, _ args: any Swift.CVarArg...)
  nonisolated func fatal(_ message: Swift.StaticString, _ args: any Swift.CVarArg...)
}
public enum ZTLogCategory : Swift.String, Swift.Codable, Swift.Sendable, Swift.CaseIterable {
  case networkAgent
  case modules
  case sdk
  case base
  case coreData
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias AllCases = [ZTCoreKit.ZTLogCategory]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [ZTCoreKit.ZTLogCategory] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
extension ZTCoreKit.ZTLogCategory : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
final public class ZTLogger : Swift.Codable {
  final public let category: ZTCoreKit.ZTLogCategory
  final public let prefixString: Swift.String
  final public var indent: Swift.UInt
  final public var logLevel: ZTCoreKit.ZTLogLevel
  final public var showDate: Swift.Bool
  public init(_ prefix: Swift.String, category: ZTCoreKit.ZTLogCategory = .sdk, level: ZTCoreKit.ZTLogLevel = .info)
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension ZTCoreKit.ZTLogger : ZTCoreKit.ZhortechLoggerProtocol {
  final public func debugCaller(_ message: Swift.String, file: Swift.String = #fileID, function: Swift.String = #function, line: Swift.Int = #line)
  final nonisolated public func ztDebugPrint(_ message: Swift.String)
  nonisolated final public func debug(_ message: Swift.StaticString, _ args: any Swift.CVarArg...)
  final public func debug(_ message: Swift.String)
  nonisolated final public func info(_ message: Swift.StaticString, _ args: any Swift.CVarArg...)
  final public func info(_ message: Swift.String)
  final nonisolated public func error(_ message: Swift.StaticString, _ args: any Swift.CVarArg...)
  final public func error(_ message: Swift.String)
  final nonisolated public func fatal(_ message: Swift.StaticString, _ args: any Swift.CVarArg...)
  final public func fatal(_ message: Swift.String)
  final public func log(_ message: Swift.StaticString, level: ZTCoreKit.ZTLogLevel, _ args: [any Swift.CVarArg])
  final public func log(_ message: Swift.String, level: ZTCoreKit.ZTLogLevel)
}
public struct ZTLoggerLine : Swift.Codable {
  public static let notification: Foundation.Notification.Name
  public var date: Foundation.Date
  public let message: Swift.String
  public let level: Swift.String
  public let category: Swift.String
  public init(message: Swift.String, level: ZTCoreKit.ZTLogLevel, category: ZTCoreKit.ZTLogCategory)
  public func post()
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum ZTLogLevel : Swift.String, Swift.Codable, Swift.Sendable {
  case all
  case debug
  case info
  case error
  case fatal
  public var logType: os.OSLogType {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension ZTCoreKit.ZTLogLevel : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Swift.Array {
  public typealias Parameters = [Swift.String : Any]
  public func asParameters() -> Swift.Array<Element>.Parameters
}
@_hasMissingDesignatedInitializers public class ZTAuthManager {
  public static let shared: ZTCoreKit.ZTAuthManager
  @objc deinit
  #if compiler(>=5.3) && $NonescapableTypes
  public var apiKey: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var secret: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var appId: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var orgCode: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var appType: Swift.String? {
    get
    set
  }
  #endif
  final public let onAuthTokenUpdated: ZTCoreKit.ZTSignal<Swift.Bool>
  #if compiler(>=5.3) && $NonescapableTypes
  public var authToken: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var expire: Foundation.Date? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var refreshToken: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var appUserId: Swift.String? {
    get
    set
  }
  #endif
  public var userDidSignout: Swift.Bool
  public func authenticate(_ completion: @escaping ZTCoreKit.ZTBaseResult)
  public func refreshToken(completion: @escaping ZTCoreKit.ZTBaseResult)
  public func checkTokenExpiration()
  public func generateAppUser() -> Swift.String
  public func signout()
}
@_hasMissingDesignatedInitializers public class ZTMediaUploader {
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ZTNetworkManager {
  public static let instance: ZTCoreKit.ZTNetworkManager
  public var shoesAttribute: ZTCoreKit.ZTShoesAttribute?
  public var isNetworkReachable: Swift.Bool
  final public let onInternetConnectionChanged: ZTCoreKit.ZTSignal<Swift.Bool>
  public var apiService: ZTCoreKit.ZTApiService {
    get
    set
  }
  public var mediaUploader: ZTCoreKit.ZTMediaUploader {
    get
    set
  }
  @objc deinit
  public func cancelAllRequests()
}
extension ZTCoreKit.ZTNetworkManager {
  public typealias Parameters = [Swift.String : Any]
  public func saveRequest(method: Swift.String, params: ZTCoreKit.ZTNetworkManager.Parameters, route: Swift.String)
  public func resendSavedRequests()
  public func resendSavedActivityRequests(completion: @escaping ZTCoreKit.ZTBaseResult)
  public func authenticate()
  #if compiler(>=5.3) && $NonescapableTypes
  public func linkUser(userId: Swift.String, device: (any ZTCoreKit.ZTDeviceProtocol)?, attributes: [Swift.String : Any], completion: @escaping ZTCoreKit.ZTBaseResult)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func userCreate(userId: Swift.String, attributes: [Swift.String : Any], completion: ZTCoreKit.ZTBaseResult? = nil)
  #endif
  public func updateDynamicAttribites()
  #if compiler(>=5.3) && $NonescapableTypes
  public func uploadProfileImage(_ image: Foundation.Data, completion: ZTCoreKit.ZTBaseResult? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getProfileImage(completion: ((UIKit.UIImage?, (any Swift.Error)?) -> Swift.Void)? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func userConnect(device: (any ZTCoreKit.ZTDeviceProtocol)?, deviceInfo: ZTCoreKit.ZTDeviceInfo? = nil, isConnected: Swift.Bool, completion: ZTCoreKit.ZTResultObject<ZTCoreKit.ZTConnectResponse>? = nil)
  #endif
  public func getUserShoes(completion: @escaping ZTCoreKit.ZTResultArray<ZTCoreKit.ZTUserShoe>)
  public func getUserShoe(code: Swift.String, completion: @escaping ZTCoreKit.ZTResultObject<ZTCoreKit.ZTUserShoe>)
  public func updateUserShoe(code: Swift.String, attributes: [Swift.String : Any], completion: @escaping ZTCoreKit.ZTResultObject<ZTCoreKit.ZTUserShoe>)
  public func deleteUserShoe(code: Swift.String, completion: @escaping ZTCoreKit.ZTBaseResult)
  #if compiler(>=5.3) && $NonescapableTypes
  public func userFirmwareUpdated(info: ZTCoreKit.ZTDeviceUpgradeInfo?, version: Swift.String?, completion: ZTCoreKit.ZTBaseResult? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func startActivity(id: Swift.String, startTime: Swift.Int64, timezone: Swift.String, code: Swift.String, attributes: [Swift.String : Any]? = nil, completion: ((Swift.String?, (any Swift.Error)?) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func addActivitySegment(activityId: Swift.String, timestamp: Swift.Int64, timezone: Swift.String, data: Swift.String?, completion: @escaping ZTCoreKit.ZTBaseResult)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func addActivitySegments(activityId: Swift.String, device: (any ZTCoreKit.ZTDeviceProtocol)?, timestamp: Swift.Int64, timezone: Swift.String, duration: Swift.Int? = nil, packets: [ZTCoreKit.ZhorthechPacket]?, completion: @escaping ZTCoreKit.ZTBaseResult)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func addActivityChunk(code: Swift.String, device: any ZTCoreKit.ZTDeviceProtocol, chunk: ZTCoreKit.ZhorthechPacket, attributes: [Swift.String : Any]? = nil, completion: @escaping ZTCoreKit.ZTBaseResult)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func addActivityChunks(code: Swift.String, device: (any ZTCoreKit.ZTDeviceProtocol)?, chunks: [ZTCoreKit.ZhorthechPacket], attributes: [Swift.String : Any]? = nil, completion: @escaping ZTCoreKit.ZTBaseResult)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func addActivityData(activityId: Swift.String, timestamp: Swift.Int64, timezone: Swift.String, data: [Swift.String : Any]?, completion: @escaping ZTCoreKit.ZTBaseResult)
  #endif
  public func addActivityData(data: [ZTCoreKit.ZTActivityAppData], completion: @escaping ZTCoreKit.ZTBaseResult)
  #if compiler(>=5.3) && $NonescapableTypes
  public func stopActivity<T>(id: Swift.String, timestamp: Swift.Int64, timezone: Swift.String, duration: Swift.Int? = nil, data: [Swift.String]?, completion: @escaping (T?, (any Swift.Error)?) -> Swift.Void) where T : ZTCoreKit.ZTMappable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func stopActivity<T>(id: Swift.String, timestamp: Swift.Int64, timezone: Swift.String, duration: Swift.Int? = nil, packets: [ZTCoreKit.ZhorthechPacket]?, completion: @escaping (T?, (any Swift.Error)?) -> Swift.Void) where T : ZTCoreKit.ZTMappable
  #endif
  public func deleteActivity(id: Swift.String, completion: @escaping ZTCoreKit.ZTBaseResult)
  #if compiler(>=5.3) && $NonescapableTypes
  public func getActivities<T>(code: Swift.String?, start: Foundation.Date, end: Foundation.Date, fields: [Swift.String] = [], include: [Swift.String]? = nil, timeZone: Swift.String = TimeZone.current.identifier, completion: @escaping ([T]?, (any Swift.Error)?) -> Swift.Void) where T : ZTCoreKit.ZTMappable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getActivities<T>(code: Swift.String?, offset: Swift.Int, limit: Swift.Int, fields: [Swift.String] = [], include: [Swift.String]? = nil, whereOptions: [Swift.String : Any]? = nil, duration: [Swift.String : Any]? = nil, start: Foundation.Date? = nil, end: Foundation.Date? = nil, timeZone: Swift.String = TimeZone.current.identifier, completion: @escaping ([T]?, (any Swift.Error)?) -> Swift.Void) where T : ZTCoreKit.ZTMappable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getActivity<T>(id: Swift.String, fields: [Swift.String] = [], include: [Swift.String]? = nil, whereOptions: [Swift.String : Any]? = nil, duration: [Swift.String : Any]? = nil, start: Foundation.Date? = nil, end: Foundation.Date? = nil, completion: @escaping (T?, (any Swift.Error)?) -> Swift.Void) where T : ZTCoreKit.ZTMappable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getData<T>(path: Swift.String, parameters: [Swift.String : Any]?, completion: @escaping (T?, (any Swift.Error)?) -> Swift.Void) where T : ZTCoreKit.ZTMappable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getData(path: Swift.String, parameters: [Swift.String : Any]? = nil, completion: @escaping ([Swift.String : Any]?, Foundation.Data?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getData(path: Swift.String, parameters: [Swift.String : Any]? = nil, completion: @escaping ([[Swift.String : Any]]?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func download(urlPath: Swift.String, completion: @escaping (Foundation.URL?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func addActivityComment(activityId: Swift.String, text: Swift.String, mediaFileTemplates: [ZTCoreKit.ZTMediaFileTemplate]?, completion: @escaping ZTCoreKit.ZTResultObject<ZTCoreKit.ZTActivityComment>)
  #endif
  public func prepareMediaTemplate(mediaFileTemplate: ZTCoreKit.ZTMediaFileTemplate, completion: @escaping ZTCoreKit.ZTResultObject<ZTCoreKit.ZTMediaFileTemplate>)
  public func uploadMediaFile(filePath: Foundation.URL, uploadUrl: Swift.String, completion: @escaping ZTCoreKit.ZTBaseResult)
  public func getActivityComments(activityId: Swift.String, completion: @escaping ZTCoreKit.ZTResultArray<ZTCoreKit.ZTActivityComment>)
  public func getActivityComment(activityId: Swift.String = "", commentId: Swift.String, completion: @escaping ZTCoreKit.ZTResultObject<ZTCoreKit.ZTActivityComment>)
  #if compiler(>=5.3) && $NonescapableTypes
  public func getActivityRealtimeData(activityId: Swift.String, fields: [Swift.String], completion: @escaping ([Swift.String : Any]?, (any Swift.Error)?) -> Swift.Void)
  #endif
  public func saveActivityComment(activityId: Swift.String = "", commentId: Swift.String, text: Swift.String, completion: @escaping ZTCoreKit.ZTBaseResult)
  public func deleteActivityComment(activityId: Swift.String = "", commentId: Swift.String, completion: @escaping ZTCoreKit.ZTBaseResult)
  public func addActivityCommentMediafile(activityId: Swift.String = "", commentId: Swift.String, mediaTemplate: ZTCoreKit.ZTMediaFileTemplate, completion: @escaping ZTCoreKit.ZTBaseResult)
  public func deleteActivityCommentMediafile(activityId: Swift.String = "", commentId: Swift.String = "", mediafileId: Swift.String, completion: @escaping ZTCoreKit.ZTBaseResult)
  public func deleteIndirectMessage(id: Swift.String, completion: @escaping ZTCoreKit.ZTBaseResult)
  #if compiler(>=5.3) && $NonescapableTypes
  public func trackEvent(name: Swift.String, data: [Swift.String : Any]? = nil, timestamp: Swift.Int64? = nil, attributes: [Swift.String : Any]? = nil)
  #endif
  public func log(severity: ZTCoreKit.ZTLoggerSeverity = ZTLoggerSeverity.debug, component: ZTCoreKit.ZTLoggerComponent = ZTLoggerComponent.sdk, message: Swift.String)
  #if compiler(>=5.3) && $NonescapableTypes
  public func postData<T>(path: Swift.String, parameters: [Swift.String : Any]?, completion: @escaping (T?, (any Swift.Error)?) -> Swift.Void) where T : ZTCoreKit.ZTMappable
  #endif
  public func updatePushNotificationToken(_ token: Swift.String, completion: @escaping ZTCoreKit.ZTBaseResult)
  public func postData(path: Swift.String, parameters: [Swift.String : Any], completion: @escaping ZTCoreKit.ZTBaseResult)
  #if compiler(>=5.3) && $NonescapableTypes
  public func getDataArray(path: Swift.String, parameters: [Swift.String : Any]? = nil, completion: @escaping ([[Swift.String : Any]]?, (any Swift.Error)?) -> Swift.Void)
  #endif
  public func putData(path: Swift.String, parameters: [Swift.String : Any], completion: @escaping ZTCoreKit.ZTBaseResult)
  #if compiler(>=5.3) && $NonescapableTypes
  public func postDataGeneric(path: Swift.String, parameters: [Swift.String : Any], safe: Swift.Bool = true, completion: @escaping (Any?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func postDataGenericV2(path: Swift.String, parameters: [Swift.String : Any], completion: @escaping (Foundation.Data?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func postData(path: Swift.String, parameters: [Swift.String : Any], completion: @escaping ([Swift.String : Any]?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func deleteData(path: Swift.String, parameters: [Swift.String : Any]?, completion: @escaping ZTCoreKit.ZTBaseResult)
  #endif
  public func deleteUser(completion: @escaping ZTCoreKit.ZTBaseResult)
  #if compiler(>=5.3) && $NonescapableTypes
  public func existUser(attribute: Swift.String, value: Swift.String, completion: @escaping (_ error: ZTCoreKit.ZTError?, _ userId: Swift.String?) -> Swift.Void)
  #endif
  public func suborgExists(code: Swift.String, completion: @escaping (_ exist: Swift.Bool) -> Swift.Void)
  #if compiler(>=5.3) && $NonescapableTypes
  public func postWithBody(route: ZTCoreKit.ZTApiRoute, device: (any ZTCoreKit.ZTDeviceProtocol)?, dataArray: [[Swift.String : Any]], shouldSave: Swift.Bool = true, isPut: Swift.Bool = false, completion: @escaping ZTCoreKit.ZTBaseResult)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func patchData(route: ZTCoreKit.ZTApiRoute, parameters: [Swift.String : Any]?, completion: @escaping ZTCoreKit.ZTBaseResult)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func userScan(info: ZTCoreKit.ZTDeviceInfo, completion: ZTCoreKit.ZTBaseResult? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func complianceTestRetry(timeout: Swift.Int, attempts: Swift.Int, statusCode: Swift.Int, completion: @escaping (Foundation.Data?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func extractZCVersion(_ response: Foundation.HTTPURLResponse?)
  #endif
}
extension ZTCoreKit.ZTNetworkManager {
  public func userGetDFUKey(mac: Swift.String, publicKey: Swift.String) async throws -> ZTCoreKit.ZTDFUKeyResponse
  public func userGetDFUKey(mac: Swift.String, publicKey: Swift.String, completion: @escaping ZTCoreKit.ZTResultObject<ZTCoreKit.ZTDFUKeyResponse>)
}
public class ZTReachability {
  public var currentAdapterMode: ZTCoreKit.ZTReachability.Adapter
  public var currentConnectionStatus: ZTCoreKit.ZTReachability.Connection {
    get
    set
  }
  public typealias ZTConnectionReachable = (ZTCoreKit.ZTReachability) -> Swift.Void
  public typealias ZTConnectionUnReachable = (ZTCoreKit.ZTReachability) -> Swift.Void
  public var onConnectionReachable: ZTCoreKit.ZTReachability.ZTConnectionReachable?
  public var onConnectionUnReachable: ZTCoreKit.ZTReachability.ZTConnectionUnReachable?
  public var managerStarted: Swift.Bool
  public enum Adapter : Swift.CustomStringConvertible, Swift.Equatable {
    case all, wifi, cellular, wiredEthernet, loopback, other, none
    public var description: Swift.String {
      get
    }
    public func getInterfaceType() -> Network.NWInterface.InterfaceType
    public static func == (a: ZTCoreKit.ZTReachability.Adapter, b: ZTCoreKit.ZTReachability.Adapter) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Connection : Swift.CustomStringConvertible, Swift.Equatable {
    case online(adapter: ZTCoreKit.ZTReachability.Adapter), offline
    public var description: Swift.String {
      get
    }
    public static func == (lhs: ZTCoreKit.ZTReachability.Connection, rhs: ZTCoreKit.ZTReachability.Connection) -> Swift.Bool
  }
  public init(adapter: ZTCoreKit.ZTReachability.Adapter = .all)
  public func startManager()
  public func stopManager()
  @objc deinit
}
public enum ZTApiRoute : Swift.Equatable {
  case authenticate, refreshToken, userCreate, userAttributes, userRecover(attribute: Swift.String, value: Swift.String), userProfileImage, userProfile, userScan, userConnect, userCheckForFirmwareUpdate, userShoes, userShoe(code: Swift.String), userShoeAttributes(code: Swift.String), userExists(attribute: Swift.String, value: Swift.String), userNotificationToken, userSuborgExists(code: Swift.String), userData(dataModel: Swift.String), userDataID(dataModel: Swift.String, id: Swift.String), userDfuKey, activityStart, activityAddSegment, activityAddData, activityStop, activityAddChunk, activityDelete(id: Swift.String), activitiesSummary, activitySummary(id: Swift.String), activityAttributes(id: Swift.String), activityRealtimeData(id: Swift.String), addActivityComment(activityId: Swift.String), getActivityComments(activityId: Swift.String), activityComment(activityId: Swift.String, commentId: Swift.String), addActivityCommentMediaFile(activityId: Swift.String, commentId: Swift.String), deleteActivityCommentMediaFile(activityId: Swift.String, commentId: Swift.String, mediaFileId: Swift.String), mediaMediafileTemplate, achievements, checkAppVersion(version: Swift.String), firmwareUpdated, deleteUser, trackEvent, log, appAttributes, compliance(timeout: Swift.Int, attempts: Swift.Int, code: Swift.Int), sendDirectMessage, sendCannedMessage, directMessage(id: Swift.String), directMessages, sendIndirectMessage(identifier: Swift.String), tileMessage(name: Swift.String), mobilityMessage(name: Swift.String), custom(path: Swift.String)
  public var path: Swift.String {
    get
  }
  public static func == (a: ZTCoreKit.ZTApiRoute, b: ZTCoreKit.ZTApiRoute) -> Swift.Bool
}
public enum ZTBalistonRoute {
  case createActivity, sendDirectMessage, sendCannedMessage, directMessage(id: Swift.String), directMessages, sendIndirectMessage(identifier: Swift.String), tileMessage(name: Swift.String), mobilityMessage(name: Swift.String), myShoeData(code: Swift.String), activity(name: Swift.String), mobility(name: Swift.String), sendAnalyticsDataNow, sendAnalyticsDataQueued, swingAnalysis, endpoint(path: Swift.String, name: Swift.String)
  public var path: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ZTApi : ZTCoreKit.ZhortechEventsProtocol {
  public static let shared: ZTCoreKit.ZTApi
  final public let onSavedRequestSent: ZTCoreKit.ZTSignal<Swift.String?>
  final public let onActivityStopRequestSent: ZTCoreKit.ZTSignal<(any Swift.Error)?>
  final public let onSocketDataReceived: ZTCoreKit.ZTSignal<Foundation.Data?>
  final public let onSocketTextReceived: ZTCoreKit.ZTSignal<Swift.String?>
  #if compiler(>=5.3) && $NonescapableTypes
  final public var appAttributes: [Swift.String : Any]? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func linkUser(userId: Swift.String, device: (any ZTCoreKit.ZTDeviceProtocol)? = nil, attributes: [Swift.String : Any], completion: @escaping (Swift.String?, (any Swift.Error)?) -> Swift.Void)
  #endif
  final public func getUserShoes(completion: @escaping ZTCoreKit.ZTResultArray<ZTCoreKit.ZTUserShoe>)
  final public func getUserShoe(code: Swift.String, completion: @escaping ZTCoreKit.ZTResultObject<ZTCoreKit.ZTUserShoe>)
  final public func updateUserShoe(code: Swift.String, attributes: [Swift.String : Any], completion: @escaping ZTCoreKit.ZTResultObject<ZTCoreKit.ZTUserShoe>)
  final public func deleteUserShoe(code: Swift.String, completion: @escaping ZTCoreKit.ZTBaseResult)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func uploadProfileImage(_ image: Foundation.Data, completion: ZTCoreKit.ZTBaseResult? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func getUserProfile(completion: @escaping ([Swift.String : Any]?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func getActivities<T>(code: Swift.String?, start: Foundation.Date, end: Foundation.Date, fields: [Swift.String] = [], include: [Swift.String]? = nil, completion: (([T]?, (any Swift.Error)?) -> Swift.Void)? = nil) where T : ZTCoreKit.ZTMappable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func getActivities<T>(code: Swift.String?, offset: Swift.Int, limit: Swift.Int, fields: [Swift.String] = [], include: [Swift.String]? = nil, whereOptions: [Swift.String : Any]? = nil, duration: [Swift.String : Any]? = nil, start: Foundation.Date? = nil, end: Foundation.Date? = nil, completion: (([T]?, (any Swift.Error)?) -> Swift.Void)? = nil) where T : ZTCoreKit.ZTMappable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func getActivity<T>(id: Swift.String, fields: [Swift.String] = [], include: [Swift.String]? = nil, whereOptions: [Swift.String : Any]? = nil, duration: [Swift.String : Any]? = nil, start: Foundation.Date? = nil, end: Foundation.Date? = nil, completion: ((T?, (any Swift.Error)?) -> Swift.Void)? = nil) where T : ZTCoreKit.ZTMappable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func startActivity(id: Swift.String, code: Swift.String, startTime: Swift.Int64 = Date().timestamp, attributes: [Swift.String : Any]? = nil, completion: ((Swift.String?, (any Swift.Error)?) -> Swift.Void)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func addActivitySegments(device: (any ZTCoreKit.ZTDeviceProtocol)?, activityId: Swift.String, duration: Swift.Int16? = nil, segments: [ZTCoreKit.ZhorthechPacket]?, completion: ZTCoreKit.ZTBaseResult? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func addChunk(code: Swift.String, device: any ZTCoreKit.ZTDeviceProtocol, chunk: ZTCoreKit.ZhorthechPacket, attributes: [Swift.String : Any]? = nil, completion: ZTCoreKit.ZTBaseResult? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func addActivityChunks(code: Swift.String, device: any ZTCoreKit.ZTDeviceProtocol, chunks: [ZTCoreKit.ZhorthechPacket], attributes: [Swift.String : Any]? = nil, completion: ZTCoreKit.ZTBaseResult? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func addActivityChunks(code: Swift.String, device: (any ZTCoreKit.ZTDeviceProtocol)?, chunks: [ZTCoreKit.ZhorthechPacket], attributes: [Swift.String : Any]? = nil) async throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func deleteActivity(id: Swift.String, completion: ZTCoreKit.ZTBaseResult? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func stopActivity<T>(id: Swift.String, duration: Swift.Int? = nil, data: [Swift.String]?, activityManager: ZTCoreKit.ZhortechActivityActor, completion: ((T?, (any Swift.Error)?) -> Swift.Void)? = nil) where T : ZTCoreKit.ZTMappable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func stopActivity<T>(id: Swift.String, duration: Swift.Int? = nil, timestamp: Swift.Int64? = nil, segments: [ZTCoreKit.ZhorthechPacket]?, activityManager: ZTCoreKit.ZhortechActivityActor, completion: ((T?, (any Swift.Error)?) -> Swift.Void)? = nil) where T : ZTCoreKit.ZTMappable
  #endif
  final public func log(severity: ZTCoreKit.ZTLoggerSeverity = ZTLoggerSeverity.debug, component: ZTCoreKit.ZTLoggerComponent = ZTLoggerComponent.sdk, message: Swift.String)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func getData<T>(path: Swift.String, parameters: [Swift.String : Any]? = nil, completion: ((T?, (any Swift.Error)?) -> Swift.Void)? = nil) where T : ZTCoreKit.ZTMappable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func getData(path: Swift.String, parameters: [Swift.String : Any]? = nil, completion: @escaping ([Swift.String : Any]?, Foundation.Data?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func getData(path: Swift.String, parameters: [Swift.String : Any]? = nil, completion: @escaping ([[Swift.String : Any]]?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func getAppAttributes(completion: @escaping ([Swift.String : Any]?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func getDataArray(path: Swift.String, parameters: [Swift.String : Any]? = nil, completion: @escaping ([[Swift.String : Any]]?, (any Swift.Error)?) -> Swift.Void)
  #endif
  final public func postData(path: Swift.String, parameters: [Swift.String : Any], completion: @escaping ZTCoreKit.ZTBaseResult)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func postData<T>(path: Swift.String, parameters: [Swift.String : Any]? = nil, completion: @escaping ZTCoreKit.ZTResultObject<T>) where T : ZTCoreKit.ZTMappable
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func postDataGenericResult(path: Swift.String, parameters: [Swift.String : Any], completion: @escaping (Any?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func postDataV2DataResult(path: Swift.String, parameters: [Swift.String : Any], completion: @escaping (Foundation.Data?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func postDataResult(path: Swift.String, parameters: [Swift.String : Any], completion: @escaping ([Swift.String : Any]?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func postDataResultArray(path: Swift.String, parameters: [Swift.String : Any], completion: @escaping ([[Swift.String : Any]]?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func deleteData(path: Swift.String, parameters: [Swift.String : Any]? = nil, completion: @escaping ZTCoreKit.ZTBaseResult)
  #endif
  final public func addActivityData(activityId: Swift.String, timestamp: Foundation.TimeInterval, data: [Any], completion: @escaping ZTCoreKit.ZTBaseResult)
  final public func updateActivityAttributes(activityId: Swift.String, attributes: [Swift.String : Any], completion: @escaping ZTCoreKit.ZTBaseResult)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func updatePushNotificationToken(_ token: Swift.String, completion: ZTCoreKit.ZTBaseResult? = nil)
  #endif
  final public func deleteUser(completion: @escaping ZTCoreKit.ZTBaseResult)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func existUser(attribute: Swift.String, value: Swift.String, completion: @escaping (_ error: (any Swift.Error)?, _ exist: Swift.Bool?) -> Swift.Void)
  #endif
  final public func suborgExist(code: Swift.String, completion: @escaping (_ exist: Swift.Bool) -> Swift.Void)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func trackEvent(name: Swift.String, data: [Swift.String : Any]? = nil, timestamp: Swift.Int64? = nil, attributes: [Swift.String : Any]? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func addActivityComment(activityId: Swift.String, text: Swift.String, mediaFileTemplates: [ZTCoreKit.ZTMediaFileTemplate]?, completion: @escaping ZTCoreKit.ZTResultObject<ZTCoreKit.ZTActivityComment>)
  #endif
  final public func saveActivityComment(commentId: Swift.String, text: Swift.String, completion: @escaping ZTCoreKit.ZTBaseResult)
  final public func getActivityComments(activityId: Swift.String, completion: @escaping ZTCoreKit.ZTResultArray<ZTCoreKit.ZTActivityComment>)
  final public func getActivityComment(commentId: Swift.String, completion: @escaping ZTCoreKit.ZTResultObject<ZTCoreKit.ZTActivityComment>)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func getActivityRealtimeData(activityId: Swift.String, fields: [Swift.String], completion: @escaping ([Swift.String : Any]?, (any Swift.Error)?) -> Swift.Void)
  #endif
  final public func addMediaFileToActivityComment(commentId: Swift.String, mediaFileTemplate: ZTCoreKit.ZTMediaFileTemplate, completion: @escaping ZTCoreKit.ZTBaseResult)
  final public func deleteActivityComment(commentId: Swift.String, completion: @escaping ZTCoreKit.ZTBaseResult)
  final public func deleteMediaFile(mediaFileId: Swift.String, completion: @escaping ZTCoreKit.ZTBaseResult)
  final public func uploadActivityRawData(activityId: Swift.String, filePath: Foundation.URL, completion: @escaping ZTCoreKit.ZTBaseResult)
  final public func getAchievements(completion: @escaping ZTCoreKit.ZTResultArray<ZTCoreKit.ZTAchievement>)
  #if compiler(>=5.3) && $NonescapableTypes
  final public func complianceTestRetry(timeout: Swift.Int, attempts: Swift.Int, statusCode: Swift.Int, completion: @escaping (Foundation.Data?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public func startListenMessages(onMessageReceived: @escaping (Swift.String?) -> Swift.Void, onDataReceived: @escaping (Foundation.Data?) -> Swift.Void)
  #endif
  final public func stopListenMessages()
  #if compiler(>=5.3) && $NonescapableTypes
  final public func getLogFilesList(date: Foundation.Date? = nil) -> [Foundation.URL]?
  #endif
  final public func resendSavedRequests()
  @objc deinit
}
extension ZTCoreKit.ZTApi {
  final public func sendAppData(completion: @escaping ZTCoreKit.ZTBaseResult)
}
extension ZTCoreKit.ZTApi {
  #if compiler(>=5.3) && $NonescapableTypes
  final public func createActivity(start: Foundation.Date, end: Foundation.Date, shoesSerial: Swift.String? = nil, chunks: [ZTCoreKit.ZhorthechPacket]?) async throws -> ZTCoreKit.ZhortechActivitySummary?
  #endif
}
extension ZTCoreKit.ZTApi {
  #if compiler(>=5.3) && $NonescapableTypes
  final public func websocketDidDisconnect(error: (any Swift.Error)?)
  #endif
}
extension ZTCoreKit.ZTApiService {
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func get(at route: ZTCoreKit.ZTApiRoute, params: ZTCoreKit.ZTApiService.Parameters? = nil) async throws -> Foundation.Data
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func post(at route: ZTCoreKit.ZTApiRoute, params: ZTCoreKit.ZTApiService.Parameters? = nil) async throws -> Foundation.Data
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func put(at route: ZTCoreKit.ZTApiRoute, params: ZTCoreKit.ZTApiService.Parameters? = nil) async throws -> Foundation.Data
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func patch(at route: ZTCoreKit.ZTApiRoute, params: ZTCoreKit.ZTApiService.Parameters? = nil) async throws -> Foundation.Data
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func delete(at route: ZTCoreKit.ZTApiRoute, params: ZTCoreKit.ZTApiService.Parameters? = nil) async throws -> Foundation.Data
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func post(at path: Swift.String, params: ZTCoreKit.ZTApiService.Parameters? = nil, safe: Swift.Bool = true) async throws -> Foundation.Data
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func get(at path: Swift.String, params: ZTCoreKit.ZTApiService.Parameters? = nil) async throws -> Foundation.Data
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func put(at path: Swift.String, params: ZTCoreKit.ZTApiService.Parameters? = nil) async throws -> Foundation.Data
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func delete(at path: Swift.String, params: ZTCoreKit.ZTApiService.Parameters? = nil) async throws -> Foundation.Data
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @discardableResult
  public func postWithBody(at route: ZTCoreKit.ZTApiRoute, body: [[Swift.String : Any]], isPut: Swift.Bool = false) async throws -> Foundation.Data?
  #endif
}
extension ZTCoreKit.ZTDataManager {
  #if compiler(>=5.3) && $NonescapableTypes
  public static var dfuUrl: Foundation.URL? {
    get
  }
  #endif
  public static func saveDevice(device: ZTCoreKit.ZTSavedDevice)
}
@_hasMissingDesignatedInitializers public class ZTNetworking : @unchecked Swift.Sendable {
  public static var zcVersion: Swift.String
  public static var version: Swift.String
  #if compiler(>=5.3) && $NonescapableTypes
  public static var lastActivityId: Swift.String? {
    get
    set
  }
  #endif
  @objc deinit
}
@available(iOS 16.0, *)
public struct ZTCoreUserData : Swift.Identifiable, Swift.Codable, Swift.Sendable {
  public typealias ID = Swift.String
  public init(id: ZTCoreKit.ZTCoreUserData.ID, data: [Swift.String : Swift.String])
  public let id: ZTCoreKit.ZTCoreUserData.ID
  public let data: [Swift.String : Swift.String]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, *)
public struct ZTCoreServerUserData : Swift.Identifiable, Swift.Codable, Swift.Sendable {
  public let id: Swift.String
  public let data: [Swift.String : [Swift.String : Swift.String]]
  @available(iOS 16.0, *)
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension ZTCoreKit.ZTNetworkManager {
  public typealias Activity = ZTCoreKit.ZhortechActivity
  #if compiler(>=5.3) && $NonescapableTypes
  public func getMetadataFor(serial: Swift.String, metaDataTimestamp: Swift.UInt32) async throws -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(iOS 16.0, *)
  public func getActivityJSONMetadataFor(serial: Swift.String, metaDataTimestamp: Swift.UInt32) async throws -> Swift.String?
  #endif
  public func postActivityJSONMetadata(for serial: Swift.String, meta json: Swift.String, metaDataTimestamp: Swift.UInt32) async throws
}
@available(iOS 16.0, *)
extension ZTCoreKit.ZTNetworkManager {
  public typealias UserData = ZTCoreKit.ZTCoreUserData
  public func postUserData(model: Swift.String, objects: [ZTCoreKit.ZTNetworkManager.UserData]) async throws
  public func patchUserData(model: Swift.String, objectId: ZTCoreKit.ZTNetworkManager.UserData.ID, objects: [ZTCoreKit.ZTNetworkManager.UserData]) async throws
  public func deleteUserData(model: Swift.String, objectId: ZTCoreKit.ZTNetworkManager.UserData.ID) async throws
  public func getUserData(model: Swift.String, objectId: ZTCoreKit.ZTNetworkManager.UserData.ID, force: Swift.Bool = false) async throws -> [ZTCoreKit.ZTNetworkManager.UserData]
  #if compiler(>=5.3) && $NonescapableTypes
  public func getUserDataLatestID(model: Swift.String, force: Swift.Bool = false) async throws -> ZTCoreKit.ZTNetworkManager.UserData.ID?
  #endif
}
public typealias ZTActivityCoreDataClassSet = Foundation.NSSet
@_inheritsConvenienceInitializers @objc(ZTActivity) nonisolated public class ZTActivity : CoreData.NSManagedObject {
  #if compiler(>=5.3) && $NonescapableTypes
  @objc override nonisolated dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  #endif
  @objc deinit
}
public typealias ZTActivityCoreDataPropertiesSet = Foundation.NSSet
extension ZTCoreKit.ZTActivity {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<ZTCoreKit.ZTActivity>
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @NSManaged nonisolated dynamic public var activityIdentifier: Swift.String? {
    @objc get
    @objc set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @NSManaged nonisolated dynamic public var activityType: Swift.String? {
    @objc get
    @objc set
  }
  #endif
  @objc @NSManaged nonisolated dynamic public var anchorTimestamp: Swift.Int64 {
    @objc get
    @objc set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @NSManaged nonisolated dynamic public var appId: Swift.String? {
    @objc get
    @objc set
  }
  #endif
  @objc @NSManaged nonisolated dynamic public var chunkCount: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged nonisolated dynamic public var customActivityFirstChunkId: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged nonisolated dynamic public var customActivityStartTimestamp: Swift.Int64 {
    @objc get
    @objc set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @NSManaged nonisolated dynamic public var endDate: Foundation.Date? {
    @objc get
    @objc set
  }
  #endif
  @objc @NSManaged nonisolated dynamic public var endTimestamp: Swift.Int64 {
    @objc get
    @objc set
  }
  @objc @NSManaged nonisolated dynamic public var firstChunkId: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged nonisolated dynamic public var forceStop: Swift.Bool {
    @objc get
    @objc set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @NSManaged nonisolated dynamic public var fwVersion: Swift.String? {
    @objc get
    @objc set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @NSManaged nonisolated dynamic public var id: Swift.String? {
    @objc get
    @objc set
  }
  #endif
  @objc @NSManaged nonisolated dynamic public var invalid: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @NSManaged nonisolated dynamic public var isAutomatic: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @NSManaged nonisolated dynamic public var isInterrupted: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @NSManaged nonisolated dynamic public var isRawDataMode: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @NSManaged nonisolated dynamic public var lastChunkId: Swift.Int16 {
    @objc get
    @objc set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @NSManaged nonisolated dynamic public var metaDataRawValue: Foundation.Data? {
    @objc get
    @objc set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @NSManaged nonisolated dynamic public var shoesSerial: Swift.String? {
    @objc get
    @objc set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @NSManaged nonisolated dynamic public var startDate: Foundation.Date? {
    @objc get
    @objc set
  }
  #endif
  @objc @NSManaged nonisolated dynamic public var startTimestamp: Swift.Int64 {
    @objc get
    @objc set
  }
  @objc @NSManaged nonisolated dynamic public var status: Swift.Int16 {
    @objc get
    @objc set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @NSManaged nonisolated dynamic public var stopReasonRawValue: Foundation.Data? {
    @objc get
    @objc set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @NSManaged nonisolated dynamic public var tz: Swift.String? {
    @objc get
    @objc set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @NSManaged nonisolated dynamic public var packets: Foundation.NSSet? {
    @objc get
    @objc set
  }
  #endif
}
extension ZTCoreKit.ZTActivity {
  @objc(addPacketsObject:) @NSManaged nonisolated dynamic public func addToPackets(_ value: ZTCoreKit.ZTPacket)
  @objc(removePacketsObject:) @NSManaged nonisolated dynamic public func removeFromPackets(_ value: ZTCoreKit.ZTPacket)
  @objc(addPackets:) @NSManaged nonisolated dynamic public func addToPackets(_ values: Foundation.NSSet)
  @objc(removePackets:) @NSManaged nonisolated dynamic public func removeFromPackets(_ values: Foundation.NSSet)
}
extension ZTCoreKit.ZTActivity : Swift.Identifiable {
  public typealias ID = Swift.String?
}
public typealias ZTPacketCoreDataClassSet = Foundation.NSSet
@_inheritsConvenienceInitializers @objc(ZTPacket) nonisolated public class ZTPacket : CoreData.NSManagedObject {
  #if compiler(>=5.3) && $NonescapableTypes
  @objc override nonisolated dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  #endif
  @objc deinit
}
public typealias ZTPacketCoreDataPropertiesSet = Foundation.NSSet
extension ZTCoreKit.ZTPacket {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<ZTCoreKit.ZTPacket>
  @objc @NSManaged nonisolated dynamic public var activityTypeRawValue: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged nonisolated dynamic public var bmTimestampTypeRawValue: Swift.Int16 {
    @objc get
    @objc set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @NSManaged nonisolated dynamic public var createdAt: Foundation.Date? {
    @objc get
    @objc set
  }
  #endif
  @objc @NSManaged nonisolated dynamic public var duration: Swift.Int16 {
    @objc get
    @objc set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @NSManaged nonisolated dynamic public var fulfilledAt: Foundation.Date? {
    @objc get
    @objc set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @NSManaged nonisolated dynamic public var fwVersion: Swift.String? {
    @objc get
    @objc set
  }
  #endif
  @objc @NSManaged nonisolated dynamic public var id: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged nonisolated dynamic public var originalTimestamp: Swift.Int64 {
    @objc get
    @objc set
  }
  @objc @NSManaged nonisolated dynamic public var packetsNumber: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged nonisolated dynamic public var packetTypeRawValue: Swift.Int16 {
    @objc get
    @objc set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @NSManaged nonisolated dynamic public var rawData: Foundation.Data? {
    @objc get
    @objc set
  }
  #endif
  @objc @NSManaged nonisolated dynamic public var retryCount: Swift.Int16 {
    @objc get
    @objc set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @NSManaged nonisolated dynamic public var scheduledDeleted: Foundation.Date? {
    @objc get
    @objc set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @NSManaged nonisolated dynamic public var sentAt: Foundation.Date? {
    @objc get
    @objc set
  }
  #endif
  @objc @NSManaged nonisolated dynamic public var statusRawValue: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged nonisolated dynamic public var timestamp: Swift.Int64 {
    @objc get
    @objc set
  }
  @objc @NSManaged nonisolated dynamic public var timestampTypeRawValue: Swift.Int16 {
    @objc get
    @objc set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @objc @NSManaged nonisolated dynamic public var activity: ZTCoreKit.ZTActivity? {
    @objc get
    @objc set
  }
  #endif
}
extension ZTCoreKit.ZTPacket : Swift.Identifiable {
  public typealias ID = Swift.Int16
}
public typealias DatabaseFoundationFrameworkSet = Foundation.NSSet
public typealias DatabaseCoreDataFrameworkManagedObject = CoreData.NSManagedObject
extension ZTCoreKit.ZhortechActivity.ActualStates : Swift.Equatable {}
extension ZTCoreKit.ZhortechActivity.ActualStates : Swift.Hashable {}
extension ZTCoreKit.ZhortechActivity.ActualStates : Swift.RawRepresentable {}
extension ZTCoreKit.ZhortechActivity.StopReason : Swift.Equatable {}
extension ZTCoreKit.ZhortechActivity.StopReason : Swift.Hashable {}
extension ZTCoreKit.ZhortechActivity.StopReason : Swift.RawRepresentable {}
extension ZTCoreKit.ZhorthechPacket.Status : Swift.Hashable {}
extension ZTCoreKit.ZhorthechPacket.Status : Swift.RawRepresentable {}
extension ZTCoreKit.ZhorthechPacket.TimestampType : Swift.Equatable {}
extension ZTCoreKit.ZhorthechPacket.TimestampType : Swift.Hashable {}
extension ZTCoreKit.ZhorthechPacket.TimestampType : Swift.RawRepresentable {}
extension ZTCoreKit.ZhorthechPacket.BmTimestampType : Swift.Equatable {}
extension ZTCoreKit.ZhorthechPacket.BmTimestampType : Swift.Hashable {}
extension ZTCoreKit.ZhorthechPacket.BmTimestampType : Swift.RawRepresentable {}
extension ZTCoreKit.ZhorthechPacket.PacketType : Swift.Equatable {}
extension ZTCoreKit.ZhorthechPacket.PacketType : Swift.Hashable {}
extension ZTCoreKit.ZhorthechPacket.PacketType : Swift.RawRepresentable {}
extension ZTCoreKit.ZhorthechPacket.Mode : Swift.Equatable {}
extension ZTCoreKit.ZhorthechPacket.Mode : Swift.Hashable {}
extension ZTCoreKit.ZhorthechPacket.Mode : Swift.RawRepresentable {}
extension ZTCoreKit.ZTRealtimeMetric : Swift.Equatable {}
extension ZTCoreKit.ZTRealtimeMetric : Swift.Hashable {}
extension ZTCoreKit.ZTRealtimeMetric : Swift.RawRepresentable {}
extension ZTCoreKit.ZTRealtimeMessage.Side : Swift.Equatable {}
extension ZTCoreKit.ZTRealtimeMessage.Side : Swift.Hashable {}
extension ZTCoreKit.ZTRealtimeMessage.Side : Swift.RawRepresentable {}
extension ZTCoreKit.ZTPeripheralState : Swift.Equatable {}
extension ZTCoreKit.ZTPeripheralState : Swift.Hashable {}
extension ZTCoreKit.ZTPeripheralState : Swift.RawRepresentable {}
extension ZTCoreKit.ZhortechBaseException : Swift.Equatable {}
extension ZTCoreKit.ZhortechBaseException : Swift.Hashable {}
extension ZTCoreKit.ZTBaseError : Swift.Hashable {}
extension ZTCoreKit.ZTCommand : Swift.Equatable {}
extension ZTCoreKit.ZTCommand : Swift.Hashable {}
extension ZTCoreKit.ZTCommand : Swift.RawRepresentable {}
extension ZTCoreKit.BluetoothUnavailableReason : Swift.Equatable {}
extension ZTCoreKit.BluetoothUnavailableReason : Swift.Hashable {}
extension Foundation.Data.Zhortech : Swift.Equatable {}
extension Foundation.Data.Zhortech : Swift.Hashable {}
extension Foundation.Data.Zhortech : Swift.RawRepresentable {}
extension Foundation.Data.NofityCommandStatus : Swift.Equatable {}
extension Foundation.Data.NofityCommandStatus : Swift.Hashable {}
extension Foundation.Data.NofityCommandStatus : Swift.RawRepresentable {}
extension Foundation.Data.NofityCommandSide : Swift.Equatable {}
extension Foundation.Data.NofityCommandSide : Swift.Hashable {}
extension Foundation.Data.NofityCommandSide : Swift.RawRepresentable {}
extension ZTCoreKit.DfuUiStateStatus : Swift.Equatable {}
extension ZTCoreKit.DfuUiStateStatus : Swift.Hashable {}
extension ZTCoreKit.ZTActivityLastStopReason : Swift.Equatable {}
extension ZTCoreKit.ZTActivityLastStopReason : Swift.Hashable {}
extension ZTCoreKit.ZTActivityLastStopReason : Swift.RawRepresentable {}
extension ZTCoreKit.ZTMessageChunkSendStatus.Status : Swift.Equatable {}
extension ZTCoreKit.ZTMessageChunkSendStatus.Status : Swift.Hashable {}
extension ZTCoreKit.ZTMessageChunkSendStatus.Status : Swift.RawRepresentable {}
extension ZTCoreKit.ZTCommandStatus : Swift.Equatable {}
extension ZTCoreKit.ZTCommandStatus : Swift.Hashable {}
extension ZTCoreKit.ZTCommandStatus : Swift.RawRepresentable {}
extension ZTCoreKit.ZTDfuPackageType : Swift.Equatable {}
extension ZTCoreKit.ZTDfuPackageType : Swift.Hashable {}
extension ZTCoreKit.ZTDfuPackageType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTMessageBootloaderInfo.DfuState : Swift.Equatable {}
extension ZTCoreKit.ZTMessageBootloaderInfo.DfuState : Swift.Hashable {}
extension ZTCoreKit.ZTMessageBootloaderInfo.DfuState : Swift.RawRepresentable {}
extension ZTCoreKit.ZTMessageChunkData.Mode : Swift.Equatable {}
extension ZTCoreKit.ZTMessageChunkData.Mode : Swift.Hashable {}
extension ZTCoreKit.ZTMessageChunkData.Mode : Swift.RawRepresentable {}
extension ZTCoreKit.ZTNotifyData.GroupID : Swift.Equatable {}
extension ZTCoreKit.ZTNotifyData.GroupID : Swift.Hashable {}
extension ZTCoreKit.ZTNotifyData.GroupID : Swift.RawRepresentable {}
extension ZTCoreKit.ZTNotifyData.CommonMessageId : Swift.Equatable {}
extension ZTCoreKit.ZTNotifyData.CommonMessageId : Swift.Hashable {}
extension ZTCoreKit.ZTNotifyData.CommonMessageId : Swift.RawRepresentable {}
extension ZTCoreKit.ZTNotifyData.WarmMessageId : Swift.Equatable {}
extension ZTCoreKit.ZTNotifyData.WarmMessageId : Swift.Hashable {}
extension ZTCoreKit.ZTNotifyData.WarmMessageId : Swift.RawRepresentable {}
extension ZTCoreKit.ZTNotifyData.RunningMessageId : Swift.Equatable {}
extension ZTCoreKit.ZTNotifyData.RunningMessageId : Swift.Hashable {}
extension ZTCoreKit.ZTNotifyData.RunningMessageId : Swift.RawRepresentable {}
extension ZTCoreKit.ZTNotifyData.CyclingMessageId : Swift.Equatable {}
extension ZTCoreKit.ZTNotifyData.CyclingMessageId : Swift.Hashable {}
extension ZTCoreKit.ZTNotifyData.CyclingMessageId : Swift.RawRepresentable {}
extension ZTCoreKit.ZTNotifyData.SafetyMessageId : Swift.Equatable {}
extension ZTCoreKit.ZTNotifyData.SafetyMessageId : Swift.Hashable {}
extension ZTCoreKit.ZTNotifyData.SafetyMessageId : Swift.RawRepresentable {}
extension ZTCoreKit.ZTNotifyData.GenericMessageId : Swift.Equatable {}
extension ZTCoreKit.ZTNotifyData.GenericMessageId : Swift.Hashable {}
extension ZTCoreKit.ZTNotifyData.GenericMessageId : Swift.RawRepresentable {}
extension ZTCoreKit.ZTNotifyData.StandardizeMessageId : Swift.Equatable {}
extension ZTCoreKit.ZTNotifyData.StandardizeMessageId : Swift.Hashable {}
extension ZTCoreKit.ZTNotifyData.StandardizeMessageId : Swift.RawRepresentable {}
extension ZTCoreKit.ZTSamplingMode : Swift.Equatable {}
extension ZTCoreKit.ZTSamplingMode : Swift.Hashable {}
extension ZTCoreKit.ZTSamplingMode : Swift.RawRepresentable {}
extension ZTCoreKit.ZTActivityMode : Swift.Equatable {}
extension ZTCoreKit.ZTActivityMode : Swift.Hashable {}
extension ZTCoreKit.ZTActivityMode : Swift.RawRepresentable {}
extension ZTCoreKit.ZTTXPower : Swift.Equatable {}
extension ZTCoreKit.ZTTXPower : Swift.Hashable {}
extension ZTCoreKit.ZTTXPower : Swift.RawRepresentable {}
extension ZTCoreKit.ZTRealtimeMessage.Event.EventType : Swift.Equatable {}
extension ZTCoreKit.ZTRealtimeMessage.Event.EventType : Swift.Hashable {}
extension ZTCoreKit.ZTRealtimeMessage.Event.EventType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTRealtimeMessage.Event.MotionId : Swift.Equatable {}
extension ZTCoreKit.ZTRealtimeMessage.Event.MotionId : Swift.Hashable {}
extension ZTCoreKit.ZTRealtimeMessage.Event.MotionId : Swift.RawRepresentable {}
extension ZTCoreKit.ZTRealtimeMessage.Event.MotionIntensity : Swift.Equatable {}
extension ZTCoreKit.ZTRealtimeMessage.Event.MotionIntensity : Swift.Hashable {}
extension ZTCoreKit.ZTRealtimeMessage.Event.MotionIntensity : Swift.RawRepresentable {}
extension ZTCoreKit.ZTRealtimeMessageEventType : Swift.Equatable {}
extension ZTCoreKit.ZTRealtimeMessageEventType : Swift.Hashable {}
extension ZTCoreKit.ZTRealtimeMessageEventType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTRealtimeSide : Swift.Equatable {}
extension ZTCoreKit.ZTRealtimeSide : Swift.Hashable {}
extension ZTCoreKit.ZTRealtimeSide : Swift.RawRepresentable {}
extension ZTCoreKit.ZTActivityType : Swift.Equatable {}
extension ZTCoreKit.ZTActivityType : Swift.Hashable {}
extension ZTCoreKit.ZTActivityType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTAlgoAcknowledgmentStatus : Swift.Equatable {}
extension ZTCoreKit.ZTAlgoAcknowledgmentStatus : Swift.Hashable {}
extension ZTCoreKit.ZTAlgoAcknowledgmentStatus : Swift.RawRepresentable {}
extension ZTCoreKit.ZTAlgoCommand : Swift.Equatable {}
extension ZTCoreKit.ZTAlgoCommand : Swift.Hashable {}
extension ZTCoreKit.ZTAlgoCommand : Swift.RawRepresentable {}
extension ZTCoreKit.ZTAlgoMode : Swift.Equatable {}
extension ZTCoreKit.ZTAlgoMode : Swift.Hashable {}
extension ZTCoreKit.ZTAlgoMode : Swift.RawRepresentable {}
extension ZTCoreKit.ZTAlgoPrecisionMode : Swift.Equatable {}
extension ZTCoreKit.ZTAlgoPrecisionMode : Swift.Hashable {}
extension ZTCoreKit.ZTAlgoPrecisionMode : Swift.RawRepresentable {}
extension ZTCoreKit.ZTAlgoState : Swift.Equatable {}
extension ZTCoreKit.ZTAlgoState : Swift.Hashable {}
extension ZTCoreKit.ZTAlgoState : Swift.RawRepresentable {}
extension ZTCoreKit.ZTAlgoStatus : Swift.Equatable {}
extension ZTCoreKit.ZTAlgoStatus : Swift.Hashable {}
extension ZTCoreKit.ZTAlgoStatus : Swift.RawRepresentable {}
extension ZTCoreKit.ZTEnvironment : Swift.Equatable {}
extension ZTCoreKit.ZTEnvironment : Swift.Hashable {}
extension ZTCoreKit.FirmwareModule : Swift.Equatable {}
extension ZTCoreKit.FirmwareModule : Swift.Hashable {}
extension ZTCoreKit.FirmwareModule : Swift.RawRepresentable {}
extension ZTCoreKit.ZTModuleSide : Swift.Hashable {}
extension ZTCoreKit.ZTModuleSide : Swift.RawRepresentable {}
extension ZTCoreKit.DFUState : Swift.Equatable {}
extension ZTCoreKit.DFUState : Swift.Hashable {}
extension ZTCoreKit.DFUState : Swift.RawRepresentable {}
extension ZTCoreKit.ZTBleManagerState : Swift.Equatable {}
extension ZTCoreKit.ZTBleManagerState : Swift.Hashable {}
extension ZTCoreKit.ZTDeviceActualState : Swift.RawRepresentable {}
extension ZTCoreKit.ZTDFUState : Swift.Equatable {}
extension ZTCoreKit.ZTDFUState : Swift.Hashable {}
extension ZTCoreKit.ZTDFUState : Swift.RawRepresentable {}
extension ZTCoreKit.ZTError.Enums.ScanningError : Swift.Equatable {}
extension ZTCoreKit.ZTError.Enums.ScanningError : Swift.Hashable {}
extension ZTCoreKit.ZTError.Enums.BleError : Swift.Equatable {}
extension ZTCoreKit.ZTError.Enums.BleError : Swift.Hashable {}
extension ZTCoreKit.ZTError.Enums.FirmwareError : Swift.Equatable {}
extension ZTCoreKit.ZTError.Enums.FirmwareError : Swift.Hashable {}
extension ZTCoreKit.ZTError.Enums.DfuError : Swift.Equatable {}
extension ZTCoreKit.ZTError.Enums.DfuError : Swift.Hashable {}
extension ZTCoreKit.ZTError.Enums.ActivityError : Swift.Equatable {}
extension ZTCoreKit.ZTError.Enums.ActivityError : Swift.Hashable {}
extension ZTCoreKit.ZTError.Enums.DecodableError : Swift.Equatable {}
extension ZTCoreKit.ZTError.Enums.DecodableError : Swift.Hashable {}
extension ZTCoreKit.ZTEventLoggerName : Swift.Equatable {}
extension ZTCoreKit.ZTEventLoggerName : Swift.Hashable {}
extension ZTCoreKit.ZTEventLoggerName : Swift.RawRepresentable {}
extension ZTCoreKit.ZTLoggerComponent : Swift.Equatable {}
extension ZTCoreKit.ZTLoggerComponent : Swift.Hashable {}
extension ZTCoreKit.ZTLoggerComponent : Swift.RawRepresentable {}
extension ZTCoreKit.ZTLoggerSeverity : Swift.Equatable {}
extension ZTCoreKit.ZTLoggerSeverity : Swift.Hashable {}
extension ZTCoreKit.ZTLoggerSeverity : Swift.RawRepresentable {}
extension ZTCoreKit.ZTMobilityScanState : Swift.Equatable {}
extension ZTCoreKit.ZTMobilityScanState : Swift.Hashable {}
extension ZTCoreKit.ZTUserDataParameters.Gender : Swift.Equatable {}
extension ZTCoreKit.ZTUserDataParameters.Gender : Swift.Hashable {}
extension ZTCoreKit.ZTUserDataParameters.Gender : Swift.RawRepresentable {}
extension ZTCoreKit.ZTUserDataParameters.Parameters : Swift.Equatable {}
extension ZTCoreKit.ZTUserDataParameters.Parameters : Swift.Hashable {}
extension ZTCoreKit.ZTUserDataParameters.Parameters : Swift.RawRepresentable {}
extension ZTCoreKit.ZTActivitySummaryStatus : Swift.Equatable {}
extension ZTCoreKit.ZTActivitySummaryStatus : Swift.Hashable {}
extension ZTCoreKit.ZTActivitySummaryStatus : Swift.RawRepresentable {}
extension ZTCoreKit.ZTProductType : Swift.Equatable {}
extension ZTCoreKit.ZTProductType : Swift.Hashable {}
extension ZTCoreKit.ZTProductType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTProjectCodeType : Swift.Equatable {}
extension ZTCoreKit.ZTProjectCodeType : Swift.Hashable {}
extension ZTCoreKit.ZTProjectCodeType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTProductCodeType : Swift.Equatable {}
extension ZTCoreKit.ZTProductCodeType : Swift.Hashable {}
extension ZTCoreKit.ZTProductCodeType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTManufacturerCodeType : Swift.Equatable {}
extension ZTCoreKit.ZTManufacturerCodeType : Swift.Hashable {}
extension ZTCoreKit.ZTManufacturerCodeType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTProductTypeCode : Swift.Equatable {}
extension ZTCoreKit.ZTProductTypeCode : Swift.Hashable {}
extension ZTCoreKit.ZTProductTypeCode : Swift.RawRepresentable {}
extension ZTCoreKit.ZTGenderCodeType : Swift.Equatable {}
extension ZTCoreKit.ZTGenderCodeType : Swift.Hashable {}
extension ZTCoreKit.ZTGenderCodeType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTGenderSizeCodeType : Swift.Equatable {}
extension ZTCoreKit.ZTGenderSizeCodeType : Swift.Hashable {}
extension ZTCoreKit.ZTGenderSizeCodeType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTUnitSizeCodeType : Swift.Equatable {}
extension ZTCoreKit.ZTUnitSizeCodeType : Swift.Hashable {}
extension ZTCoreKit.ZTUnitSizeCodeType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTPeriod : Swift.Equatable {}
extension ZTCoreKit.ZTPeriod : Swift.Hashable {}
extension ZTCoreKit.ZTPeriod : Swift.RawRepresentable {}
extension ZTCoreKit.ZTPairingType : Swift.Equatable {}
extension ZTCoreKit.ZTPairingType : Swift.Hashable {}
extension ZTCoreKit.ZTPairingType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTUnitType : Swift.Equatable {}
extension ZTCoreKit.ZTUnitType : Swift.Hashable {}
extension ZTCoreKit.ZTUnitType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTRawDataFlowStates : Swift.Equatable {}
extension ZTCoreKit.ZTRawDataFlowStates : Swift.Hashable {}
extension ZTCoreKit.ZTRawDataFlowStates : Swift.RawRepresentable {}
extension ZTCoreKit.ZTDateDefaultTransform.Unit : Swift.Equatable {}
extension ZTCoreKit.ZTDateDefaultTransform.Unit : Swift.Hashable {}
extension ZTCoreKit.ZTDateDefaultTransform.Unit : Swift.RawRepresentable {}
extension ZTCoreKit.ZTMappingType : Swift.Equatable {}
extension ZTCoreKit.ZTMappingType : Swift.Hashable {}
extension ZTCoreKit.ZTLogCategory : Swift.Equatable {}
extension ZTCoreKit.ZTLogCategory : Swift.Hashable {}
extension ZTCoreKit.ZTLogCategory : Swift.RawRepresentable {}
extension ZTCoreKit.ZTLogLevel : Swift.Equatable {}
extension ZTCoreKit.ZTLogLevel : Swift.Hashable {}
extension ZTCoreKit.ZTLogLevel : Swift.RawRepresentable {}
extension ZTCoreKit.ZTReachability.Adapter : Swift.Hashable {}
