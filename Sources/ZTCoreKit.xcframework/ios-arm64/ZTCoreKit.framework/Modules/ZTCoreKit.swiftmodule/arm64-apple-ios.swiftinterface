// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1.2 effective-5.10 (swiftlang-6.1.2.1.2 clang-1700.0.13.5)
// swift-module-flags: -target arm64-apple-ios15.6 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name ZTCoreKit
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -interface-compiler-version 6.1.2
import CoreBluetooth
import CoreData
import CoreTelephony
import Dispatch
import Foundation
import Network
import OSLog
import ObjectiveC
import Swift
import SystemConfiguration
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os.log
import os
@_hasMissingDesignatedInitializers public class ZTDeviceInfo {
  public var project: ZTCoreKit.ZTProjectCodeType? {
    get
  }
  public var productCode: ZTCoreKit.ZTProductCodeType? {
    get
  }
  public var manufacturer: ZTCoreKit.ZTManufacturerCodeType? {
    get
  }
  public var productType: ZTCoreKit.ZTProductTypeCode? {
    get
  }
  public var hardwareVersion: Swift.Int8? {
    get
  }
  public var boardVersion: Swift.Int8? {
    get
  }
  public var testeur: Swift.String? {
    get
  }
  public var sizeRaw: Swift.String? {
    get
  }
  public var year: Swift.Int? {
    get
  }
  public var week: Swift.Int? {
    get
  }
  public var SN: Swift.String? {
    get
  }
  public var serialNumber: Swift.String
  public var deviceIdentifier: Swift.String
  public var macAddressRight: Swift.String? {
    get
  }
  public var macAddressLeft: Swift.String? {
    get
  }
  public var code: Swift.String? {
    get
  }
  @objc deinit
}
extension ZTCoreKit.ZTDeviceInfo {
  public var size: Swift.Int? {
    get
  }
  public var gender: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers public class ZTDefaults {
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ZTDefaultsKey<T> : ZTCoreKit.ZTDefaults {
  final public let stringValue: Swift.String
  public init(_ value: Swift.String)
  @objc deinit
}
@_hasMissingDesignatedInitializers public actor ZhortechEvent {
  public static func setEventTracker(_ tracker: any ZTCoreKit.ZhortechEventsProtocol)
  @objc deinit
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  @_semantics("defaultActor") nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
public protocol ZhortechEventsProtocol {
  func trackEvent(name: Swift.String, data: [Swift.String : Any]?, timestamp: Swift.Int64?, attributes: [Swift.String : Any]?)
}
public struct ZTMessageChunkSendStatus : Swift.CustomStringConvertible {
  public enum Status : Swift.UInt8 {
    case success
    case errorOutOfRange
    case errorSendFailed
    case errorUnexpected
    case errorNotFound
    case unknown
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public let bytes: [Swift.UInt8]
  public var status: ZTCoreKit.ZTMessageChunkSendStatus.Status?
  public var chunkId: Swift.UInt16?
  public init(bytes: [Swift.UInt8])
  public var description: Swift.String {
    get
  }
}
extension ZTCoreKit.ZTCore {
  final public func improvedConnectivity(_ value: Swift.Bool, for timeInterval: Foundation.TimeInterval = 0)
}
extension ZTCoreKit.ZTCore {
  final public func setTxPower(value: ZTCoreKit.ZTTXPower, completion: @escaping (ZTCoreKit.ZTError?) -> Swift.Void)
}
@available(iOS 16.0, *)
extension ZTCoreKit.ZTCore {
  final public func setTxPower(value: ZTCoreKit.ZTTXPower) async throws
  final public func setPHYLongRange(active: Swift.Bool = true) async throws
  final public func setAgressiveConnInterval(active: Swift.Bool = true) async throws
  final public func schedule(delay: Foundation.TimeInterval, cancelOnSleeep: Swift.Bool = false, commands: [Swift.UInt8]) async throws
  final public func clearSchedule() async throws
}
public class ZTActivityComment : ZTCoreKit.ZTMappable {
  public var id: Swift.String?
  public var timeZone: Swift.String?
  public var timestamp: Foundation.Date?
  public var text: Swift.String?
  public var activityId: Swift.String?
  public var createdAt: Foundation.Date?
  public var updatedAt: Foundation.Date?
  public var mediaFiles: [ZTCoreKit.ZTMediaFile]?
  required public init?(map: ZTCoreKit.ZTMap)
  public func mapping(map: ZTCoreKit.ZTMap)
  @objc deinit
}
public protocol ZTEnum : Swift.Decodable, Swift.Encodable {
  var description: Swift.String { get }
}
extension ZTCoreKit.ZTEnum {
  public var description: Swift.String {
    get
  }
}
public enum ZTAlgoPrecisionMode : Swift.UInt8, ZTCoreKit.ZTEnum {
  case defaultMode
  case economicMode
  case performanceMode
  public var parameters: [Swift.UInt8] {
    get
  }
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public func <<- <Transform>(left: inout Transform.Object, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
public func ->> <Transform>(left: Transform.Object, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
public func <<- <Transform>(left: inout Transform.Object?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
public func ->> <Transform>(left: Transform.Object?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
public func <<- <Transform>(left: inout [Transform.Object], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
public func ->> <Transform>(left: [Transform.Object], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
public func <<- <Transform>(left: inout [Transform.Object]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
public func ->> <Transform>(left: [Transform.Object]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
public func <<- <Transform>(left: inout [Swift.String : Transform.Object], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
public func ->> <Transform>(left: [Swift.String : Transform.Object], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
public func <<- <Transform>(left: inout [Swift.String : Transform.Object]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
public func ->> <Transform>(left: [Swift.String : Transform.Object]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
public func <<- <Transform>(left: inout Transform.Object, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
public func ->> <Transform>(left: Transform.Object, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
public func <<- <Transform>(left: inout Transform.Object?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
public func ->> <Transform>(left: Transform.Object?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
public func <<- <Transform>(left: inout [Swift.String : Transform.Object], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
public func ->> <Transform>(left: [Swift.String : Transform.Object], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
public func <<- <Transform>(left: inout [Swift.String : Transform.Object]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
public func ->> <Transform>(left: [Swift.String : Transform.Object]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
public func <<- <Transform>(left: inout [Swift.String : [Transform.Object]], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
public func ->> <Transform>(left: [Swift.String : [Transform.Object]], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
public func <<- <Transform>(left: inout [Swift.String : [Transform.Object]]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
public func ->> <Transform>(left: [Swift.String : [Transform.Object]]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
public func <<- <Transform>(left: inout [Transform.Object], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
public func ->> <Transform>(left: [Transform.Object], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
public func <<- <Transform>(left: inout [Transform.Object]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
public func ->> <Transform>(left: [Transform.Object]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : ZTCoreKit.ZTBaseMappable
public func <<- <Transform>(left: inout [[Transform.Object]], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
public func ->> <Transform>(left: [[Transform.Object]], right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
public func <<- <Transform>(left: inout [[Transform.Object]]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
public func ->> <Transform>(left: [[Transform.Object]]?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType
public func <<- <Transform>(left: inout Swift.Set<Transform.Object>, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : Swift.Hashable, Transform.Object : ZTCoreKit.ZTBaseMappable
public func ->> <Transform>(left: Swift.Set<Transform.Object>, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : Swift.Hashable, Transform.Object : ZTCoreKit.ZTBaseMappable
public func <<- <Transform>(left: inout Swift.Set<Transform.Object>?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : Swift.Hashable, Transform.Object : ZTCoreKit.ZTBaseMappable
public func ->> <Transform>(left: Swift.Set<Transform.Object>?, right: (ZTCoreKit.ZTMap, Transform)) where Transform : ZTCoreKit.ZTTransformType, Transform.Object : Swift.Hashable, Transform.Object : ZTCoreKit.ZTBaseMappable
public enum ZTAlgoAcknowledgmentStatus : Swift.UInt8, ZTCoreKit.ZTEnum {
  case success
  case busy
  case invalidParam
  case invalidState
  case fwResForbidden
  case notSupported
  case unknownCommand
  case commandInProgress
  case noPeerResponse
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
infix operator <<- : DefaultPrecedence
infix operator ->> : DefaultPrecedence
public func <<- <T>(left: inout T, right: ZTCoreKit.ZTMap)
public func ->> <T>(left: T, right: ZTCoreKit.ZTMap)
public func <<- <T>(left: inout T?, right: ZTCoreKit.ZTMap)
public func ->> <T>(left: T?, right: ZTCoreKit.ZTMap)
public func <<- <T>(left: inout T, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func ->> <T>(left: T, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func <<- <T>(left: inout T?, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func ->> <T>(left: T?, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func <<- <T>(left: inout [Swift.String : T], right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func ->> <T>(left: [Swift.String : T], right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func <<- <T>(left: inout [Swift.String : T]?, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func ->> <T>(left: [Swift.String : T]?, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func <<- <T>(left: inout [Swift.String : [T]], right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func ->> <T>(left: [Swift.String : [T]], right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func <<- <T>(left: inout [Swift.String : [T]]?, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func ->> <T>(left: [Swift.String : [T]]?, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func <<- <T>(left: inout [T], right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func ->> <T>(left: [T], right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func <<- <T>(left: inout [T]?, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func ->> <T>(left: [T]?, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func <<- <T>(left: inout [[T]], right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func ->> <T>(left: [[T]], right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func <<- <T>(left: inout [[T]]?, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func ->> <T>(left: [[T]]?, right: ZTCoreKit.ZTMap) where T : ZTCoreKit.ZTBaseMappable
public func <<- <T>(left: inout Swift.Set<T>, right: ZTCoreKit.ZTMap) where T : Swift.Hashable, T : ZTCoreKit.ZTBaseMappable
public func ->> <T>(left: Swift.Set<T>, right: ZTCoreKit.ZTMap) where T : Swift.Hashable, T : ZTCoreKit.ZTBaseMappable
public func <<- <T>(left: inout Swift.Set<T>?, right: ZTCoreKit.ZTMap) where T : Swift.Hashable, T : ZTCoreKit.ZTBaseMappable
public func ->> <T>(left: Swift.Set<T>?, right: ZTCoreKit.ZTMap) where T : Swift.Hashable, T : ZTCoreKit.ZTBaseMappable
public enum ZTRealtimeSide : Swift.UInt8 {
  case none
  case left
  case right
  case both
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ZTApi : ZTCoreKit.ZhortechEventsProtocol {
  public static let shared: ZTCoreKit.ZTApi
  final public let onSavedRequestSent: ZTCoreKit.ZTSignal<Swift.String?>
  final public let onActivityStopRequestSent: ZTCoreKit.ZTSignal<(any Swift.Error)?>
  final public let onSocketDataReceived: ZTCoreKit.ZTSignal<Foundation.Data?>
  final public let onSocketTextReceived: ZTCoreKit.ZTSignal<Swift.String?>
  final public var appAttributes: [Swift.String : Any]? {
    get
  }
  final public func linkUser(userId: Swift.String, attributes: [Swift.String : Any], completion: @escaping (Swift.String?, (any Swift.Error)?) -> Swift.Void)
  final public func getUserShoes(completion: @escaping ZTCoreKit.ZTResultArray<ZTCoreKit.ZTUserShoe>)
  final public func getUserShoe(code: Swift.String, completion: @escaping ZTCoreKit.ZTResultObject<ZTCoreKit.ZTUserShoe>)
  final public func updateUserShoe(code: Swift.String, attributes: [Swift.String : Any], completion: @escaping ZTCoreKit.ZTResultObject<ZTCoreKit.ZTUserShoe>)
  final public func deleteUserShoe(code: Swift.String, completion: @escaping ZTCoreKit.ZTBaseResult)
  final public func uploadProfileImage(_ image: Foundation.Data, completion: ZTCoreKit.ZTBaseResult? = nil)
  final public func getUserProfile(completion: @escaping ([Swift.String : Any]?, (any Swift.Error)?) -> Swift.Void)
  final public func getActivities<T>(code: Swift.String?, start: Foundation.Date, end: Foundation.Date, fields: [Swift.String] = [], include: [Swift.String]? = nil, completion: (([T]?, (any Swift.Error)?) -> Swift.Void)? = nil) where T : ZTCoreKit.ZTMappable
  final public func getActivities<T>(code: Swift.String?, offset: Swift.Int, limit: Swift.Int, fields: [Swift.String] = [], include: [Swift.String]? = nil, whereOptions: [Swift.String : Any]? = nil, duration: [Swift.String : Any]? = nil, start: Foundation.Date? = nil, end: Foundation.Date? = nil, completion: (([T]?, (any Swift.Error)?) -> Swift.Void)? = nil) where T : ZTCoreKit.ZTMappable
  final public func getActivity<T>(id: Swift.String, fields: [Swift.String] = [], include: [Swift.String]? = nil, whereOptions: [Swift.String : Any]? = nil, duration: [Swift.String : Any]? = nil, start: Foundation.Date? = nil, end: Foundation.Date? = nil, completion: ((T?, (any Swift.Error)?) -> Swift.Void)? = nil) where T : ZTCoreKit.ZTMappable
  final public func startActivity(id: Swift.String, code: Swift.String, startTime: Swift.Int64 = Date().timestamp, attributes: [Swift.String : Any]? = nil, completion: ((Swift.String?, (any Swift.Error)?) -> Swift.Void)?)
  final public func addActivitySegments(activityId: Swift.String, duration: Swift.Int16? = nil, segments: [ZTCoreKit.ZhorthechPacket]?, completion: ZTCoreKit.ZTBaseResult? = nil)
  final public func addChunk(code: Swift.String, chunk: ZTCoreKit.ZhorthechPacket, attributes: [Swift.String : Any]? = nil, completion: ZTCoreKit.ZTBaseResult? = nil)
  final public func addActivityChunks(code: Swift.String, chunks: [ZTCoreKit.ZhorthechPacket], attributes: [Swift.String : Any]? = nil, completion: ZTCoreKit.ZTBaseResult? = nil)
  final public func addActivityChunks(code: Swift.String, chunks: [ZTCoreKit.ZhorthechPacket], attributes: [Swift.String : Any]? = nil) async throws
  final public func deleteActivity(id: Swift.String, completion: ZTCoreKit.ZTBaseResult? = nil)
  final public func stopActivity<T>(id: Swift.String, duration: Swift.Int? = nil, data: [Swift.String]?, completion: ((T?, (any Swift.Error)?) -> Swift.Void)? = nil) where T : ZTCoreKit.ZTMappable
  final public func stopActivity<T>(id: Swift.String, duration: Swift.Int? = nil, timestamp: Swift.Int64? = nil, segments: [ZTCoreKit.ZhorthechPacket]?, completion: ((T?, (any Swift.Error)?) -> Swift.Void)? = nil) where T : ZTCoreKit.ZTMappable
  final public func getData<T>(path: Swift.String, parameters: [Swift.String : Any]? = nil, completion: ((T?, (any Swift.Error)?) -> Swift.Void)? = nil) where T : ZTCoreKit.ZTMappable
  final public func getData(path: Swift.String, parameters: [Swift.String : Any]? = nil, completion: @escaping ([Swift.String : Any]?, Foundation.Data?, (any Swift.Error)?) -> Swift.Void)
  final public func getData(path: Swift.String, parameters: [Swift.String : Any]? = nil, completion: @escaping ([[Swift.String : Any]]?, (any Swift.Error)?) -> Swift.Void)
  final public func getAppAttributes(completion: @escaping ([Swift.String : Any]?, (any Swift.Error)?) -> Swift.Void)
  final public func checkFirmwareUpdate(completion: @escaping (_ updatable: Swift.Bool, _ error: (any Swift.Error)?) -> Swift.Void)
  final public func checkFirmwareUpdate(completion: @escaping (_ updatable: Swift.Bool, _ version: Swift.String?, _ error: (any Swift.Error)?) -> Swift.Void)
  final public func getDataArray(path: Swift.String, parameters: [Swift.String : Any]? = nil, completion: @escaping ([[Swift.String : Any]]?, (any Swift.Error)?) -> Swift.Void)
  final public func postData(path: Swift.String, parameters: [Swift.String : Any], completion: @escaping ZTCoreKit.ZTBaseResult)
  final public func postData<T>(path: Swift.String, parameters: [Swift.String : Any]? = nil, completion: @escaping ZTCoreKit.ZTResultObject<T>) where T : ZTCoreKit.ZTMappable
  final public func postDataGenericResult(path: Swift.String, parameters: [Swift.String : Any], completion: @escaping (Any?, (any Swift.Error)?) -> Swift.Void)
  final public func postDataV2DataResult(path: Swift.String, parameters: [Swift.String : Any], completion: @escaping (Foundation.Data?, (any Swift.Error)?) -> Swift.Void)
  final public func postDataResult(path: Swift.String, parameters: [Swift.String : Any], completion: @escaping ([Swift.String : Any]?, (any Swift.Error)?) -> Swift.Void)
  final public func postDataResultArray(path: Swift.String, parameters: [Swift.String : Any], completion: @escaping ([[Swift.String : Any]]?, (any Swift.Error)?) -> Swift.Void)
  final public func deleteData(path: Swift.String, parameters: [Swift.String : Any]? = nil, completion: @escaping ZTCoreKit.ZTBaseResult)
  final public func addActivityData(activityId: Swift.String, timestamp: Foundation.TimeInterval, data: [Any], completion: @escaping ZTCoreKit.ZTBaseResult)
  final public func updateActivityAttributes(activityId: Swift.String, attributes: [Swift.String : Any], completion: @escaping ZTCoreKit.ZTBaseResult)
  final public func updatePushNotificationToken(_ token: Swift.String, completion: ZTCoreKit.ZTBaseResult? = nil)
  final public func deleteUser(completion: @escaping ZTCoreKit.ZTBaseResult)
  final public func existUser(attribute: Swift.String, value: Swift.String, completion: @escaping (_ error: (any Swift.Error)?, _ exist: Swift.Bool?) -> Swift.Void)
  final public func suborgExist(code: Swift.String, completion: @escaping (_ exist: Swift.Bool) -> Swift.Void)
  final public func trackEvent(name: Swift.String, data: [Swift.String : Any]? = nil, timestamp: Swift.Int64? = nil, attributes: [Swift.String : Any]? = nil)
  final public func log(severity: ZTCoreKit.ZTLoggerSeverity = ZTLoggerSeverity.debug, component: ZTCoreKit.ZTLoggerComponent = ZTLoggerComponent.sdk, message: Swift.String)
  final public func addActivityComment(activityId: Swift.String, text: Swift.String, mediaFileTemplates: [ZTCoreKit.ZTMediaFileTemplate]?, completion: @escaping ZTCoreKit.ZTResultObject<ZTCoreKit.ZTActivityComment>)
  final public func saveActivityComment(commentId: Swift.String, text: Swift.String, completion: @escaping ZTCoreKit.ZTBaseResult)
  final public func getActivityComments(activityId: Swift.String, completion: @escaping ZTCoreKit.ZTResultArray<ZTCoreKit.ZTActivityComment>)
  final public func getActivityComment(commentId: Swift.String, completion: @escaping ZTCoreKit.ZTResultObject<ZTCoreKit.ZTActivityComment>)
  final public func getActivityRealtimeData(activityId: Swift.String, fields: [Swift.String], completion: @escaping ([Swift.String : Any]?, (any Swift.Error)?) -> Swift.Void)
  final public func addMediaFileToActivityComment(commentId: Swift.String, mediaFileTemplate: ZTCoreKit.ZTMediaFileTemplate, completion: @escaping ZTCoreKit.ZTBaseResult)
  final public func deleteActivityComment(commentId: Swift.String, completion: @escaping ZTCoreKit.ZTBaseResult)
  final public func deleteMediaFile(mediaFileId: Swift.String, completion: @escaping ZTCoreKit.ZTBaseResult)
  final public func uploadActivityRawData(activityId: Swift.String, filePath: Foundation.URL, completion: @escaping ZTCoreKit.ZTBaseResult)
  final public func getAchievements(completion: @escaping ZTCoreKit.ZTResultArray<ZTCoreKit.ZTAchievement>)
  final public func complianceTestRetry(timeout: Swift.Int, attempts: Swift.Int, statusCode: Swift.Int, completion: @escaping (Foundation.Data?, (any Swift.Error)?) -> Swift.Void)
  final public func startListenMessages(onMessageReceived: @escaping (Swift.String?) -> Swift.Void, onDataReceived: @escaping (Foundation.Data?) -> Swift.Void)
  final public func stopListenMessages()
  final public func getLogFilesList(date: Foundation.Date? = nil) -> [Foundation.URL]?
  final public func resendSavedRequests()
  @objc deinit
}
extension ZTCoreKit.ZTRealtimeMessage.Event {
  public enum EventType : Swift.UInt8, ZTCoreKit.ZTEnum {
    case motion
    case transition
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum MotionId : Swift.UInt8, ZTCoreKit.ZTEnum {
    case undefined
    case stepForward
    case stepBackward
    case stepSideLeft
    case stepSideRight
    case stepUp
    case stepDown
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum MotionIntensity : Swift.UInt8, ZTCoreKit.ZTEnum {
    case undefined
    case low
    case medium
    case high
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
public struct ZTMapError : Swift.Error {
  public var key: Swift.String?
  public var currentValue: Any?
  public var reason: Swift.String?
  public var file: Swift.StaticString?
  public var function: Swift.StaticString?
  public var line: Swift.UInt?
  public init(key: Swift.String?, currentValue: Any?, reason: Swift.String?, file: Swift.StaticString? = nil, function: Swift.StaticString? = nil, line: Swift.UInt? = nil)
}
extension ZTCoreKit.ZTMapError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension ZTCoreKit.ZTRealtimeMessage {
  public struct Event : Swift.CustomStringConvertible {
    public var timestamp: Swift.UInt32? {
      get
    }
    public var eventType: ZTCoreKit.ZTRealtimeMessage.Event.EventType? {
      get
    }
    public var motionId: ZTCoreKit.ZTRealtimeMessage.Event.MotionId? {
      get
    }
    public var intensity: ZTCoreKit.ZTRealtimeMessage.Event.MotionIntensity? {
      get
    }
    public var arguments: [Swift.UInt8]? {
      get
    }
    public var description: Swift.String {
      get
    }
    public init(data: Foundation.Data)
  }
}
extension Foundation.Data {
  public var hexString: Swift.String {
    get
  }
}
public protocol DataConvertible {
  static func + (lhs: Foundation.Data, rhs: Self) -> Foundation.Data
  static func += (lhs: inout Foundation.Data, rhs: Self)
}
extension ZTCoreKit.DataConvertible {
  public static func + (lhs: Foundation.Data, rhs: Self) -> Foundation.Data
  public static func += (lhs: inout Foundation.Data, rhs: Self)
}
extension Swift.UInt8 : ZTCoreKit.DataConvertible {
}
extension Swift.UInt16 : ZTCoreKit.DataConvertible {
}
extension Swift.UInt32 : ZTCoreKit.DataConvertible {
}
extension Swift.Int : ZTCoreKit.DataConvertible {
}
extension Swift.Float : ZTCoreKit.DataConvertible {
}
extension Swift.Double : ZTCoreKit.DataConvertible {
}
extension Swift.String : ZTCoreKit.DataConvertible {
  public static func + (lhs: Foundation.Data, rhs: Swift.String) -> Foundation.Data
}
extension Foundation.Data : ZTCoreKit.DataConvertible {
  public static func + (lhs: Foundation.Data, rhs: Foundation.Data) -> Foundation.Data
}
public protocol ZTCBPeripheralManagerProtocol : AnyObject {
  var delegate: (any CoreBluetooth.CBPeripheralManagerDelegate)? { get set }
  var state: CoreBluetooth.CBManagerState { get }
  var isAdvertising: Swift.Bool { get }
  func startAdvertising(_ advertisementData: [Swift.String : Any]?)
  func stopAdvertising()
  func setDesiredConnectionLatency(_ latency: CoreBluetooth.CBPeripheralManagerConnectionLatency, for central: CoreBluetooth.CBCentral)
  func add(_ service: CoreBluetooth.CBMutableService)
  func remove(_ service: CoreBluetooth.CBMutableService)
  func removeAllServices()
  func respond(to request: CoreBluetooth.CBATTRequest, withResult result: CoreBluetooth.CBATTError.Code)
  func updateValue(_ value: Foundation.Data, for characteristic: CoreBluetooth.CBMutableCharacteristic, onSubscribedCentrals centrals: [CoreBluetooth.CBCentral]?) -> Swift.Bool
}
extension CoreBluetooth.CBPeripheralManager : ZTCoreKit.ZTCBPeripheralManagerProtocol {
}
public enum DFUStreamHexError : Swift.Error {
  case invalidHexFile
  public static func == (a: ZTCoreKit.DFUStreamHexError, b: ZTCoreKit.DFUStreamHexError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ZTCBCentralManagerProtocol : AnyObject {
  var delegate: (any CoreBluetooth.CBCentralManagerDelegate)? { get set }
  var state: CoreBluetooth.CBManagerState { get }
  func stopScan()
  func retrievePeripherals(withIdentifiers identifiers: [Foundation.UUID]) -> [CoreBluetooth.CBPeripheral]
  func retrieveConnectedPeripherals(withServices serviceUUIDs: [CoreBluetooth.CBUUID]) -> [CoreBluetooth.CBPeripheral]
  func scanForPeripherals(withServices serviceUUIDs: [CoreBluetooth.CBUUID]?, options: [Swift.String : Any]?)
  func connect(_ peripheral: CoreBluetooth.CBPeripheral, options: [Swift.String : Any]?)
  func connect(_ peripheral: any ZTCoreKit.ZTCBPeripheralProtocol, options: [Swift.String : Any]?)
  func cancelPeripheralConnection(_ peripheral: CoreBluetooth.CBPeripheral)
}
extension CoreBluetooth.CBCentralManager : ZTCoreKit.ZTCBCentralManagerProtocol {
  public func retrievePeripheral(withIdentifier identifier: Foundation.UUID) -> (any ZTCoreKit.ZTCBPeripheralProtocol)?
  public func retrieveConnectedPeripherals(withServices services: [CoreBluetooth.CBUUID]) -> [any ZTCoreKit.ZTCBPeripheralProtocol]
  public func connect(_ peripheral: any ZTCoreKit.ZTCBPeripheralProtocol, options: [Swift.String : Any]?)
  public func cancelPeripheralConnection(_ peripheral: any ZTCoreKit.ZTCBPeripheralProtocol)
}
public struct ZhorthechPacket : Swift.Codable, Swift.Identifiable, Swift.Sendable {
  public typealias Activity = ZTCoreKit.ZhortechActivity
  public var id: Swift.Int16 {
    get
  }
  public var createdAt: Foundation.Date {
    get
  }
  public var dbCreated: Swift.Bool
  public var fulfilledAt: Foundation.Date? {
    get
  }
  public var scheduledDeleted: Foundation.Date? {
    get
  }
  public var sentAt: Foundation.Date? {
    get
  }
  public var rawData: Foundation.Data? {
    get
  }
  public var activityId: Swift.String? {
    get
  }
  public var activityType: ZTCoreKit.ZhorthechPacket.Mode? {
    get
  }
  public var status: ZTCoreKit.ZhorthechPacket.Status {
    get
  }
  public var timestampType: ZTCoreKit.ZhorthechPacket.TimestampType {
    get
  }
  public var bmTimestampType: ZTCoreKit.ZhorthechPacket.BmTimestampType {
    get
  }
  public var packetType: ZTCoreKit.ZhorthechPacket.PacketType {
    get
  }
  public var originalTimestamp: Swift.Int64 {
    get
  }
  public var packetsNumber: Swift.Int16 {
    get
  }
  public var fwVersion: Swift.String? {
    get
  }
  public var retryCount: Swift.Int16 {
    get
  }
  public init(data: Foundation.Data, activity: ZTCoreKit.ZhorthechPacket.Activity? = nil, fwVersion: Swift.String? = nil, name: Swift.String = "BA")
  public var safeTimestamp: Swift.Int64 {
    get
  }
  public var safeDuration: Swift.Int64 {
    get
  }
  public var timestamp: Swift.Int64
  public var key: Swift.String {
    get
  }
  public typealias ID = Swift.Int16
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_inheritsConvenienceInitializers open class ZTTextCharacteristic : ZTCoreKit.ZTCharacteristic {
  required public init(service: ZTCoreKit.ZTService, characteristic: CoreBluetooth.CBCharacteristic)
  public var stringValue: Swift.String? {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers open class ZTManufacturerNameCharacteristic : ZTCoreKit.ZTTextCharacteristic {
  public static var uuid: Swift.String
  open var data: Foundation.Data? {
    get
  }
  override open func valueUpdated()
  required public init(service: ZTCoreKit.ZTService, characteristic: CoreBluetooth.CBCharacteristic)
  @objc deinit
}
public typealias ZTBaseResult = (_ error: (any Swift.Error)?) -> Swift.Void
public typealias ZTResultObject<T> = (T?, (any Swift.Error)?) -> Swift.Void
public typealias ZTResultArray<T> = ([T]?, (any Swift.Error)?) -> Swift.Void
public typealias ZTCompletion = () -> Swift.Void
@_inheritsConvenienceInitializers public class ZTFirmwareCharacteristic : ZTCoreKit.ZTTextCharacteristic {
  public static let uuid: Swift.String
  open var data: Foundation.Data? {
    get
  }
  override open func valueUpdated()
  required public init(service: ZTCoreKit.ZTService, characteristic: CoreBluetooth.CBCharacteristic)
  @objc deinit
}
@objc public enum DFUError : Swift.Int {
  case remoteLegacyDFUSuccess = 1
  case remoteLegacyDFUInvalidState = 2
  case remoteLegacyDFUNotSupported = 3
  case remoteLegacyDFUDataExceedsLimit = 4
  case remoteLegacyDFUCrcError = 5
  case remoteLegacyDFUOperationFailed = 6
  case remoteSecureDFUSuccess = 11
  case remoteSecureDFUOpCodeNotSupported = 12
  case remoteSecureDFUInvalidParameter = 13
  case remoteSecureDFUInsufficientResources = 14
  case remoteSecureDFUInvalidObject = 15
  case remoteSecureDFUSignatureMismatch = 16
  case remoteSecureDFUUnsupportedType = 17
  case remoteSecureDFUOperationNotPermitted = 18
  case remoteSecureDFUOperationFailed = 20
  case remoteSecureDFUExtendedError = 21
  case remoteExtendedErrorWrongCommandFormat = 22
  case remoteExtendedErrorUnknownCommand = 23
  case remoteExtendedErrorInitCommandInvalid = 24
  case remoteExtendedErrorFwVersionFailure = 25
  case remoteExtendedErrorHwVersionFailure = 26
  case remoteExtendedErrorSdVersionFailure = 27
  case remoteExtendedErrorSignatureMissing = 28
  case remoteExtendedErrorWrongHashType = 29
  case remoteExtendedErrorHashFailed = 30
  case remoteExtendedErrorWrongSignatureType = 31
  case remoteExtendedErrorVerificationFailed = 32
  case remoteExtendedErrorInsufficientSpace = 33
  case remoteExperimentalButtonlessDFUSuccess = 9001
  case remoteExperimentalButtonlessDFUOpCodeNotSupported = 9002
  case remoteExperimentalButtonlessDFUOperationFailed = 9004
  case remoteButtonlessDFUSuccess = 91
  case remoteButtonlessDFUOpCodeNotSupported = 92
  case remoteButtonlessDFUOperationFailed = 94
  case remoteButtonlessDFUInvalidAdvertisementName = 95
  case remoteButtonlessDFUBusy = 96
  case remoteButtonlessDFUNotBonded = 97
  case fileNotSpecified = 101
  case fileInvalid = 102
  case extendedInitPacketRequired = 103
  case initPacketRequired = 104
  case failedToConnect = 201
  case deviceDisconnected = 202
  case bluetoothDisabled = 203
  case serviceDiscoveryFailed = 301
  case deviceNotSupported = 302
  case readingVersionFailed = 303
  case enablingControlPointFailed = 304
  case writingCharacteristicFailed = 305
  case receivingNotificationFailed = 306
  case unsupportedResponse = 307
  case bytesLost = 308
  case crcError = 309
  case invalidInternalState = 500
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum DFUState : Swift.Int {
  case connecting
  case starting
  case enablingDfuMode
  case uploading
  case validating
  case disconnecting
  case completed
  case aborted
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension ZTCoreKit.DFUState : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@objc public protocol DFUProgressDelegate {
  @objc func dfuProgressDidChange(for part: Swift.Int, outOf totalParts: Swift.Int, to progress: Swift.Int, currentSpeedBytesPerSecond: Swift.Double, avgSpeedBytesPerSecond: Swift.Double)
}
@objc public protocol DFUServiceDelegate {
  @objc func dfuStateDidChange(to state: ZTCoreKit.DFUState)
  @objc func dfuError(_ error: ZTCoreKit.DFUError, didOccurWithMessage message: Swift.String)
}
@_inheritsConvenienceInitializers public class ZTPrimaryOldService : ZTCoreKit.ZTService, ZTCoreKit.ZTServiceProtocol {
  public static var uuid: Swift.String {
    get
  }
  public static var characteristicTypes: [Swift.String : ZTCoreKit.ZTCharacteristic.Type]
  required public init(device: ZTCoreKit.ZTDevice, service: CoreBluetooth.CBService)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class IntelHex2BinConverter : ObjectiveC.NSObject {
  public static func convert(_ hex: Foundation.Data, mbrSize: Swift.UInt32 = 0) -> Foundation.Data?
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers public class ZTIndicateCharacteristic : ZTCoreKit.ZTCharacteristic {
  public static var uuid: Swift.String
  open var data: Foundation.Data? {
    get
  }
  required public init(service: ZTCoreKit.ZTService, characteristic: CoreBluetooth.CBCharacteristic)
  override open func valueUpdated()
  @objc deinit
}
final public class ZTSignal<T> {
  public typealias ZTSignalCallback = (T) -> Swift.Void
  final public var fireCount: Swift.Int {
    get
  }
  final public var retainLastData: Swift.Bool {
    get
    set
  }
  final public var lastDataFired: T? {
    get
  }
  final public var observers: [Swift.AnyObject] {
    get
  }
  public init(retainLastData: Swift.Bool = false)
  @discardableResult
  final public func subscribe(with observer: Swift.AnyObject, callback: @escaping ZTCoreKit.ZTSignal<T>.ZTSignalCallback) -> ZTCoreKit.ZTSignalSubscription<T>
  @discardableResult
  final public func subscribeOnce(with observer: Swift.AnyObject, callback: @escaping ZTCoreKit.ZTSignal<T>.ZTSignalCallback) -> ZTCoreKit.ZTSignalSubscription<T>
  @discardableResult
  final public func subscribePast(with observer: Swift.AnyObject, callback: @escaping ZTCoreKit.ZTSignal<T>.ZTSignalCallback) -> ZTCoreKit.ZTSignalSubscription<T>
  @discardableResult
  final public func subscribePastOnce(with observer: Swift.AnyObject, callback: @escaping ZTCoreKit.ZTSignal<T>.ZTSignalCallback) -> ZTCoreKit.ZTSignalSubscription<T>
  final public func fire(_ data: T)
  final public func cancelSubscription(for observer: Swift.AnyObject)
  final public func cancelAllSubscriptions()
  final public func clearLastData()
  @objc deinit
}
extension ZTCoreKit.ZTSignal where T == () {
  final public func fire()
}
@_hasMissingDesignatedInitializers final public class ZTSignalSubscription<T> {
  public typealias ZTSignalCallback = (T) -> Swift.Void
  public typealias ZTSignalFilter = (T) -> Swift.Bool
  weak final public var observer: Swift.AnyObject?
  final public var once: Swift.Bool
  @discardableResult
  final public func filter(_ predicate: @escaping ZTCoreKit.ZTSignalSubscription<T>.ZTSignalFilter) -> ZTCoreKit.ZTSignalSubscription<T>
  @discardableResult
  final public func sample(every sampleInterval: Foundation.TimeInterval) -> ZTCoreKit.ZTSignalSubscription<T>
  @discardableResult
  final public func onQueue(_ queue: Dispatch.DispatchQueue) -> ZTCoreKit.ZTSignalSubscription<T>
  final public func cancel()
  @objc deinit
}
infix operator => : AssignmentPrecedence
public func => <T>(signal: ZTCoreKit.ZTSignal<T>, data: T)
public enum ZTPeriod : Swift.String {
  case day
  case week
  case month
  case year
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct ZTPairedDevice : Swift.Codable {
  public var macAddress: Swift.String {
    get
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public class ZTMediaFile : ZTCoreKit.ZTMappable {
  public var id: Swift.String?
  public var name: Swift.String?
  public var mimeType: Swift.String?
  public var key: Swift.String?
  public var url: Swift.String?
  public var mfableId: Swift.String?
  public var mfableType: Swift.String?
  public var createdAt: Foundation.Date?
  public var updatedAt: Foundation.Date?
  required public init?(map: ZTCoreKit.ZTMap)
  public func mapping(map: ZTCoreKit.ZTMap)
  @objc deinit
}
public struct ZTMessageInactivityTimeout : Swift.CustomStringConvertible, Swift.Codable {
  public var left: Swift.UInt32
  public var right: Swift.UInt32
  public init(bytes: [Swift.UInt8])
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension ZTCoreKit.ZTMessageInactivityTimeout {
  public var description: Swift.String {
    get
  }
}
public enum ZTTXPower : Swift.UInt8 {
  case dBm0
  case dBm2
  case dBm3
  case dBm4
  case dBm5
  case dBm6
  case dBm7
  case dBm8
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct ZTMessageChunkConfig : Swift.CustomStringConvertible, Swift.Codable {
  public var byte0: Swift.UInt8? {
    get
  }
  public var byte1: Swift.UInt8? {
    get
  }
  public init(bytes: [Swift.UInt8])
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension ZTCoreKit.ZTMessageChunkConfig {
  public var side: ZTCoreKit.ZTModuleSide {
    get
  }
  public var flag: Swift.UInt8 {
    get
  }
  public var description: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers public class ZTPacketDfuCharacteristic : ZTCoreKit.ZTCharacteristic {
  public static let uuid: Swift.String
  open var data: Foundation.Data? {
    get
  }
  required public init(service: ZTCoreKit.ZTService, characteristic: CoreBluetooth.CBCharacteristic)
  override open func valueUpdated()
  @objc deinit
}
public struct ZTMessageActivity : Swift.CustomStringConvertible, Swift.Codable {
  public init(bytes: [Swift.UInt8])
  public var isRight: Swift.Bool {
    get
  }
  public var isLeft: Swift.Bool {
    get
  }
  public var selectedMode: ZTCoreKit.ZTActivityMode? {
    get
  }
  public var timeInterval: Swift.Int? {
    get
  }
  public var description: Swift.String {
    get
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_inheritsConvenienceInitializers public class ZTControlPointDfuCharacteristic : ZTCoreKit.ZTCharacteristic {
  public static let uuid: Swift.String
  open var data: Foundation.Data? {
    get
  }
  required public init(service: ZTCoreKit.ZTService, characteristic: CoreBluetooth.CBCharacteristic)
  override open func valueUpdated()
  @objc deinit
}
public protocol ZTImmutableMappable : ZTCoreKit.ZTBaseMappable {
  init(map: ZTCoreKit.ZTMap) throws
}
extension ZTCoreKit.ZTImmutableMappable {
  public func mapping(map: ZTCoreKit.ZTMap)
  public init(JSONString: Swift.String, context: (any ZTCoreKit.ZTMapContext)? = nil) throws
  public init(JSON: [Swift.String : Any], context: (any ZTCoreKit.ZTMapContext)? = nil) throws
  public init(JSONObject: Any, context: (any ZTCoreKit.ZTMapContext)? = nil) throws
}
extension ZTCoreKit.ZTMap {
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> Transform.Object where Transform : ZTCoreKit.ZTTransformType
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T where T : Swift.RawRepresentable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T? where T : Swift.RawRepresentable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T] where T : Swift.RawRepresentable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T]? where T : Swift.RawRepresentable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T where T : ZTCoreKit.ZTBaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T? where T : ZTCoreKit.ZTBaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T] where T : ZTCoreKit.ZTBaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T]? where T : ZTCoreKit.ZTBaseMappable
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Transform.Object] where Transform : ZTCoreKit.ZTTransformType
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Swift.String : T] where T : ZTCoreKit.ZTBaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Swift.String : T]? where T : ZTCoreKit.ZTBaseMappable
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Swift.String : Transform.Object] where Transform : ZTCoreKit.ZTTransformType
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [[T]]? where T : ZTCoreKit.ZTBaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [[T]] where T : ZTCoreKit.ZTBaseMappable
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [[Transform.Object]] where Transform : ZTCoreKit.ZTTransformType
}
extension ZTCoreKit.ZTMapper where N : ZTCoreKit.ZTImmutableMappable {
  final public func map(JSON: [Swift.String : Any]) throws -> N
  final public func map(JSONString: Swift.String) throws -> N
  final public func map(JSONObject: Any) throws -> N
  final public func mapArray(JSONArray: [[Swift.String : Any]]) throws -> [N]
  final public func mapArray(JSONString: Swift.String) throws -> [N]
  final public func mapArray(JSONObject: Any) throws -> [N]
  final public func mapDictionary(JSONString: Swift.String) throws -> [Swift.String : N]
  final public func mapDictionary(JSONObject: Any?) throws -> [Swift.String : N]
  final public func mapDictionary(JSON: [Swift.String : [Swift.String : Any]]) throws -> [Swift.String : N]
  final public func mapDictionaryOfArrays(JSONObject: Any?) throws -> [Swift.String : [N]]
  final public func mapDictionaryOfArrays(JSON: [Swift.String : [[Swift.String : Any]]]) throws -> [Swift.String : [N]]
  final public func mapArrayOfArrays(JSONObject: Any?) throws -> [[N]]
}
extension ZTCoreKit.ZhortechActivityActor {
  public typealias FetchConfiguration = ZTCoreKit.ZhortechActivityFetchConfiguration
  @discardableResult
  public func send(packets: [ZTCoreKit.ZhortechActivityActor.Packet], sentHandler: ([ZTCoreKit.ZhortechActivityActor.Packet]) async throws -> [ZTCoreKit.ZhortechActivityActor.Packet]) async throws -> [ZTCoreKit.ZhortechActivityActor.Packet]
  public func startFetchTimer(configuration: ZTCoreKit.ZhortechActivityActor.FetchConfiguration = .default, sentHandler: @escaping ([ZTCoreKit.ZhortechActivityActor.Packet]) async throws -> [ZTCoreKit.ZhortechActivityActor.Packet])
}
extension ZTCoreKit.ZhortechActivityActor {
  public func stop(force: Swift.Bool = false) async throws
  public func anchorTimestamp(_ value: Swift.Int64) async throws
  public func resetAnchorTimestamp() async throws
  public func fwVersion(_ value: Swift.String?) async throws
  public func clearMetaData() async throws
  public func update(actualState: ZTCoreKit.ZhortechActivityActor.ActualStates) async throws
  public func activityType(_ value: Swift.String) async throws
  public func customActivityStartTimestamp(_ value: Swift.Int64) async throws
  public func customActivityFirstChunkId(_ value: Swift.Int16) async throws
}
open class ZTEnumTransform<T> : ZTCoreKit.ZTTransformType where T : Swift.RawRepresentable {
  public typealias Object = T
  public typealias JSON = T.RawValue
  public init()
  open func transformFromJSON(_ value: Any?) -> T?
  open func transformToJSON(_ value: T?) -> T.RawValue?
  @objc deinit
}
public typealias ZTScannerResultBlock = (ZTCoreKit.ZTScannerResult) -> Swift.Void
public enum ZTScannerResult {
  case success(device: ZTCoreKit.ZTDevice)
  case cancelled
  case failed((any Swift.Error)?)
}
open class ZTDateDefaultTransform : ZTCoreKit.ZTTransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.Double
  public enum Unit : Foundation.TimeInterval {
    case seconds
    case milliseconds
    public init?(rawValue: Foundation.TimeInterval)
    public typealias RawValue = Foundation.TimeInterval
    public var rawValue: Foundation.TimeInterval {
      get
    }
  }
  public init(unit: ZTCoreKit.ZTDateDefaultTransform.Unit = .seconds)
  open func transformFromJSON(_ value: Any?) -> Foundation.Date?
  open func transformToJSON(_ value: Foundation.Date?) -> Swift.Double?
  @objc deinit
}
open class ZTCodableTransform<T> : ZTCoreKit.ZTTransformType where T : Swift.Decodable, T : Swift.Encodable {
  public typealias Object = T
  public typealias JSON = Any
  public init()
  open func transformFromJSON(_ value: Any?) -> ZTCoreKit.ZTCodableTransform<T>.Object?
  open func transformToJSON(_ value: T?) -> Any?
  @objc deinit
}
public protocol ZTDfuDelegate : AnyObject {
  func dfuDelegate(firmwareDownloaded: Swift.Bool, version: Swift.String?)
  func dfuDelegate(didFinish: Swift.Bool)
  func dfuDelegate(didFail error: ZTCoreKit.ZTError?)
  func dfuDelegate(progress: Swift.Float?)
  func dfuDelegate(leftDidFinish newVersion: Swift.String?)
  func dfuDelegate(rightDidFinish newVersion: Swift.String?)
}
public protocol ZTNotifyDataMessage : Swift.Decodable, Swift.Encodable {
  var rawData: Foundation.Data? { get set }
}
extension ZTCoreKit.ZTCore {
  final public func updateFirmware(packageType: ZTCoreKit.ZTDfuPackageType? = nil, isButtonless: Swift.Bool = true)
  final public func updateFirmware(path: Swift.String)
}
extension ZTCoreKit.ZTCore : ZTCoreKit.DFUServiceDelegate, ZTCoreKit.DFUProgressDelegate, ZTCoreKit.LoggerDelegate {
  @objc final public func dfuStateDidChange(to state: ZTCoreKit.DFUState)
  final public func dfuFailed(error: ZTCoreKit.ZTError)
  @objc final public func dfuError(_ error: ZTCoreKit.DFUError, didOccurWithMessage message: Swift.String)
  @objc final public func dfuProgressDidChange(for part: Swift.Int, outOf totalParts: Swift.Int, to progress: Swift.Int, currentSpeedBytesPerSecond: Swift.Double, avgSpeedBytesPerSecond: Swift.Double)
  @objc final public func logWith(_ level: ZTCoreKit.LogLevel, message: Swift.String)
  final public func checkDfuState()
}
public enum ZTLogLevel : Swift.String {
  case all
  case debug
  case info
  case error
  case fatal
  public var logType: os.OSLogType {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension ZTCoreKit.ZTLogLevel : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public enum ZTLogCategory : Swift.String {
  case networkAgent
  case modules
  case sdk
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension ZTCoreKit.ZTLogCategory : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public enum ZTBleManagerState : Swift.CustomStringConvertible {
  case off
  case on
  case idle
  case scanning
  case unauthorized
  case resetting
  case unknown
  case unsupported
  public var description: Swift.String {
    get
  }
  public static func == (a: ZTCoreKit.ZTBleManagerState, b: ZTCoreKit.ZTBleManagerState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public actor ZhortechLogger {
  public static func setLogger(_ logger: any ZTCoreKit.ZhortechLoggerProtocol)
  @objc deinit
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  @_semantics("defaultActor") nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
public protocol ZhortechLoggerProtocol {
  static var instance: Self { get }
  func ztDebugPrint(_ message: Swift.String)
  func debug(_ message: Swift.StaticString, _ args: any Swift.CVarArg...)
  func info(_ message: Swift.StaticString, _ args: any Swift.CVarArg...)
  func error(_ message: Swift.StaticString, _ args: any Swift.CVarArg...)
  func fatal(_ message: Swift.StaticString, _ args: any Swift.CVarArg...)
}
public enum ZTError : Swift.Equatable, Swift.Error {
  case scanning(type: ZTCoreKit.ZTError.Enums.ScanningError)
  case ble(type: ZTCoreKit.ZTError.Enums.BleError)
  case network(type: ZTCoreKit.ZTError.Enums.NetworkError)
  case store(type: ZTCoreKit.ZTError.Enums.StoreError)
  case custom(errorDescription: Swift.String?, error: (any Swift.Error)? = nil)
  case decoding(type: ZTCoreKit.ZTError.Enums.DecodableError)
  case activity(type: ZTCoreKit.ZTError.Enums.ActivityError)
  case dfu(type: ZTCoreKit.ZTError.Enums.DfuError)
  @_hasMissingDesignatedInitializers public class Enums {
    @objc deinit
  }
  public static func == (lhs: ZTCoreKit.ZTError, rhs: ZTCoreKit.ZTError) -> Swift.Bool
  public var error: (any Swift.Error)? {
    get
  }
}
extension ZTCoreKit.ZTError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension ZTCoreKit.ZTError.Enums {
  public enum ScanningError {
    case cameraPermission
    case wrongCode
    case unknown
    case notLinkedUser
    public static func == (a: ZTCoreKit.ZTError.Enums.ScanningError, b: ZTCoreKit.ZTError.Enums.ScanningError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension ZTCoreKit.ZTError.Enums.ScanningError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension ZTCoreKit.ZTError.Enums {
  public enum BleError {
    case invalidState
    case resetting
    case poweredOff
    case unsupported
    case timeout
    case unauthorized
    case notConnected
    case notConnectedLeft
    case activityIsRunning
    case busy
    case dfu
    case commandError
    public static func == (a: ZTCoreKit.ZTError.Enums.BleError, b: ZTCoreKit.ZTError.Enums.BleError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension ZTCoreKit.ZTError.Enums.BleError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension ZTCoreKit.ZTError.Enums {
  public enum FirmwareError {
    case differentFirmware
    case memsError
    case leftNoConnected
    case restartRequired
    case recoverFromDfu
    case minimumFwVersion
    case updateRequired
    case unsupported
    case wrongProductType
    case firstChunkIdIsGreater
    case startTimeZero
    public static func == (a: ZTCoreKit.ZTError.Enums.FirmwareError, b: ZTCoreKit.ZTError.Enums.FirmwareError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension ZTCoreKit.ZTError.Enums.FirmwareError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension ZTCoreKit.ZTError.Enums {
  public enum DfuError {
    case noLeftModule
    case noUpdate
    case wrongFile
    case noStart
    case aborted
    case abortedRight
    case abortedLeft
    case unsupported
    case lowBattery
    case inProgress
    case updateRequired
    case wrongProductType
    public static func == (a: ZTCoreKit.ZTError.Enums.DfuError, b: ZTCoreKit.ZTError.Enums.DfuError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension ZTCoreKit.ZTError.Enums.DfuError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension ZTCoreKit.ZTError.Enums {
  public enum StoreError {
    case missing(Swift.String)
    case invalid(Swift.String, Any?)
    case wrong(Swift.String)
    case unknown
  }
}
extension ZTCoreKit.ZTError.Enums.StoreError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension ZTCoreKit.ZTError.Enums {
  public enum ActivityError {
    case notStarted
    case notStartedLeft
    case notStopped
    case unknown
    case modeNotSetActivityIsRunning
    case previousNotStopped
    case previousRestoring
    case noUserParametersSet
    case rawDataFlowIsRunning
    case invalidMobilityScanResults
    case outsideActivityDetected
    case anomalyDetected
    case mobility
    public static func == (a: ZTCoreKit.ZTError.Enums.ActivityError, b: ZTCoreKit.ZTError.Enums.ActivityError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension ZTCoreKit.ZTError.Enums.ActivityError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension ZTCoreKit.ZTError.Enums {
  public enum NetworkError {
    case userLinkError
    case inaccessible
    case urlError(Foundation.URLError)
    case generalError(any Swift.Error)
    case noResponse
    case invalidResponseType(Foundation.URLResponse)
    case noResponseData(Foundation.HTTPURLResponse)
    case endpointError(Foundation.HTTPURLResponse, Foundation.Data?)
    case custom(errorCode: Swift.Int?, errorDescription: Swift.String?)
  }
}
extension ZTCoreKit.ZTError.Enums.NetworkError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension ZTCoreKit.ZTError.Enums {
  public enum DecodableError {
    case invalidKeyPath
    case emptyKeyPath
    case invalidJSON
    public static func == (a: ZTCoreKit.ZTError.Enums.DecodableError, b: ZTCoreKit.ZTError.Enums.DecodableError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension ZTCoreKit.ZTError.Enums.DecodableError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public enum ZTProductType : Swift.String {
  case sports
  case warm
  case safety
  case podoSmart
  case dfu
  case ztDfu
  case baliston
  public var activityType: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ZTProjectCodeType : Swift.String {
  case zt1
  case zt2
  case zt3
  case zt4
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ZTProductCodeType : Swift.String {
  case WS, WM
  case SP
  case SF
  case PS
  case SI
  case BA
  case XX
  public var activityType: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ZTManufacturerCodeType : Swift.String {
  case a
  case b
  case c
  case d
  case e
  case f
  case z
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ZTProductTypeCode : Swift.String {
  case ix
  case sx
  case xx
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ZTGenderCodeType : Swift.String {
  case man
  case woman
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ZTGenderSizeCodeType : Swift.String {
  case a
  case b
  case c
  case d
  case e
  case f
  case g
  case h
  case i
  case j
  case n
  case o
  case p
  case q
  case r
  case s
  case t
  case u
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ZTUnitSizeCodeType : Swift.String {
  case a
  case b
  case c
  case d
  case e
  case f
  case n
  case o
  case p
  case q
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ZTCommand : Swift.UInt8, Swift.CaseIterable, Swift.Identifiable {
  public var id: Swift.UInt8 {
    get
  }
  case generalState
  case startNewActivity
  case stopNewActivity
  case resendData
  case deepSleep
  case reboot
  case detailedBattery
  case hardwareInformation
  case firmwareInformation
  case bootloaderVersion
  case setInactivityTimeout
  case setDFUInstall
  case setDFUMode
  case setChunkConfig
  case setChunkMinutesInterval
  case setChunkSecondsInterval
  case selectAlgorithm
  case freeMemory
  case getTimestamp
  case passthroughAlgo
  case resetActivity
  case getActivityMetadata
  case disableHeating
  case setHeating
  case setTimer
  case getTemperature
  case getTimer
  case startPostureCalibration
  case setUserParameters
  case resetCalibration
  case getCalibrationState
  case rawDataSend
  case rawDataEnable
  case rawDataLookup
  case rawDataDebug
  case calibrateStatic
  case clearCalibrateStatic
  case cancelCalibrateStatic
  case getCalibrateStaticMessage
  case getCalibrateStaticData
  case testCalibrateStatic
  case memsConfig
  case updateTxPower
  case updatePhy
  case disconnect
  case leftRightConnectionInterval
  case startDFURight
  case startDFULeft
  case enablePeerConnection
  case factoryReset
  case scheduleAdd
  case clearlSchedule
  case setDFUKey
  case setDFUPubkey
  case setDFUKeySecure
  case getDevicePubkey
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.UInt8)
  public typealias AllCases = [ZTCoreKit.ZTCommand]
  public typealias ID = Swift.UInt8
  public typealias RawValue = Swift.UInt8
  nonisolated public static var allCases: [ZTCoreKit.ZTCommand] {
    get
  }
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum ZTActivitySummaryStatus : Swift.String {
  case started
  case complete
  case processing
  case errored
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
open class ZTActivitySummary : ZTCoreKit.ZTMappable {
  public var id: Swift.String
  public var activityType: Swift.String
  public var activityIdentifier: Swift.String
  public var start: Swift.String?
  public var end: Swift.String?
  public var duration: Swift.Int?
  public var tz: Swift.String?
  public var startDate: Foundation.Date?
  public var endDate: Foundation.Date?
  public var status: ZTCoreKit.ZTActivitySummaryStatus?
  required public init?(map: ZTCoreKit.ZTMap)
  open func mapping(map: ZTCoreKit.ZTMap)
  @objc deinit
}
public enum ZTPassthroughAlgo : ZTCoreKit.ZTEnum {
  case status(id: ZTCoreKit.ZTAlgoStatus)
  case startNewChunk
  case changeProductMode(mode: ZTCoreKit.ZTAlgoMode)
  case setPrecisionMode(mode: ZTCoreKit.ZTAlgoPrecisionMode)
  case setMinimumStepsForAnalysis(activityType: ZTCoreKit.ZTActivityType, steps: Swift.Int)
  case setMinimumStridesForAnalysis(activityType: ZTCoreKit.ZTActivityType, strides: Swift.Int)
  case setStreamingMode(interval: Swift.UInt16, activityType: ZTCoreKit.ZTActivityType, metricsId: Swift.UInt8)
  public var parameters: [Swift.UInt8] {
    get
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public typealias ConnectResultBlock = (ZTCoreKit.ZTDevice?, (any Swift.Error)?) -> Swift.Void
public typealias ScanResultBlock = (ZTCoreKit.ZTDevice?, (any Swift.Error)?) -> Swift.Void
public typealias ScanFinishedBlock = ((any Swift.Error)?) -> Swift.Void
@_hasMissingDesignatedInitializers final public class ZTCore {
  public static let version: Swift.String
  final public var zcVersion: Swift.String
  public static let shared: ZTCoreKit.ZTCore
  final public var bleManager: ZTCoreKit.ZTBleManager? {
    get
  }
  final public var settings: ZTCoreKit.ZTSettings {
    get
  }
  final public var appUserId: Swift.String? {
    get
  }
  final public var lastCommand: ZTCoreKit.ZTCommand?
  final public var lastCommandResponses: [ZTCoreKit.ZTCommandResponse]
  final public var lastActivityId: Swift.String? {
    get
  }
  final public var leftModuleCommandStatus: ZTCoreKit.ZTCommandStatus {
    get
  }
  final public var connectedDevice: ZTCoreKit.ZTDevice? {
    get
  }
  final public var lastDeviceSerialNumber: Swift.String? {
    get
  }
  final public var lastDeviceQRCode: Swift.String? {
    get
  }
  final public var lastQRCode: Swift.String? {
    get
  }
  final public var isDfuInProgress: Swift.Bool {
    get
  }
  final public var longRangePHY: Swift.Bool {
    get
  }
  final public var agressiveConnInterval: Swift.Bool {
    get
  }
  final public var needImprovedConnectivity: Swift.Bool {
    get
  }
  final public var activityManager: ZTCoreKit.ZhortechActivityActor {
    get
  }
  final public var backgroundDFUEnable: Swift.Bool {
    get
  }
  weak final public var dfuDelegate: (any ZTCoreKit.ZTDfuDelegate)?
  final public var firmwareDfuState: ZTCoreKit.DFUState? {
    get
  }
  final public let keyingAndDfuRequired: ZTCoreKit.ZTSignal<Swift.Bool>
  final public var currentDfuState: ZTCoreKit.ZTMessageBootloaderInfo.DfuState {
    get
    set
  }
  final public let onDfuStateUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageBootloaderInfo.DfuState>
  final public let onDfuUploadProgress: ZTCoreKit.ZTSignal<Swift.Float?>
  final public let onDfuFinishedLeft: ZTCoreKit.ZTSignal<ZTCoreKit.ZTError?>
  final public let onDfuFinishedRight: ZTCoreKit.ZTSignal<ZTCoreKit.ZTError?>
  final public let onDfuFinished: ZTCoreKit.ZTSignal<ZTCoreKit.ZTError?>
  final public let onDfuCopied: ZTCoreKit.ZTSignal<()>
  final public func setup(apiKey: Swift.String, secret: Swift.String, appId: Swift.String, completion: (((any Swift.Error)?) -> Swift.Void)? = nil)
  final public func clearUser()
  final public func updateOrganization(code: Swift.String? = nil, appType: Swift.String? = nil)
  @available(*, deprecated, message: "Use scan(product:, timeout:, deviceDiscovered:, completion:) instead")
  final public func scan(for product: ZTCoreKit.ZTProductType? = nil, timeout: Swift.Double? = 15, completion: ZTCoreKit.ConnectResultBlock? = nil)
  final public func scan(for product: ZTCoreKit.ZTProductType? = nil, timeout: Swift.Double? = 15, deviceDiscovered: ZTCoreKit.ScanResultBlock? = nil, completion: ZTCoreKit.ScanFinishedBlock? = nil)
  final public func scan(macAddress: Swift.String, timeout: Swift.Double? = 15, deviceDiscovered: ZTCoreKit.ScanResultBlock? = nil, completion: ZTCoreKit.ScanFinishedBlock? = nil)
  final public func stopScan()
  final public func connectWithDevice(_ device: ZTCoreKit.ZTDevice?, timeout: Swift.Double? = 5, isDfu: Swift.Bool = false, completion: @escaping ZTCoreKit.ConnectResultBlock)
  final public func connect(withCode code: Swift.String, timeout: Swift.Double? = 20) async throws -> ZTCoreKit.ZTDevice
  @available(*, deprecated, renamed: "connect(withCode:)", message: "Use Swift Concurrency compliant (Async/Await) method instead.")
  final public func connectWithCode(_ code: Swift.String, timeout: Swift.Double? = 20, completion: @escaping ZTCoreKit.ConnectResultBlock)
  final public func getDeviceInfo(code: Swift.String, completion: @escaping (ZTCoreKit.ZTDeviceInfo?, (any Swift.Error)?) -> Swift.Void)
  final public func tryReconnect(completion: ZTCoreKit.ConnectResultBlock? = nil)
  final public func checkConnectedDevice(completion: ZTCoreKit.ConnectResultBlock? = nil)
  final public func setDeepSleepMode() throws
  @objc deinit
  final public func subscribeEvents()
}
public class ZTAchievement : ZTCoreKit.ZTMappable {
  public var id: Swift.String?
  public var type: Swift.String?
  public var activityId: Swift.String?
  public var code: Swift.String?
  public var appuserId: Swift.String?
  public var data: [Swift.String : Any]?
  public var duration: Swift.Int64?
  public var calories: Swift.Double?
  public var createdAt: Foundation.Date?
  required public init?(map: ZTCoreKit.ZTMap)
  public func mapping(map: ZTCoreKit.ZTMap)
  @objc deinit
}
public enum ZTAlgoState : Swift.UInt8, ZTCoreKit.ZTEnum {
  case undefined
  case walking
  case running
  case pedaling
  case jump
  case stairsUp
  case stairsDown
  case standing
  case sitting
  case kneeling
  case tiptoe
  case vibration
  case slip
  case incident
  case freewheel
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public protocol ZTTransformType {
  associatedtype Object
  associatedtype JSON
  func transformFromJSON(_ value: Any?) -> Self.Object?
  func transformToJSON(_ value: Self.Object?) -> Self.JSON?
}
public enum ZTAlgoCommand : Swift.UInt8 {
  case getStatus
  case startNewChunk
  case changeProductMode
  case setPrecisionMode
  case setMinimumNumberOfStrides
  case enableStreamingOfValues
  case setDisconnectionDelay
  case setUserInfo
  case setDailyTimestamp
  case getPositionOfPods
  case enableSpecificPacket
  case holdRealtimeStreaming
  case getSingleTimeMetrics
  case calibrateGravity
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum ZTRealtimeMessageEventType : Swift.UInt8, ZTCoreKit.ZTEnum {
  case status
  case acknowledgment
  case realTimeEvent
  case realTimeMetrics
  case warning
  case error
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public protocol ZTBaseMappable {
  mutating func mapping(map: ZTCoreKit.ZTMap)
}
public protocol ZTMappable : ZTCoreKit.ZTBaseMappable {
  init?(map: ZTCoreKit.ZTMap)
}
public protocol ZTStaticMappable : ZTCoreKit.ZTBaseMappable {
  static func objectForMapping(map: ZTCoreKit.ZTMap) -> (any ZTCoreKit.ZTBaseMappable)?
}
extension ZTCoreKit.ZTMappable {
  public init?(JSONString: Swift.String, context: (any ZTCoreKit.ZTMapContext)? = nil)
  public init?(JSON: [Swift.String : Any], context: (any ZTCoreKit.ZTMapContext)? = nil)
}
extension ZTCoreKit.ZTBaseMappable {
  public func toJSON() -> [Swift.String : Any]
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
extension Swift.Array where Element : ZTCoreKit.ZTBaseMappable {
  public init?(JSONString: Swift.String, context: (any ZTCoreKit.ZTMapContext)? = nil)
  public init(JSONArray: [[Swift.String : Any]], context: (any ZTCoreKit.ZTMapContext)? = nil)
  public func toJSON() -> [[Swift.String : Any]]
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
extension Swift.Set where Element : ZTCoreKit.ZTBaseMappable {
  public init?(JSONString: Swift.String, context: (any ZTCoreKit.ZTMapContext)? = nil)
  public init?(JSONArray: [[Swift.String : Any]], context: (any ZTCoreKit.ZTMapContext)? = nil)
  public func toJSON() -> [[Swift.String : Any]]
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
extension ZTCoreKit.ZTRealtimeMessage {
  public struct Metrics : Swift.CustomStringConvertible {
    public var activityType: ZTCoreKit.ZTActivityType? {
      get
    }
    public var metricId: Swift.UInt8? {
      get
    }
    public var metric: ZTCoreKit.ZTRealtimeMetric? {
      get
    }
    public var value: [Swift.UInt8]? {
      get
    }
    public var description: Swift.String {
      get
    }
    public init(data: Foundation.Data)
  }
}
extension ZTCoreKit.ZTRealtimeMessage {
  public struct Acknowledgment : Swift.CustomStringConvertible {
    public var command: ZTCoreKit.ZTAlgoCommand? {
      get
    }
    public var status: ZTCoreKit.ZTAlgoAcknowledgmentStatus? {
      get
    }
    public var description: Swift.String {
      get
    }
    public init(data: Foundation.Data)
  }
}
public protocol ZTCBPeripheralProtocol {
  var delegate: (any CoreBluetooth.CBPeripheralDelegate)? { get set }
  var name: Swift.String? { get }
  var rssi: Foundation.NSNumber? { get }
  var state: CoreBluetooth.CBPeripheralState { get }
  var services: [CoreBluetooth.CBService]? { get }
  var identifier: Foundation.UUID { get }
  func discoverServices(_: [CoreBluetooth.CBUUID]?)
  func discoverCharacteristics(_: [CoreBluetooth.CBUUID]?, for: CoreBluetooth.CBService)
  func readValue(for: CoreBluetooth.CBCharacteristic)
  func writeValue(_: Foundation.Data, for: CoreBluetooth.CBCharacteristic, type: CoreBluetooth.CBCharacteristicWriteType)
  func setNotifyValue(_: Swift.Bool, for: CoreBluetooth.CBCharacteristic)
}
extension CoreBluetooth.CBPeripheral : ZTCoreKit.ZTCBPeripheralProtocol {
}
public enum DFUStreamZipError : Swift.Error {
  case noManifest
  case invalidManifest
  case fileNotFound
  case typeNotFound
  public static func == (a: ZTCoreKit.DFUStreamZipError, b: ZTCoreKit.DFUStreamZipError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension ZTCoreKit.DFUStreamZipError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers @objc open class DFUFirmwareSize : ObjectiveC.NSObject {
  @objc open var softdevice: Swift.UInt32 {
    get
  }
  @objc open var bootloader: Swift.UInt32 {
    get
  }
  @objc open var application: Swift.UInt32 {
    get
  }
  @objc deinit
}
@objc public enum DFUFirmwareType : Swift.UInt8 {
  case softdevice = 1
  case bootloader = 2
  case application = 4
  case softdeviceBootloader = 3
  case softdeviceBootloaderApplication = 7
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct DFUFirmwareError : Swift.Error {
  public enum FileType {
    case zip
    case binOrHex
    case dat
    public static func == (a: ZTCoreKit.DFUFirmwareError.FileType, b: ZTCoreKit.DFUFirmwareError.FileType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let type: ZTCoreKit.DFUFirmwareError.FileType
}
extension ZTCoreKit.DFUFirmwareError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@objc public class DFUFirmware : ObjectiveC.NSObject {
  @objc final public let fileName: Swift.String?
  @objc final public let fileUrl: Foundation.URL?
  @objc public var valid: Swift.Bool {
    @objc get
  }
  @objc public var size: ZTCoreKit.DFUFirmwareSize {
    @objc get
  }
  @objc public var parts: Swift.Int {
    @objc get
  }
  @objc convenience public init(urlToZipFile: Foundation.URL) throws
  @objc public init(urlToZipFile: Foundation.URL, type: ZTCoreKit.DFUFirmwareType) throws
  @objc convenience public init(zipFile: Foundation.Data) throws
  @objc public init(zipFile: Foundation.Data, type: ZTCoreKit.DFUFirmwareType) throws
  @objc public init(urlToBinOrHexFile: Foundation.URL, urlToDatFile: Foundation.URL?, type: ZTCoreKit.DFUFirmwareType) throws
  @objc public init(binFile: Foundation.Data, datFile: Foundation.Data?, type: ZTCoreKit.DFUFirmwareType)
  @objc public init(hexFile: Foundation.Data, datFile: Foundation.Data?, type: ZTCoreKit.DFUFirmwareType) throws
  @objc deinit
}
@_inheritsConvenienceInitializers open class ZTModelNumberCharacteristic : ZTCoreKit.ZTTextCharacteristic {
  public static var uuid: Swift.String
  open var data: Foundation.Data? {
    get
  }
  override open func valueUpdated()
  required public init(service: ZTCoreKit.ZTService, characteristic: CoreBluetooth.CBCharacteristic)
  @objc deinit
}
@_inheritsConvenienceInitializers public class ZTHardwareCharacteristic : ZTCoreKit.ZTTextCharacteristic {
  public static var uuid: Swift.String
  open var data: Foundation.Data? {
    get
  }
  override open func valueUpdated()
  required public init(service: ZTCoreKit.ZTService, characteristic: CoreBluetooth.CBCharacteristic)
  @objc deinit
}
extension ZTCoreKit.ZhortechActivity {
  public enum ActualStates : Swift.UInt8, Swift.Codable, Swift.Sendable {
    case activityNone
    case activityStarting
    case eraseMemory
    case activityRunning
    case activityPaused
    case activityStopping
    case activityPendData
    case activitySendData
    case unknown
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum StopReason : Swift.UInt8, Swift.Codable, Swift.Sendable {
    case undefined
    case userRequest
    case memoryFull
    case inactivity
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
@objc public class DFUServiceInitiator : ObjectiveC.NSObject {
  @objc weak public var delegate: (any ZTCoreKit.DFUServiceDelegate)?
  @objc weak public var progressDelegate: (any ZTCoreKit.DFUProgressDelegate)?
  @objc weak public var logger: (any ZTCoreKit.LoggerDelegate)?
  @objc public var peripheralSelector: any ZTCoreKit.DFUPeripheralSelectorDelegate
  @objc public var packetReceiptNotificationParameter: Swift.UInt16
  @objc public var forceDfu: Swift.Bool
  @objc public var forceScanningForNewAddressInLegacyDfu: Swift.Bool
  @objc public var connectionTimeout: Swift.Double
  @objc public var dataObjectPreparationDelay: Swift.Double
  @objc public var alternativeAdvertisingNameEnabled: Swift.Bool
  @objc public var alternativeAdvertisingName: Swift.String?
  @objc public var enableUnsafeExperimentalButtonlessServiceInSecureDfu: Swift.Bool
  @objc public var uuidHelper: ZTCoreKit.DFUUuidHelper
  @objc public var disableResume: Swift.Bool
  @available(*, deprecated, message: "Use init(queue: DispatchQueue?) instead.")
  @objc public init(centralManager: CoreBluetooth.CBCentralManager, target: CoreBluetooth.CBPeripheral)
  @objc public init(queue: Dispatch.DispatchQueue? = nil, delegateQueue: Dispatch.DispatchQueue = DispatchQueue.main, progressQueue: Dispatch.DispatchQueue = DispatchQueue.main, loggerQueue: Dispatch.DispatchQueue = DispatchQueue.main, centralManagerOptions: [Swift.String : Any]? = nil)
  @objc public func with(firmware file: ZTCoreKit.DFUFirmware) -> ZTCoreKit.DFUServiceInitiator
  @available(*, deprecated, message: "Use start(target: CBPeripheral) instead.")
  @objc public func start() -> ZTCoreKit.DFUServiceController?
  @objc public func start(target: CoreBluetooth.CBPeripheral) -> ZTCoreKit.DFUServiceController?
  @objc public func start(targetWithIdentifier uuid: Foundation.UUID) -> ZTCoreKit.DFUServiceController?
  @objc deinit
}
public enum ZTLoggerComponent : Swift.String {
  case api
  case app
  case sdk
  case firmware
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ZTLoggerSeverity : Swift.String {
  case debug
  case error
  case info
  case warn
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public class ZTUserShoe : ZTCoreKit.ZTMappable {
  public var id: Swift.String?
  public var code: Swift.String?
  public var attributes: [Swift.String : Any]?
  public var firmware: ZTCoreKit.ZTUserShoe.Firmware?
  public var organizationId: Swift.String?
  public var createdAt: Foundation.Date?
  public var updatedAt: Foundation.Date?
  required public init?(map: ZTCoreKit.ZTMap)
  public func mapping(map: ZTCoreKit.ZTMap)
  public class Firmware : ZTCoreKit.ZTMappable {
    public var type: Swift.String?
    public var arch: Swift.String?
    public var version: Swift.String?
    public var updatedAt: Foundation.Date?
    required public init?(map: ZTCoreKit.ZTMap)
    public func mapping(map: ZTCoreKit.ZTMap)
    @objc deinit
  }
  @objc deinit
}
@objc public protocol DFUPeripheralSelectorDelegate {
  @objc func select(_ peripheral: CoreBluetooth.CBPeripheral, advertisementData: [Swift.String : Swift.AnyObject], RSSI: Foundation.NSNumber, hint name: Swift.String?) -> Swift.Bool
  @objc func filterBy(hint dfuServiceUUID: CoreBluetooth.CBUUID) -> [CoreBluetooth.CBUUID]?
}
@_inheritsConvenienceInitializers public class ZTNotifyCharacteristic : ZTCoreKit.ZTCharacteristic {
  public static let uuid: Swift.String
  open var data: Foundation.Data? {
    get
  }
  required public init(service: ZTCoreKit.ZTService, characteristic: CoreBluetooth.CBCharacteristic)
  override open func valueUpdated()
  @objc deinit
}
public class ZTDateTransform : ZTCoreKit.ZTTransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.String
  public init()
  public func transformFromJSON(_ value: Any?) -> Foundation.Date?
  public func transformToJSON(_ value: Foundation.Date?) -> Swift.String?
  @objc deinit
}
public class ZTDateTransformUTC : ZTCoreKit.ZTTransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.String
  public init()
  public func transformFromJSON(_ value: Any?) -> Foundation.Date?
  public func transformToJSON(_ value: Foundation.Date?) -> Swift.String?
  @objc deinit
}
@_inheritsConvenienceInitializers public class ZTBatteryCharacteristic : ZTCoreKit.ZTCharacteristic {
  public static let uuid: Swift.String
  public var batteryLevel: ZTCoreKit.ZTBatteryLevel? {
    get
  }
  required public init(service: ZTCoreKit.ZTService, characteristic: CoreBluetooth.CBCharacteristic)
  override open func valueUpdated()
  @objc deinit
}
extension Foundation.UserDefaults {
  public subscript(key: ZTCoreKit.ZTDefaultsKey<Swift.Float>) -> Swift.Float {
    get
    set
  }
  public subscript(key: ZTCoreKit.ZTDefaultsKey<Swift.Double>) -> Swift.Double {
    get
    set
  }
  public subscript<T>(key: ZTCoreKit.ZTDefaultsKey<T>) -> T? {
    get
    set
  }
  public subscript(key: ZTCoreKit.ZTDefaultsKey<Swift.String>) -> Swift.String? {
    get
    set
  }
  public subscript(key: ZTCoreKit.ZTDefaultsKey<Foundation.Data>) -> Foundation.Data? {
    get
    set
  }
  public subscript(key: ZTCoreKit.ZTDefaultsKey<Foundation.Date>) -> Foundation.Date? {
    get
    set
  }
  public subscript(key: ZTCoreKit.ZTDefaultsKey<Foundation.URL>) -> Foundation.URL? {
    get
    set
  }
  public subscript(key: ZTCoreKit.ZTDefaultsKey<[Foundation.URL]>) -> [Foundation.URL]? {
    get
    set
  }
  public subscript(key: ZTCoreKit.ZTDefaultsKey<[Swift.String : Foundation.URL]>) -> [Swift.String : Foundation.URL]? {
    get
    set
  }
  public subscript<T>(key: ZTCoreKit.ZTDefaultsKey<T>) -> T? where T : Swift.Decodable, T : Swift.Encodable {
    get
    set
  }
  public subscript(key: Swift.String) -> Any? {
    get
    set(value)
  }
  public func value<T>(forKey key: Swift.String) -> T?
  public func clear(_ key: Swift.String)
  public func clear<T>(_ key: ZTCoreKit.ZTDefaultsKey<T>)
  public func clearAll()
}
@_hasMissingDesignatedInitializers public class ZTMediaFileTemplate : ZTCoreKit.ZTMappable {
  public var name: Swift.String
  public var description: Swift.String?
  public var mimeType: Swift.String?
  public var key: Swift.String?
  public var url: Swift.String?
  public var data: Foundation.Data?
  convenience public init(data: Foundation.Data? = nil, fileName: Swift.String? = nil, mimeType: Swift.String? = nil, description: Swift.String? = nil)
  required convenience public init?(map: ZTCoreKit.ZTMap)
  public func mapping(map: ZTCoreKit.ZTMap)
  @objc deinit
}
public struct ZTMessageSoftware : Swift.CustomStringConvertible, Swift.Codable {
  public init(bytes: [Swift.UInt8])
  public var side: ZTCoreKit.ZTModuleSide {
    get
  }
  public var baseMajor: Swift.UInt8 {
    get
  }
  public var baseMinor: Swift.UInt8 {
    get
  }
  public var baseBuild: Swift.UInt16 {
    get
  }
  public var app: Swift.String {
    get
  }
  public var appMajor: Swift.UInt8 {
    get
  }
  public var appMinor: Swift.UInt8 {
    get
  }
  public var version: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension Swift.String {
  public func binary(with character: Swift.String = "0", toLength length: Swift.Int = 8) -> Swift.String
  public var fromBase64: Swift.String? {
    get
  }
  public var toBase64: Swift.String {
    get
  }
  public func substring(from: Swift.Int, to: Swift.Int) -> Swift.String
  public func substring(range: Foundation.NSRange) -> Swift.String
  public func matches(regex: Swift.String) -> [Swift.String]
  public static func random(length: Swift.Int = 9) -> Swift.String
  public func split(usingRegex pattern: Swift.String) -> [Swift.String]
  public func serialNumber() -> Swift.String
  public func fileName() -> Swift.String
  public func incrementedMacAddress() -> Swift.String
}
extension Swift.String {
  public func toByteArray() -> [Swift.UInt8]?
}
extension Swift.Int {
  public func toByteArray(size: Swift.Int = 4) -> [Swift.UInt8]
}
extension Swift.UInt8 {
  public var bits: [Swift.UInt8] {
    get
  }
  public var hexValue: Swift.String {
    get
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public var hexString: Swift.String {
    get
  }
}
extension Swift.UInt16 {
  public func toByteArray(size: Swift.Int = 2) -> [Swift.UInt8]
}
extension Swift.UInt32 {
  public func toByteArray(size: Swift.Int = 4) -> [Swift.UInt8]
}
extension Swift.UInt64 {
  public func toByteArray(size: Swift.Int = 8) -> [Swift.UInt8]
}
extension Swift.Double {
  public var milliseconds: Swift.Int64 {
    get
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public var hex: Swift.String {
    get
  }
}
extension Swift.Dictionary {
  public func merge(dict: [Key : Value]) -> [Key : Value]
}
extension Swift.Int64 {
  public var readableTimeStamp: Swift.String {
    get
  }
}
extension Swift.UInt32 {
  public var readableTimeStamp: Swift.String {
    get
  }
}
extension Foundation.Date {
  public var timestamp: Swift.Int64 {
    get
  }
  public var apiFormat: Swift.String {
    get
  }
  public var logFormat: Swift.String {
    get
  }
  public func toLocalTime() -> Foundation.Date
}
extension Swift.Array where Element : CoreBluetooth.CBPeripheral {
  public func has(peripheral: CoreBluetooth.CBPeripheral) -> Swift.Bool
}
extension Swift.Array {
  public func chunked(into size: Swift.Int = 1000) -> [[Element]]
}
extension Swift.Array where Element == Swift.String {
  public func stringify() -> Swift.String
}
extension CoreBluetooth.CBCharacteristic {
  public func notifyValue(_ isEnabled: Swift.Bool)
  public func readValue()
  @discardableResult
  public func write(_ data: Foundation.Data, writeType: CoreBluetooth.CBCharacteristicWriteType) -> Swift.Bool
}
public struct ZTMessageChunkData : Swift.CustomStringConvertible, Swift.Codable {
  public enum Mode : Swift.UInt8 {
    case manual
    case automatic
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public var byte0: Swift.UInt8? {
    get
  }
  public var byte1: Swift.UInt8? {
    get
  }
  public var byte2: Swift.UInt8? {
    get
  }
  public var byte3: Swift.UInt8? {
    get
  }
  public init(bytes: [Swift.UInt8])
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension ZTCoreKit.ZTMessageChunkData {
  public var side: ZTCoreKit.ZTModuleSide {
    get
  }
  public var mode: ZTCoreKit.ZTMessageChunkData.Mode {
    get
  }
  public var length: Swift.UInt8 {
    get
  }
  public var payload: Foundation.Data? {
    get
  }
  public var description: Swift.String {
    get
  }
}
public enum ZTDfuPackageType : Swift.String {
  case APP
  case BL
  case SD
  case SD_BL
  case SD_BL_APP
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public func <<- <T>(left: inout T, right: ZTCoreKit.ZTMap) where T : Swift.SignedInteger
public func <<- <T>(left: inout T?, right: ZTCoreKit.ZTMap) where T : Swift.SignedInteger
public func <<- <T>(left: inout T, right: ZTCoreKit.ZTMap) where T : Swift.UnsignedInteger
public func <<- <T>(left: inout T?, right: ZTCoreKit.ZTMap) where T : Swift.UnsignedInteger
extension ZTCoreKit.ZhorthechPacket {
  public var rawDescription: Swift.String {
    get
  }
}
extension ZTCoreKit.ZhortechActivityActor {
  @discardableResult
  public func updated(packet: ZTCoreKit.ZhortechActivityActor.Packet, for activity: ZTCoreKit.ZhortechActivityActor.Activity?) async throws -> ZTCoreKit.ZhortechActivityActor.Packet
  @discardableResult
  public func contextualUpdated(packet: ZTCoreKit.ZhortechActivityActor.Packet, for activity: ZTCoreKit.ZhortechActivityActor.Activity?) async throws -> ZTCoreKit.ZhortechActivityActor.Packet
  public func createPacket(data: Foundation.Data, name: Swift.String, activity: ZTCoreKit.ZhortechActivityActor.Activity?, fwVersion: Swift.String?, updateBlock: ((ZTCoreKit.ZhortechActivityActor.Packet) -> ZTCoreKit.ZhortechActivityActor.Packet)? = nil) async throws -> ZTCoreKit.ZhortechActivityActor.Packet
}
extension ZTCoreKit.ZhortechActivityActor {
  public func checkMissedChunks(activityId: Swift.String) async throws -> Swift.Bool
  public func hasMissedChunks(activityId: Swift.String, startIndex: Swift.Int16?, endIndex: Swift.Int16?) async throws -> Swift.Bool
  public func hasPreviousChunk(activityId: Swift.String, currentIndex: Swift.Int16) async throws -> Swift.Bool
  public func loadAllIds(activityId: Swift.String, startId: Swift.Int16, endId: Swift.Int16? = nil) async throws -> [Swift.Int16]
  public func loadAll(for activityId: Swift.String) async throws -> [ZTCoreKit.ZhorthechPacket]
  public func loadAll(for activityId: Swift.String, startId: Swift.Int16) async throws -> [ZTCoreKit.ZhorthechPacket]
  public func loadUnsent(activityId: Swift.String) async throws -> [ZTCoreKit.ZhorthechPacket]
  public func count(for activityId: Swift.String) async throws -> Swift.Int
  public func count(for activity: ZTCoreKit.ZhortechActivity) async throws -> Swift.Int
  public func lastChunkID(for activityId: Swift.String) async throws -> Swift.Int16?
  public func loadPreviousTimestamps(activityId: Swift.String?, packetId: Swift.Int16, startId: Swift.Int16? = nil) async throws -> (id: Swift.Int16?, timestamp: Swift.Int64?, originalTimestamp: Swift.Int64?)?
  public func loadLastFwVersionEvent(activityId: Swift.String?, packetId: Swift.Int16, startId: Swift.Int16? = nil) async throws -> Swift.String?
  public func loadPrevious(activityId: Swift.String?, chunkId: Swift.Int16, originalTimestamp: Swift.Int64) async throws -> ZTCoreKit.ZhorthechPacket?
  public func getMinMissedChunk(activityId: Swift.String, chunkId: Swift.Int16, activityChunkRetryLimit: Swift.Int) async throws -> Swift.Int16?
  public func getMissedPackets(activityId: Swift.String, startId: Swift.Int16, endId: Swift.Int16? = nil, activityChunkRetryLimit: Swift.Int) async throws -> [Swift.Int16]?
  public func lastSegmentId(activityId: Swift.String) async throws -> Swift.Int
  public func segmentsCount(activityId: Swift.String) async throws -> Swift.Int
  public func loadOrphelin() async throws -> [ZTCoreKit.ZhorthechPacket]
  public func updateSegments(ids: [Swift.Int16], status: ZTCoreKit.ZhorthechPacket.Status, activityId: Swift.String) async throws
  public func updateSegments(ids: [Swift.Int16], status: ZTCoreKit.ZhorthechPacket.Status, activity: ZTCoreKit.ZhortechActivity) async throws
  public func updateSegmentsTimestamp(activityId: Swift.String, startId: Swift.Int16, anchorTime: Swift.Int64?) async throws
  @discardableResult
  public func update(_ packets: [ZTCoreKit.ZhortechActivityActor.Packet], withNewStatus newStatus: ZTCoreKit.ZhortechActivityActor.Packet.Status) async throws -> [ZTCoreKit.ZhortechActivityActor.Packet]
}
extension ZTCoreKit.ZhorthechPacket {
  @discardableResult
  public mutating func status(_ value: ZTCoreKit.ZhorthechPacket.Status) -> ZTCoreKit.ZhorthechPacket
  @discardableResult
  public mutating func fwVersion(_ value: Swift.String) -> ZTCoreKit.ZhorthechPacket
  @discardableResult
  public mutating func activityType(_ value: ZTCoreKit.ZhorthechPacket.Mode) -> ZTCoreKit.ZhorthechPacket
}
public class ZTUser : ZTCoreKit.ZTMappable {
  public var attributes: [Swift.String : Any]
  public var id: Swift.String?
  public var organizationId: Swift.String?
  public var appId: Swift.String?
  public var createdAt: Swift.String?
  public var updatedAt: Swift.String?
  public var userId: Swift.String?
  required public init?(map: ZTCoreKit.ZTMap)
  public func mapping(map: ZTCoreKit.ZTMap)
  @objc deinit
}
open class ZTService {
  weak public var device: ZTCoreKit.ZTDevice! {
    get
  }
  final public let service: CoreBluetooth.CBService
  public static var serviceType: ZTCoreKit.ZTService.Type {
    get
  }
  public var characteristics: [Swift.String : ZTCoreKit.ZTCharacteristic] {
    get
  }
  public func characteristic<T>(_ uuid: Swift.String? = nil) -> T? where T : ZTCoreKit.ZTCharacteristic
  required public init(device: ZTCoreKit.ZTDevice, service: CoreBluetooth.CBService)
  @objc deinit
}
extension ZTCoreKit.ZTService : Swift.Equatable {
  public static func == (lhs: ZTCoreKit.ZTService, rhs: ZTCoreKit.ZTService) -> Swift.Bool
}
public enum ZTServices {
  public enum Primary {
    public static let uid: Swift.String
    public static let uuid: CoreBluetooth.CBUUID
    public enum Characteristic {
      case commands
      case notifyData
      case indicateData
      case batteryLevel
      case pairedSoles
      case test
      public var uid: Swift.String {
        get
      }
      public var uuid: CoreBluetooth.CBUUID {
        get
      }
      public static func == (a: ZTCoreKit.ZTServices.Primary.Characteristic, b: ZTCoreKit.ZTServices.Primary.Characteristic) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
  }
  public enum PrimaryOld {
    public static let uid: Swift.String
    public static let uuid: CoreBluetooth.CBUUID
    public enum Characteristic {
      case commands
      case notifyData
      case indicateData
      case batteryLevel
      case pairedSoles
      public var uid: Swift.String {
        get
      }
      public static func == (a: ZTCoreKit.ZTServices.PrimaryOld.Characteristic, b: ZTCoreKit.ZTServices.PrimaryOld.Characteristic) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
  }
  public enum DeviceInformation {
    public static let uid: Swift.String
    public static let uuid: CoreBluetooth.CBUUID
    public enum Characteristic {
      case manufacturerName
      case modelNumber
      case serialNumber
      case firmwareRevision
      case hardwareRevision
      public var uid: Swift.String {
        get
      }
      public static func == (a: ZTCoreKit.ZTServices.DeviceInformation.Characteristic, b: ZTCoreKit.ZTServices.DeviceInformation.Characteristic) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
  }
  public enum DeviceDFU {
    public static let uid: Swift.String
    public static let uuid: CoreBluetooth.CBUUID
    public enum Characteristic {
      case dfuControlPoint
      case dfuPacket
      case dfuButtonless
      public var uid: Swift.String {
        get
      }
      public static func == (a: ZTCoreKit.ZTServices.DeviceDFU.Characteristic, b: ZTCoreKit.ZTServices.DeviceDFU.Characteristic) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
  }
}
public struct ZTDictionaryTransform<Key, Value> : ZTCoreKit.ZTTransformType where Key : Swift.Hashable, Key : Swift.RawRepresentable, Value : ZTCoreKit.ZTMappable, Key.RawValue == Swift.String {
  public init()
  public func transformFromJSON(_ value: Any?) -> [Key : Value]?
  public func transformToJSON(_ value: [Key : Value]?) -> Any?
  public typealias JSON = Any
  public typealias Object = [Key : Value]
}
open class ZTDataTransform : ZTCoreKit.ZTTransformType {
  public typealias Object = Foundation.Data
  public typealias JSON = Swift.String
  public init()
  open func transformFromJSON(_ value: Any?) -> Foundation.Data?
  open func transformToJSON(_ value: Foundation.Data?) -> Swift.String?
  @objc deinit
}
public struct ZhortechActivity : Swift.Codable, Swift.Identifiable, Swift.Hashable, Swift.Equatable, Swift.Sendable, Swift.CustomStringConvertible {
  public typealias MessageActivityMetadata = ZTCoreKit.ZhortechMessageActivityMetadata
  public typealias Packet = ZTCoreKit.ZhorthechPacket
  public let id: Swift.String
  public var activityIdentifier: Swift.String {
    get
  }
  public var appId: Swift.String {
    get
  }
  public var activityType: Swift.String {
    get
  }
  public var startDate: Foundation.Date {
    get
  }
  public var endDate: Foundation.Date? {
    get
  }
  public var startTimestamp: Swift.Int64 {
    get
  }
  public var endTimestamp: Swift.Int64 {
    get
  }
  public var tz: Swift.String? {
    get
  }
  public var state: ZTCoreKit.ZhortechActivity.ActualStates {
    get
  }
  public var packets: [ZTCoreKit.ZhortechActivity.Packet]? {
    get
  }
  public var metaData: ZTCoreKit.ZhortechActivity.MessageActivityMetadata? {
    get
  }
  public var isRawDataMode: Swift.Bool {
    get
  }
  public var isAutomatic: Swift.Bool {
    get
  }
  public var forceStop: Swift.Bool {
    get
  }
  public var isInterrupted: Swift.Bool {
    get
  }
  public var firstChunkId: Swift.Int16 {
    get
  }
  public var lastChunkId: Swift.Int16 {
    get
  }
  public var chunkCount: Swift.Int16 {
    get
  }
  public var anchorTimestamp: Swift.Int64 {
    get
  }
  public var customActivityStartTimestamp: Swift.Int64 {
    get
  }
  public var customActivityFirstChunkId: Swift.Int16 {
    get
  }
  public var fwVersion: Swift.String? {
    get
  }
  public var shoesSerial: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: ZTCoreKit.ZhortechActivity, rhs: ZTCoreKit.ZhortechActivity) -> Swift.Bool
  public var description: Swift.String {
    get
  }
  public typealias ID = Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension ZTCoreKit.ZhortechActivity {
  public var isValidAnchorTimestamp: Swift.Bool {
    get
  }
  public mutating func anchorTimestamp(_ value: Swift.Int64)
  public mutating func resetAnchorTimestamp()
  public mutating func forceStop(_ value: Swift.Bool)
  public mutating func isAutomatic(_ value: Swift.Bool)
  public mutating func fwVersion(_ value: Swift.String?)
  public mutating func isInterrupted(_ value: Swift.Bool)
  public mutating func activityType(_ value: Swift.String)
  public mutating func customActivityStartTimestamp(_ value: Swift.Int64)
  public mutating func startTimestamp(_ value: Swift.Int64)
  public mutating func customActivityFirstChunkId(_ value: Swift.Int16)
  public mutating func clearMetaData()
  public mutating func lastChunkId(_ value: Swift.Int16)
  public mutating func update(actualState: ZTCoreKit.ZhortechActivity.ActualStates)
  public mutating func packets(_ value: [ZTCoreKit.ZhortechActivity.Packet]?)
  public mutating func metaData(_ value: ZTCoreKit.ZhortechActivity.MessageActivityMetadata?)
  public mutating func firstChunkId(_ value: Swift.Int16)
}
extension Swift.Int16 {
  public static let invalid: Swift.Int16
}
extension Swift.Int64 {
  public static let invalid: Swift.Int64
}
public enum ZTSamplingMode : Swift.UInt8, Swift.Codable {
  case jump
  case run
  case walk
  public var parameters: [Swift.UInt8] {
    get
  }
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension ZTCoreKit.ZTCore {
  final public func isDummyFirmware(packageType: ZTCoreKit.ZTDfuPackageType? = nil, installFW: Swift.Bool = true)
}
open class ZTCharacteristic {
  weak public var service: ZTCoreKit.ZTService? {
    get
  }
  public var value: Foundation.Data? {
    get
  }
  public var characteristic: CoreBluetooth.CBCharacteristic! {
    get
  }
  public var valueUpdatedTimeInterval: Swift.Double? {
    get
  }
  public var valueWrittenTimeInterval: Swift.Double? {
    get
  }
  public var isNotifying: Swift.Bool {
    get
  }
  final public let onValueUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTCharacteristic>
  final public let onValueWritten: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTCharacteristic, Swift.Bool)>
  final public let onNotificationUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTCharacteristic>
  required public init(service: ZTCoreKit.ZTService, characteristic: CoreBluetooth.CBCharacteristic)
  open func valueUpdated()
  open func valueWritten()
  public func readValue()
  open func notificationUpdated()
  @objc deinit
}
public class ZTFirmwareRevision {
  public var fwSystemVersion: Swift.String? {
    get
  }
  public var productType: ZTCoreKit.ZTProductCodeType? {
    get
  }
  public var bmVersion: Swift.String? {
    get
  }
  public var date: Foundation.Date? {
    get
  }
  public var code: Swift.String {
    get
  }
  public var fwVersion: Swift.String {
    get
  }
  public var versions: ZTCoreKit.ZTFwBmVersion? {
    get
  }
  public init(code: Swift.String)
  @objc deinit
}
extension ZTCoreKit.ZTFirmwareRevision : Swift.Equatable {
  public static func == (lhs: ZTCoreKit.ZTFirmwareRevision, rhs: ZTCoreKit.ZTFirmwareRevision) -> Swift.Bool
  public static func < (lhs: ZTCoreKit.ZTFirmwareRevision, rhs: ZTCoreKit.ZTFirmwareRevision) -> Swift.Bool
  public static func >= (lhs: ZTCoreKit.ZTFirmwareRevision, rhs: ZTCoreKit.ZTFirmwareRevision) -> Swift.Bool
}
public struct ZTFwBmVersion {
  public var fwSystemMajorVersion: Swift.Int
  public var fwSystemMinorVersion: Swift.Int
  public var fwSystemBuildVersion: Swift.Int
  public var bmMajorVersion: Swift.Int
  public var bmMinorVersion: Swift.Int
}
extension ZTCoreKit.ZTFirmwareRevision {
  public var fwSystemMajorVersion: Swift.Int {
    get
  }
  public var fwSystemMinorVersion: Swift.Int {
    get
  }
  public var fwSystemBuildVersion: Swift.Int {
    get
  }
  public var bmMajorVersion: Swift.Int {
    get
  }
  public var bmMinorVersion: Swift.Int {
    get
  }
}
@objc public class ZTDevice : ObjectiveC.NSObject {
  public var id: Swift.String
  public var peripheral: CoreBluetooth.CBPeripheral? {
    get
  }
  public var cbPeripheral: (any ZTCoreKit.ZTCBPeripheralProtocol)? {
    get
  }
  public var serialNumber: Swift.String {
    get
  }
  public var name: Swift.String? {
    get
  }
  public var qrCode: Swift.String? {
    get
  }
  public var rssi: Swift.Int {
    get
  }
  public var macAddressRight: Swift.String?
  public var macAddressLeft: Swift.String?
  public var advertisementData: [Swift.String : Any]?
  public var manufacturer: Swift.String? {
    get
  }
  public var hardwareRevision: Swift.String? {
    get
  }
  public var firmwareRevision: ZTCoreKit.ZTFirmwareRevision? {
    get
  }
  public var isDummyFirmware: Swift.Bool {
    get
  }
  public var modelNumber: Swift.String? {
    get
  }
  public var uuid: Swift.String {
    get
  }
  public var isConnected: Swift.Bool {
    get
  }
  public var isActivityRunning: Swift.Bool {
    get
  }
  public var isDeviceReady: Swift.Bool {
    get
  }
  public var info: ZTCoreKit.ZTDeviceInfo? {
    get
    set
  }
  public var batterylevel: ZTCoreKit.ZTBatteryLevel? {
    get
  }
  public var lastActivityDate: Foundation.Date {
    get
  }
  public var generalState: ZTCoreKit.ZTMessageGeneralState? {
    get
    set
  }
  public var softwareInfo: (right: ZTCoreKit.ZTMessageSoftware?, left: ZTCoreKit.ZTMessageSoftware?) {
    get
    set
  }
  public var lowSoftwareInfo: Swift.String {
    get
  }
  public var activityInfo: ZTCoreKit.ZTMessageActivity? {
    get
    set
  }
  public var bootloaderInfo: (right: ZTCoreKit.ZTMessageBootloaderInfo?, left: ZTCoreKit.ZTMessageBootloaderInfo?) {
    get
    set
  }
  public var inactivityTimeout: ZTCoreKit.ZTMessageInactivityTimeout? {
    get
    set
  }
  public var actualState: ZTCoreKit.ZTDeviceActualState
  public var previousState: ZTCoreKit.ZTDeviceActualState
  public var hasInitialUpdate: Swift.Bool {
    get
  }
  final public let onStateChanged: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTDevice?, (any Swift.Error)?)>
  final public let onRSSIChanged: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTDevice, Swift.Int)>
  final public let onServiceDiscovered: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTDevice, ZTCoreKit.ZTService)>
  final public let onServiceFeaturesIdentified: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTDevice, ZTCoreKit.ZTService)>
  final public let onCharacteristicDiscovered: ZTCoreKit.ZTSignal<ZTCoreKit.ZTCharacteristic?>
  final public let onAllCharacteristicsDiscovered: ZTCoreKit.ZTSignal<()>
  final public let onAllCharacteristicsRead: ZTCoreKit.ZTSignal<()>
  final public let onCharacteristicValueUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTCharacteristic?>
  final public let onCharacteristicValueWritten: ZTCoreKit.ZTSignal<ZTCoreKit.ZTCharacteristic?>
  final public let onCommandCharacteristicDiscovered: ZTCoreKit.ZTSignal<ZTCoreKit.ZTCharacteristic?>
  final public let onNotifyValueUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.GroupID, Swift.UInt8, [Swift.UInt8]?)>
  final public let onBatteryValueUpdated: ZTCoreKit.ZTSignal<()>
  final public let onGeneralStateUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTDeviceActualState>
  final public let onActivityInfoUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageActivity?>
  final public let onSoftwareUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageSoftware?>
  final public let onTimeUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageTime?>
  final public let onActivityMetadataUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZhortechMessageActivityMetadata?>
  final public let onRawDataHeaderUpdated: ZTCoreKit.ZTSignal<Foundation.Data?>
  final public let onRawDataFrameUpdated: ZTCoreKit.ZTSignal<Foundation.Data?>
  final public let onInactivityTimeoutUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageInactivityTimeout?>
  final public let onFirmwareError: ZTCoreKit.ZTSignal<ZTCoreKit.ZTError.Enums.FirmwareError>
  final public let onNotifyCommonGroupUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.CommonMessageId, [Swift.UInt8]?)>
  final public let onNotifyWarmGroupUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.WarmMessageId, Foundation.Data?)>
  final public let onNotifyRunningGroupUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.RunningMessageId, [Swift.UInt8]?)>
  final public let onNotifyCyclingGroupUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.CyclingMessageId, [Swift.UInt8]?)>
  final public let onNotifySafetyGroupUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.SafetyMessageId, [Swift.UInt8]?)>
  final public let onNotifyGenericGroupUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.GenericMessageId, [Swift.UInt8]?)>
  final public let onNotifyStandardizeGroupUpdated: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTNotifyData.StandardizeMessageId, [Swift.UInt8]?)>
  final public let onCommandUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTCommandResponse?>
  final public let onCommandAck: ZTCoreKit.ZTSignal<ZTCoreKit.ZTCommandResponse?>
  final public let onIndicateValueUpdated: ZTCoreKit.ZTSignal<Foundation.Data?>
  final public let onBootloaderInfoUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageBootloaderInfo?>
  final public let onNotifyChunkSendStatusUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageChunkSendStatus?>
  final public let onNotifyChunkConfigUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageChunkConfig?>
  final public let onNotifyChunkDataUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageChunkData?>
  required public init(peripheral: CoreBluetooth.CBPeripheral)
  public init(cbPeripheral: any ZTCoreKit.ZTCBPeripheralProtocol)
  public func connect()
  public func disconnect()
  @objc deinit
  @objc override dynamic open func observeValue(forKeyPath keyPath: Swift.String?, of object: Any?, change: [Foundation.NSKeyValueChangeKey : Any]?, context: Swift.UnsafeMutableRawPointer?)
  public func service<T>(_ uuid: Swift.String? = nil) -> T? where T : ZTCoreKit.ZTService
  public func checkBattery(completion: @escaping (Swift.UInt8, Swift.UInt8, Swift.Bool) -> Swift.Void)
  public func readGeneralState()
}
extension ZTCoreKit.ZTDevice {
  public static func == (lhs: ZTCoreKit.ZTDevice, rhs: ZTCoreKit.ZTDevice) -> Swift.Bool
  public var isLowBattery: Swift.Bool? {
    get
  }
}
@_hasMissingDesignatedInitializers public class ZTCommandResponse {
  public var bytes: [Swift.UInt8]
  public var rightModule: Swift.Bool {
    get
  }
  public var leftModule: Swift.Bool {
    get
  }
  public var command: ZTCoreKit.ZTCommand? {
    get
  }
  public var status: ZTCoreKit.ZTCommandStatus? {
    get
  }
  @objc deinit
}
public enum ZTCommandStatus : Swift.UInt8 {
  case success
  case busy
  case invalidParam
  case invalidState
  case forbidden
  case notSupported
  case unknownCommand
  case commandInProgress
  case noPeerresponse
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
@_hasMissingDesignatedInitializers final public class ZTSettings {
  public static let shared: ZTCoreKit.ZTSettings
  final public var version: Swift.String?
  final public var logLevel: ZTCoreKit.ZTLogLevel
  final public var environment: ZTCoreKit.ZTEnvironment
  final public var autoConnect: Swift.Bool
  final public var enableEventLogging: Swift.Bool
  final public var shouldObtaineMissedChunks: Swift.Bool
  final public var enableRawDataCheck: Swift.Bool
  final public var shouldAutoResendData: Swift.Bool
  final public var activityDataSyncThreshold: Swift.Int
  final public var enableBackgroundDFU: Swift.Bool
  final public var enableBackgroundDataStreaming: Swift.Bool
  final public var activityChunkStoreForFreeMemory: Swift.Int
  final public var activityChunkRetryLimit: Swift.Int
  final public var checkFirmwareUpdatePeriod: Swift.Int
  final public var enableAnalyticsData: Swift.Bool
  final public var autorestartBackgroundDfu: Swift.Bool
  final public var getChunksOnApplicationDidBecomeActive: Swift.Bool
  final public var enablePacketsDataLogging: Swift.Bool
  final public var cachedPacketsBatchUploadSize: Swift.Int
  final public var chunkDuration: Swift.Int? {
    get
    set
  }
  final public var disableAutomaticActivity: Swift.Bool
  final public var allowAntennaOptimization: Swift.Bool
  final public var realTimeOnly: Swift.Bool
  final public func clear()
  final public var disablePLister: Swift.Bool
  @objc deinit
}
public enum ZTActivityLastStopReason : Swift.UInt8, Swift.Codable {
  case undefined
  case userRequest
  case memoryFull
  case inactivity
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension ZTCoreKit.ZTCore {
  final public func isPendingEmbeddedActivity(completion: @escaping (Swift.Bool, ZTCoreKit.ZTError?) -> Swift.Void)
  final public func pushPendingEmbeddedActivities(completion: @escaping (ZTCoreKit.ZTError?) -> Swift.Void)
}
@available(iOS 16.0, *)
public struct ZTCoreUserData : Swift.Identifiable, Swift.Codable, Swift.Sendable {
  public typealias ID = Swift.String
  public init(id: ZTCoreKit.ZTCoreUserData.ID, data: [Swift.String : Swift.String])
  public let id: ZTCoreKit.ZTCoreUserData.ID
  public let data: [Swift.String : Swift.String]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(iOS 16.0, *)
extension ZTCoreKit.ZTCore {
  public typealias UserData = ZTCoreKit.ZTCoreUserData
  final public func postUserData(model: Swift.String, objects: [ZTCoreKit.ZTCore.UserData]) async throws
  final public func patchUserData(model: Swift.String, objectId: ZTCoreKit.ZTCore.UserData.ID, objects: [ZTCoreKit.ZTCore.UserData]) async throws
  final public func deleteUserData(model: Swift.String, objectId: ZTCoreKit.ZTCore.UserData.ID) async throws
  final public func getUserData(model: Swift.String, objectId: ZTCoreKit.ZTCore.UserData.ID) async throws -> [ZTCoreKit.ZTCore.UserData]
  final public func getUserDataLatestID(model: Swift.String) async throws -> ZTCoreKit.ZTCore.UserData.ID?
}
public enum ZTAlgoStatus : Swift.UInt8, ZTCoreKit.ZTEnum {
  case timestamp
  case modeId
  case precisionMode
  case numberOfSteps
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension ZTCoreKit.ZhorthechPacket {
  public enum Status : Swift.Int16, Swift.Codable, Swift.Equatable, Swift.Sendable {
    case new
    case readyToSend
    case sending
    case sent
    case error
    public init?(rawValue: Swift.Int16)
    public typealias RawValue = Swift.Int16
    public var rawValue: Swift.Int16 {
      get
    }
  }
  public enum TimestampType : Swift.UInt8, Swift.Codable, Swift.Sendable {
    case unknown
    case start
    case stop
    case pause
    case resume
    case reboot
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum BmTimestampType : Swift.UInt8, Swift.Codable, Swift.Sendable {
    case unknown
    case shoeWearOn
    case shoeWearOff
    case walkingStart
    case walkingStop
    case runningStart
    case runningStop
    case cyclingStart
    case cyclingStop
    case transportStart
    case transportStop
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum PacketType : Swift.UInt8, Swift.Codable, Swift.Sendable {
    public static let maxDataValue: Swift.UInt8
    case unknown
    case quantification
    case walkAnalysis
    case runAnalysis
    case stairs
    case cycling
    case jump
    case safety
    case staticActivity
    case debug
    case debugTelemetry
    case debugProba
    case bmTimestampPacket
    case fwTimestampPacket
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum Mode : Swift.UInt8, Swift.Codable, Swift.Sendable {
    case safety
    case walking
    case running
    case cycling
    case mobility
    case swing
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
extension ZTCoreKit.ZhorthechPacket.TimestampType {
  public var description: Swift.String {
    get
  }
  public var name: Swift.String {
    get
  }
}
extension ZTCoreKit.ZhorthechPacket.BmTimestampType {
  public var description: Swift.String {
    get
  }
  public var name: Swift.String {
    get
  }
}
extension ZTCoreKit.ZhorthechPacket.PacketType {
  public var description: Swift.String {
    get
  }
}
open class ZTURLTransform : ZTCoreKit.ZTTransformType {
  public typealias Object = Foundation.URL
  public typealias JSON = Swift.String
  public init(shouldEncodeURLString: Swift.Bool = false, allowedCharacterSet: Foundation.CharacterSet = .urlQueryAllowed)
  open func transformFromJSON(_ value: Any?) -> Foundation.URL?
  open func transformToJSON(_ value: Foundation.URL?) -> Swift.String?
  @objc deinit
}
public enum ZTAlgoMode : Swift.UInt8, ZTCoreKit.ZTEnum {
  case monitoring
  case gaming
  public var parameters: [Swift.UInt8] {
    get
  }
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
open class ZTTransformOf<ObjectType, JSONType> : ZTCoreKit.ZTTransformType {
  public typealias Object = ObjectType
  public typealias JSON = JSONType
  public init(fromJSON: @escaping (JSONType?) -> ObjectType?, toJSON: @escaping (ObjectType?) -> JSONType?)
  open func transformFromJSON(_ value: Any?) -> ObjectType?
  open func transformToJSON(_ value: ObjectType?) -> JSONType?
  @objc deinit
}
public enum ZTActivityType : Swift.UInt8, ZTCoreKit.ZTEnum {
  case staticType
  case dynamic
  case walking
  case running
  case cycling
  case jump
  case stairsUp
  case stairsDown
  case staticOther
  case kneel
  case tiptoe
  case vibration
  case trampling
  case crawling
  case dynamicOther
  case slip
  case trip
  case active
  case inactive
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
open class ZTNSDecimalNumberTransform : ZTCoreKit.ZTTransformType {
  public typealias Object = Foundation.NSDecimalNumber
  public typealias JSON = Swift.String
  public init()
  open func transformFromJSON(_ value: Any?) -> Foundation.NSDecimalNumber?
  open func transformToJSON(_ value: Foundation.NSDecimalNumber?) -> Swift.String?
  @objc deinit
}
extension Swift.Array where Element == ZTCoreKit.ZTRealtimeMetric {
  public static var walk: [ZTCoreKit.ZTRealtimeMetric] {
    get
  }
}
public enum ZTRealtimeMetric : Swift.String {
  case duration
  case steps
  case cycleDuration
  case stepCadence
  case stepSpeed
  case distance
  case footDistance
  case energySum
  case walkingQualityScore
  case stairsClimbed
  case intenseActivity
  case slope
  case accelerationFoot
  case strideLength
  case relativePronationAngleFoot
  case pronationAngleFFI
  case pronationAngleFFO
  case plantarFlexionAngularSpeedMaxPropulsion
  case symmetry
  public func value() -> Swift.UInt8
  public var activityType: ZTCoreKit.ZTActivityType {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension ZTCoreKit.ZTRealtimeMetric {
  public init?(value: Swift.UInt8, activityType: ZTCoreKit.ZTActivityType? = nil)
  public init?(name: Swift.String)
}
public enum ZTMappingType {
  case fromJSON
  case toJSON
  public static func == (a: ZTCoreKit.ZTMappingType, b: ZTCoreKit.ZTMappingType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class ZTMapper<N> where N : ZTCoreKit.ZTBaseMappable {
  final public var context: (any ZTCoreKit.ZTMapContext)?
  final public var shouldIncludeNilValues: Swift.Bool
  public init(context: (any ZTCoreKit.ZTMapContext)? = nil, shouldIncludeNilValues: Swift.Bool = false)
  final public func map(JSONObject: Any?, toObject object: N) -> N
  final public func map(JSONString: Swift.String, toObject object: N) -> N
  final public func map(JSON: [Swift.String : Any], toObject object: N) -> N
  final public func map(JSONString: Swift.String) -> N?
  final public func map(JSONObject: Any?) -> N?
  final public func map(JSON: [Swift.String : Any]) -> N?
  final public func mapArray(JSONString: Swift.String) -> [N]?
  final public func mapArray(JSONObject: Any?) -> [N]?
  final public func mapArray(JSONArray: [[Swift.String : Any]]) -> [N]
  final public func mapDictionary(JSONString: Swift.String) -> [Swift.String : N]?
  final public func mapDictionary(JSONObject: Any?) -> [Swift.String : N]?
  final public func mapDictionary(JSON: [Swift.String : [Swift.String : Any]]) -> [Swift.String : N]?
  final public func mapDictionary(JSONObject: Any?, toDictionary dictionary: [Swift.String : N]) -> [Swift.String : N]
  final public func mapDictionary(JSON: [Swift.String : [Swift.String : Any]], toDictionary dictionary: [Swift.String : N]) -> [Swift.String : N]
  final public func mapDictionaryOfArrays(JSONObject: Any?) -> [Swift.String : [N]]?
  final public func mapDictionaryOfArrays(JSON: [Swift.String : [[Swift.String : Any]]]) -> [Swift.String : [N]]?
  final public func mapArrayOfArrays(JSONObject: Any?) -> [[N]]?
  public static func parseJSONStringIntoDictionary(JSONString: Swift.String) -> [Swift.String : Any]?
  public static func parseJSONString(JSONString: Swift.String) -> Any?
  @objc deinit
}
extension ZTCoreKit.ZTMapper {
  final public func map(JSONfile: Swift.String) -> N?
  final public func mapArray(JSONfile: Swift.String) -> [N]?
}
extension ZTCoreKit.ZTMapper {
  final public func toJSON(_ object: N) -> [Swift.String : Any]
  final public func toJSONArray(_ array: [N]) -> [[Swift.String : Any]]
  final public func toJSONDictionary(_ dictionary: [Swift.String : N]) -> [Swift.String : [Swift.String : Any]]
  final public func toJSONDictionaryOfArrays(_ dictionary: [Swift.String : [N]]) -> [Swift.String : [[Swift.String : Any]]]
  final public func toJSONString(_ object: N, prettyPrint: Swift.Bool = false) -> Swift.String?
  final public func toJSONString(_ array: [N], prettyPrint: Swift.Bool = false) -> Swift.String?
  public static func toJSONString(_ JSONObject: Any, prettyPrint: Swift.Bool) -> Swift.String?
  public static func toJSONData(_ JSONObject: Any, options: Foundation.JSONSerialization.WritingOptions) -> Foundation.Data?
}
extension ZTCoreKit.ZTMapper where N : Swift.Hashable {
  final public func mapSet(JSONString: Swift.String) -> Swift.Set<N>?
  final public func mapSet(JSONObject: Any?) -> Swift.Set<N>?
  final public func mapSet(JSONArray: [[Swift.String : Any]]) -> Swift.Set<N>
  final public func toJSONSet(_ set: Swift.Set<N>) -> [[Swift.String : Any]]
  final public func toJSONString(_ set: Swift.Set<N>, prettyPrint: Swift.Bool = false) -> Swift.String?
}
extension ZTCoreKit.ZTRealtimeMessage {
  public struct Status : Swift.CustomStringConvertible {
    public var code: ZTCoreKit.ZTAlgoStatus? {
      get
    }
    public var timestamp: Swift.UInt32? {
      get
    }
    public var algoMode: ZTCoreKit.ZTAlgoMode? {
      get
    }
    public var precisionMode: ZTCoreKit.ZTAlgoPrecisionMode? {
      get
    }
    public var consecutiveSteps: Swift.UInt8? {
      get
    }
    public var description: Swift.String {
      get
    }
    public init(data: Foundation.Data)
  }
}
public protocol ZTMapContext {
}
final public class ZTMap {
  final public let mappingType: ZTCoreKit.ZTMappingType
  final public var JSON: [Swift.String : Any] {
    get
  }
  final public var isKeyPresent: Swift.Bool {
    get
  }
  final public var currentValue: Any? {
    get
  }
  final public var currentKey: Swift.String? {
    get
  }
  final public var nestedKeyDelimiter: Swift.String {
    get
  }
  final public var context: (any ZTCoreKit.ZTMapContext)?
  final public var shouldIncludeNilValues: Swift.Bool
  final public let toObject: Swift.Bool
  public init(mappingType: ZTCoreKit.ZTMappingType, JSON: [Swift.String : Any], toObject: Swift.Bool = false, context: (any ZTCoreKit.ZTMapContext)? = nil, shouldIncludeNilValues: Swift.Bool = false)
  final public subscript(key: Swift.String) -> ZTCoreKit.ZTMap {
    get
  }
  final public subscript(key: Swift.String, delimiter delimiter: Swift.String) -> ZTCoreKit.ZTMap {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool) -> ZTCoreKit.ZTMap {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool, delimiter delimiter: Swift.String) -> ZTCoreKit.ZTMap {
    get
  }
  final public subscript(key: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> ZTCoreKit.ZTMap {
    get
  }
  final public subscript(key: Swift.String, delimiter delimiter: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> ZTCoreKit.ZTMap {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool, ignoreNil ignoreNil: Swift.Bool) -> ZTCoreKit.ZTMap {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool?, delimiter delimiter: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> ZTCoreKit.ZTMap {
    get
  }
  final public func value<T>() -> T?
  @objc deinit
}
extension ZTCoreKit.ZTMap {
  final public func value<T>(_ key: Swift.String, default: T.Object, using transform: T) throws -> T.Object where T : ZTCoreKit.ZTTransformType
  final public func value<T>(_ key: Swift.String, default: T) throws -> T
  final public func value<T>(_ key: Swift.String, default: [T]) -> [T] where T : ZTCoreKit.ZTBaseMappable
  final public func value<T>(_ key: Swift.String, default: T) throws -> T where T : ZTCoreKit.ZTBaseMappable
}
public struct ZTRealtimeMessage : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
  public enum Side : Swift.UInt8 {
    case none
    case left
    case right
    case both
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public var senderSide: ZTCoreKit.ZTRealtimeMessage.Side? {
    get
  }
  public var concernedSide: ZTCoreKit.ZTRealtimeMessage.Side? {
    get
  }
  public var eventType: ZTCoreKit.ZTRealtimeMessageEventType? {
    get
  }
  public var content: [Swift.UInt8] {
    get
  }
  public init(bytes: [Swift.UInt8])
  public var status: ZTCoreKit.ZTRealtimeMessage.Status? {
    get
  }
  public var acknowledgment: ZTCoreKit.ZTRealtimeMessage.Acknowledgment? {
    get
  }
  public var realtimeEvent: ZTCoreKit.ZTRealtimeMessage.Event? {
    get
  }
  public var realtimeMetrics: ZTCoreKit.ZTRealtimeMessage.Metrics? {
    get
  }
}
@objc public enum LogLevel : Swift.Int {
  case debug = 0
  case verbose = 1
  case info = 5
  case application = 10
  case warning = 15
  case error = 20
  public func name() -> Swift.String
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public protocol LoggerDelegate {
  @objc func logWith(_ level: ZTCoreKit.LogLevel, message: Swift.String)
}
@_inheritsConvenienceInitializers public class ZTPrimaryService : ZTCoreKit.ZTService, ZTCoreKit.ZTServiceProtocol {
  public static var uuid: Swift.String {
    get
  }
  public static var characteristicTypes: [Swift.String : ZTCoreKit.ZTCharacteristic.Type]
  required public init(device: ZTCoreKit.ZTDevice, service: CoreBluetooth.CBService)
  @objc deinit
}
@_inheritsConvenienceInitializers open class ZTSerialNumberCharacteristic : ZTCoreKit.ZTTextCharacteristic {
  public static var uuid: Swift.String
  open var data: Foundation.Data? {
    get
  }
  override open func valueUpdated()
  required public init(service: ZTCoreKit.ZTService, characteristic: CoreBluetooth.CBCharacteristic)
  @objc deinit
}
@_inheritsConvenienceInitializers public class ZTInformationService : ZTCoreKit.ZTService, ZTCoreKit.ZTServiceProtocol {
  public static var uuid: Swift.String {
    get
  }
  public static var characteristicTypes: [Swift.String : ZTCoreKit.ZTCharacteristic.Type]
  open var manufacturerName: ZTCoreKit.ZTManufacturerNameCharacteristic? {
    get
  }
  open var modelNumber: ZTCoreKit.ZTModelNumberCharacteristic? {
    get
  }
  open var serialNumber: ZTCoreKit.ZTSerialNumberCharacteristic? {
    get
  }
  open var firmwareRevision: ZTCoreKit.ZTFirmwareCharacteristic? {
    get
  }
  open var hardwareRevision: ZTCoreKit.ZTHardwareCharacteristic? {
    get
  }
  required public init(device: ZTCoreKit.ZTDevice, service: CoreBluetooth.CBService)
  @objc deinit
}
extension Foundation.DateFormatter {
  convenience public init(withFormat format: Swift.String, locale: Swift.String)
}
open class ZTISO8601DateTransform : ZTCoreKit.ZTDateFormatterTransform {
  public init()
  @objc deinit
}
public class ZTReachability {
  public var currentAdapterMode: ZTCoreKit.ZTReachability.Adapter
  public var currentConnectionStatus: ZTCoreKit.ZTReachability.Connection {
    get
    set
  }
  public typealias ZTConnectionReachable = (ZTCoreKit.ZTReachability) -> Swift.Void
  public typealias ZTConnectionUnReachable = (ZTCoreKit.ZTReachability) -> Swift.Void
  public var onConnectionReachable: ZTCoreKit.ZTReachability.ZTConnectionReachable?
  public var onConnectionUnReachable: ZTCoreKit.ZTReachability.ZTConnectionUnReachable?
  public var managerStarted: Swift.Bool
  public enum Adapter : Swift.CustomStringConvertible, Swift.Equatable {
    case all, wifi, cellular, wiredEthernet, loopback, other, none
    public var description: Swift.String {
      get
    }
    public func getInterfaceType() -> Network.NWInterface.InterfaceType
    public static func == (a: ZTCoreKit.ZTReachability.Adapter, b: ZTCoreKit.ZTReachability.Adapter) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Connection : Swift.CustomStringConvertible, Swift.Equatable {
    case online(adapter: ZTCoreKit.ZTReachability.Adapter), offline
    public var description: Swift.String {
      get
    }
    public static func == (lhs: ZTCoreKit.ZTReachability.Connection, rhs: ZTCoreKit.ZTReachability.Connection) -> Swift.Bool
  }
  public init(adapter: ZTCoreKit.ZTReachability.Adapter = .all)
  public func startManager()
  public func stopManager()
  @objc deinit
}
public struct ZhortechMessageActivityMetadata : Swift.Codable, Swift.Equatable, Swift.Sendable, Swift.CustomStringConvertible {
  public typealias LastStopReason = ZTCoreKit.ZhortechActivity.StopReason
  public let bytes: [Swift.UInt8]
  public var lastStopReason: ZTCoreKit.ZhortechMessageActivityMetadata.LastStopReason
  public var chunkCount: Swift.Int16
  public var firstChunkId: Swift.Int16
  public var lastChunkId: Swift.Int16 {
    get
  }
  public var startTime: Swift.UInt32
  public var endTime: Swift.UInt32
  public init(bytes: [Swift.UInt8])
  public var description: Swift.String {
    get
  }
  public static func == (a: ZTCoreKit.ZhortechMessageActivityMetadata, b: ZTCoreKit.ZhortechMessageActivityMetadata) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@objc public enum DFUUuidType : Swift.Int {
  case legacyService = 0
  case legacyControlPoint = 1
  case legacyPacket = 2
  case legacyVersion = 3
  case secureService = 4
  case secureControl = 5
  case securePacket = 6
  case buttonlessService = 7
  case buttonlessCharacteristic = 8
  case buttonlessWithoutBondSharing = 9
  case buttonlessWithBondSharing = 10
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public class DFUUuid : ObjectiveC.NSObject {
  @objc final public let uuid: CoreBluetooth.CBUUID
  @objc final public let type: ZTCoreKit.DFUUuidType
  @objc public init(withUUID: CoreBluetooth.CBUUID, forType: ZTCoreKit.DFUUuidType)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class DFUUuidHelper : ObjectiveC.NSObject {
  @objc public var legacyDFUService: CoreBluetooth.CBUUID {
    get
  }
  @objc public var legacyDFUControlPoint: CoreBluetooth.CBUUID {
    get
  }
  @objc public var legacyDFUPacket: CoreBluetooth.CBUUID {
    get
  }
  @objc public var legacyDFUVersion: CoreBluetooth.CBUUID {
    get
  }
  @objc public var secureDFUService: CoreBluetooth.CBUUID {
    get
  }
  @objc public var secureDFUControlPoint: CoreBluetooth.CBUUID {
    get
  }
  @objc public var secureDFUPacket: CoreBluetooth.CBUUID {
    get
  }
  @objc public var buttonlessExperimentalService: CoreBluetooth.CBUUID {
    get
  }
  @objc public var buttonlessExperimentalCharacteristic: CoreBluetooth.CBUUID {
    get
  }
  @objc public var buttonlessWithoutBonds: CoreBluetooth.CBUUID {
    get
  }
  @objc public var buttonlessWithBonds: CoreBluetooth.CBUUID {
    get
  }
  @objc override dynamic public init()
  @objc convenience public init(customUuids uuids: [ZTCoreKit.DFUUuid])
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc public class DFUServiceController : ObjectiveC.NSObject {
  @objc public func pause()
  @objc public func resume()
  @objc public func abort() -> Swift.Bool
  @objc public func restart()
  @objc public var paused: Swift.Bool {
    @objc get
  }
  @objc public var aborted: Swift.Bool {
    @objc get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class SecureDFUServiceInitiator : ZTCoreKit.DFUServiceInitiator {
  @objc override public func start(targetWithIdentifier uuid: Foundation.UUID) -> ZTCoreKit.DFUServiceController?
  @available(*, deprecated, message: "Use init(queue: DispatchQueue?) instead.")
  @objc override public init(centralManager: CoreBluetooth.CBCentralManager, target: CoreBluetooth.CBPeripheral)
  @objc override public init(queue: Dispatch.DispatchQueue? = nil, delegateQueue: Dispatch.DispatchQueue = super, progressQueue: Dispatch.DispatchQueue = super, loggerQueue: Dispatch.DispatchQueue = super, centralManagerOptions: [Swift.String : Any]? = nil)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc open class DFUPeripheralSelector : ObjectiveC.NSObject, ZTCoreKit.DFUPeripheralSelectorDelegate {
  @objc open func select(_ peripheral: CoreBluetooth.CBPeripheral, advertisementData: [Swift.String : Swift.AnyObject], RSSI: Foundation.NSNumber, hint name: Swift.String? = nil) -> Swift.Bool
  @objc open func filterBy(hint dfuServiceUUID: CoreBluetooth.CBUUID) -> [CoreBluetooth.CBUUID]?
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers public class ZTPairedSolesCharacteristic : ZTCoreKit.ZTCharacteristic {
  public static let uuid: Swift.String
  open var data: Foundation.Data? {
    get
  }
  required public init(service: ZTCoreKit.ZTService, characteristic: CoreBluetooth.CBCharacteristic)
  override open func valueUpdated()
  @objc deinit
}
@_inheritsConvenienceInitializers public class ZTCommandsCharacteristic : ZTCoreKit.ZTCharacteristic {
  public static let uuid: Swift.String
  open var data: Foundation.Data? {
    get
  }
  required public init(service: ZTCoreKit.ZTService, characteristic: CoreBluetooth.CBCharacteristic)
  override open func valueUpdated()
  @objc deinit
}
public enum ZTEnvironment {
  case dev
  case staging
  case production
  case zcdev
  case zcstaging
  case zcproduction
  case cnzcdev
  case cnzcproduction
  public var name: Swift.String {
    get
  }
  public var isDEV: Swift.Bool {
    get
  }
  public var isZC: Swift.Bool {
    get
  }
  public var needPut: Swift.Bool {
    get
  }
  public static func == (a: ZTCoreKit.ZTEnvironment, b: ZTCoreKit.ZTEnvironment) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ZTModuleSide : Swift.String, Swift.Codable {
  case left
  case right
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public func decodeData<T>(_ data: Foundation.Data, for type: T.Type) -> T? where T : Swift.Decodable, T : Swift.Encodable
public func encodeData<T>(for type: T) -> Foundation.Data where T : Swift.Decodable, T : Swift.Encodable
public struct ZTMessageTime : Swift.CustomStringConvertible {
  public var timestamp: Swift.Int64
  public var side: ZTCoreKit.ZTModuleSide
  public init(bytes: [Swift.UInt8])
  public var description: Swift.String {
    get
  }
}
extension Foundation.Data {
  public func macAddress() -> Swift.String?
  public var bytes: [Swift.UInt8] {
    get
  }
  public var hexDescription: Swift.String {
    get
  }
  public init?(hex: Swift.String)
  public func getUInt(offset: Swift.Int) -> Swift.UInt16
  public func getUInt32(offset: Swift.Int) -> Swift.UInt32
  public func getFloat(offset: Swift.Int) -> Swift.Float
  public func getByte(at index: Swift.Int) -> Swift.Int8
  public func getUnsignedInteger(at index: Swift.Int, bigEndian: Swift.Bool = true) -> Swift.UInt32
  public func getUnsignedInt16(at index: Swift.Int) -> Swift.UInt16
  public func getUnsignedInt32(at index: Swift.Int, bigEndian: Swift.Bool = true) -> Swift.UInt32
  public func getUnsignedLong(at index: Swift.Int, bigEndian: Swift.Bool = true) -> Swift.UInt64
  public mutating func append(byte data: Swift.Int8)
  public mutating func append(unsignedInteger data: Swift.UInt32, bigEndian: Swift.Bool = true)
  public mutating func append(unsignedLong data: Swift.UInt64, bigEndian: Swift.Bool = true)
}
extension Foundation.Data {
  public func dataObject<T>(at index: Foundation.Data.Index = 0) -> T
  public func subdata<R>(in range: R) -> Foundation.Data where R : Swift.RangeExpression, R.Bound == Swift.Int
  public func object<T>(at offset: Swift.Int) -> T
}
extension Swift.Numeric {
  public var data: Foundation.Data {
    get
  }
}
public struct ZTMessageGeneralState : Swift.CustomStringConvertible, Swift.Codable {
  public var byte0: Swift.UInt8? {
    get
  }
  public var byte1: Swift.UInt8? {
    get
  }
  public var byte2: Swift.UInt8? {
    get
  }
  public var byte3: Swift.UInt8? {
    get
  }
  public init(bytes: [Swift.UInt8])
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension ZTCoreKit.ZTMessageGeneralState {
  public var activityStartedRight: Swift.Bool {
    get
  }
  public var activityStartedLeft: Swift.Bool {
    get
  }
  public var pairIsConnected: Swift.Bool {
    get
  }
  public var memsHasError: Swift.Bool {
    get
  }
  public var firmwareDifferent: Swift.Bool {
    get
  }
  public var actualState: ZTCoreKit.ZTDeviceActualState {
    get
  }
  public var previousState: ZTCoreKit.ZTDeviceActualState {
    get
  }
  public var description: Swift.String {
    get
  }
}
public protocol ZTServiceProtocol : AnyObject {
  static var uuid: Swift.String { get }
  static var serviceType: ZTCoreKit.ZTService.Type { get }
  static var characteristicTypes: [Swift.String : ZTCoreKit.ZTCharacteristic.Type] { get }
}
extension ZTCoreKit.ZTServiceProtocol where Self : ZTCoreKit.ZTService {
  public static var serviceType: ZTCoreKit.ZTService.Type {
    get
  }
}
public enum ZTBaseError : Swift.Equatable, Swift.Error {
  case noDeviceConnectedMainSDK
  case noDeviceConnectedZhortechBase
  case failedDownloadingRawData
  public static func == (a: ZTCoreKit.ZTBaseError, b: ZTCoreKit.ZTBaseError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ZTBaseRawDownload : Swift.Sendable {
  public var rawdataActivityKey: Swift.String {
    get
  }
  public var downloadingRight: Swift.Bool {
    get
  }
  public var downloadingLeft: Swift.Bool {
    get
  }
  public var progress: Swift.Float {
    get
  }
  public var totalBytesReceived: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ZTBaseRaw {
  public static let shared: ZTCoreKit.ZTBaseRaw
  public var active: Swift.Bool {
    get
  }
  @discardableResult
  public func switchToZhortechBase() async throws -> Swift.Bool
  @discardableResult
  public func switchToZhortechSDK1() async throws -> Swift.Bool
  @discardableResult
  public func disconnect() async throws -> Swift.Bool
  @discardableResult
  public func stopActivity() async throws -> Swift.Bool
  @discardableResult
  public func startActivity(isRawData: Swift.Bool = false) async throws -> Swift.Bool
  @discardableResult
  public func startRawData() async throws -> Swift.Bool
  @discardableResult
  public func stopRawData() async throws -> Swift.Bool
  @Sendable public func downloadRawData() -> _Concurrency.AsyncThrowingStream<ZTCoreKit.ZTBaseRawDownload, any Swift.Error>
  @objc deinit
}
public struct ZTMessageBootloaderInfo : Swift.CustomStringConvertible, Swift.Codable {
  public init(bytes: [Swift.UInt8])
  public var side: ZTCoreKit.ZTModuleSide {
    get
  }
  public var bootloaderVersion: Swift.UInt8 {
    get
  }
  public var appSupportVersion: Swift.UInt8 {
    get
  }
  public var softDeviceId: Swift.UInt8 {
    get
  }
  public var dfuState: ZTCoreKit.ZTMessageBootloaderInfo.DfuState? {
    get
  }
  public var description: Swift.String {
    get
  }
  public enum DfuState : Swift.UInt8 {
    case none
    case inProgress
    case received
    case readyForCopy
    case activation
    case done
    case error
    case validationError
    case activationError
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_inheritsConvenienceInitializers public class ZTDfuService : ZTCoreKit.ZTService, ZTCoreKit.ZTServiceProtocol {
  public static let uuid: Swift.String
  public static var characteristicTypes: [Swift.String : ZTCoreKit.ZTCharacteristic.Type]
  required public init(device: ZTCoreKit.ZTDevice, service: CoreBluetooth.CBService)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class LegacyDFUServiceInitiator : ZTCoreKit.DFUServiceInitiator {
  @objc override public func start(targetWithIdentifier uuid: Foundation.UUID) -> ZTCoreKit.DFUServiceController?
  @available(*, deprecated, message: "Use init(queue: DispatchQueue?) instead.")
  @objc override public init(centralManager: CoreBluetooth.CBCentralManager, target: CoreBluetooth.CBPeripheral)
  @objc override public init(queue: Dispatch.DispatchQueue? = nil, delegateQueue: Dispatch.DispatchQueue = super, progressQueue: Dispatch.DispatchQueue = super, loggerQueue: Dispatch.DispatchQueue = super, centralManagerOptions: [Swift.String : Any]? = nil)
  @objc deinit
}
public struct ZTBatteryLevel : ZTCoreKit.ZTNotifyDataMessage {
  public var rawData: Foundation.Data?
  public var right: Swift.UInt8
  public var left: Swift.UInt8
  public var min: Swift.UInt8 {
    get
  }
  public var description: Swift.String {
    get
  }
  public init()
  public init(data: Foundation.Data)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_inheritsConvenienceInitializers public class ZTButtonlessDfuCharacteristic : ZTCoreKit.ZTCharacteristic {
  public static let uuid: Swift.String
  open var data: Foundation.Data? {
    get
  }
  required public init(service: ZTCoreKit.ZTService, characteristic: CoreBluetooth.CBCharacteristic)
  override open func valueUpdated()
  @objc deinit
}
open class ZTHexColorTransform : ZTCoreKit.ZTTransformType {
  public typealias Object = UIKit.UIColor
  public typealias JSON = Swift.String
  public init(prefixToJSON: Swift.Bool = false, alphaToJSON: Swift.Bool = false)
  open func transformFromJSON(_ value: Any?) -> ZTCoreKit.ZTHexColorTransform.Object?
  open func transformToJSON(_ value: ZTCoreKit.ZTHexColorTransform.Object?) -> ZTCoreKit.ZTHexColorTransform.JSON?
  @objc deinit
}
extension ZTCoreKit.ZhortechActivity {
  public var stopReason: ZTCoreKit.ZhortechActivity.StopReason? {
    get
  }
  public var duration: Swift.Double {
    get
  }
  public func lastSavedChunkId(startId: Swift.Int16? = 0, lastId: Swift.Int16? = 0) async -> Swift.Int16
  public func getLastPacket() -> ZTCoreKit.ZhorthechPacket?
  public func getPacketCount() -> Swift.Int
  public func getPackets(fromId startId: Swift.Int16? = nil, toId endId: Swift.Int16? = nil, withStatus status: ZTCoreKit.ZhorthechPacket.Status? = nil) -> [ZTCoreKit.ZhorthechPacket]
  public func getPacket(with packetId: Swift.UInt16) -> ZTCoreKit.ZhorthechPacket?
  public func getPreviousPacket(beforePacket packetId: Swift.UInt16, withTimestamp timestamp: Swift.Int64) -> ZTCoreKit.ZhorthechPacket?
  public func getPacketContainingLastFirmwareVersion(packetId: Swift.UInt16, startId: Swift.UInt16? = nil) -> ZTCoreKit.ZhorthechPacket?
}
extension ZTCoreKit.ZhortechActivityActor {
  public func clearPackets() async throws
  @discardableResult
  public func setPackets(ids: [Swift.Int16]) async throws -> [ZTCoreKit.ZhorthechPacket]
  @discardableResult
  public func addPacket(packet: ZTCoreKit.ZhorthechPacket) async throws -> [ZTCoreKit.ZhorthechPacket]
  @discardableResult
  public func update(with metaData: ZTCoreKit.ZhortechActivity.MessageActivityMetadata?, serial: Swift.String?, fwVersion: Swift.String?, isCheckingMonitoredActivity: Swift.Bool) async throws -> (sucess: Swift.Bool, outsideActivityDetected: Swift.Bool)
  public func createActivity(serialNumber: Swift.String, activityType: Swift.String, fwVersion: Swift.String?, appId: Swift.String) async throws -> ZTCoreKit.ZhortechActivity
}
public enum ZTActivityMode : Swift.UInt8, Swift.Codable {
  case safety
  case walking
  case running
  case cycling
  case mobility
  case swing
  public var name: Swift.String {
    get
  }
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public func <<- <T>(left: inout T, right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
public func ->> <T>(left: T, right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
public func <<- <T>(left: inout T?, right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
public func ->> <T>(left: T?, right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
public func <<- <T>(left: inout [T], right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
public func ->> <T>(left: [T], right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
public func <<- <T>(left: inout [T]?, right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
public func ->> <T>(left: [T]?, right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
public func <<- <T>(left: inout [Swift.String : T], right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
public func ->> <T>(left: [Swift.String : T], right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
public func <<- <T>(left: inout [Swift.String : T]?, right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
public func ->> <T>(left: [Swift.String : T]?, right: ZTCoreKit.ZTMap) where T : Swift.RawRepresentable
open class ZTDateFormatterTransform : ZTCoreKit.ZTTransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.String
  final public let dateFormatter: Foundation.DateFormatter
  public init(dateFormatter: Foundation.DateFormatter)
  open func transformFromJSON(_ value: Any?) -> Foundation.Date?
  open func transformToJSON(_ value: Foundation.Date?) -> Swift.String?
  @objc deinit
}
public enum ZTDFUState : Swift.Int {
  case started
  case startedLeft
  case completedLeft
  case startedRight
  case completedRight
  case completed
  case error
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public actor ZhortechActivityActor : Swift.Sendable {
  public typealias ActualStates = ZTCoreKit.ZhortechActivity.ActualStates
  public typealias Packet = ZTCoreKit.ZhorthechPacket
  public typealias Activity = ZTCoreKit.ZhortechActivity
  public init(with uuid: Swift.String, currentActivity: ZTCoreKit.ZhortechActivity? = nil)
  final public let uuid: Swift.String
  public var currentActivity: ZTCoreKit.ZhortechActivity? {
    get
  }
  public var activityStarted: Swift.Bool {
    get
  }
  public var errors: [Swift.String] {
    get
  }
  public func update(activity: ZTCoreKit.ZhortechActivity?) async throws
  public func refreshActivity() async throws
  @discardableResult
  public func getLatestActivity(for serial: Swift.String) async throws -> ZTCoreKit.ZhortechActivity?
  public func cleanup() async throws
  public func hardReset() async throws
  public func fetchActivity(withId activtyId: Swift.String) async throws -> ZTCoreKit.ZhortechActivity?
  public func deleteActivity(withID activtyId: Swift.String) async throws
  public func resetActivity() async throws
  @objc deinit
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  @_semantics("defaultActor") nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
public struct ZhortechActivityFetchConfiguration : Swift.Sendable {
  public static let `default`: ZTCoreKit.ZhortechActivityFetchConfiguration
  public let intervalBetween2Fetches: Swift.Double
  public let packetThreshold: Swift.Int
}
open class ZTCustomDateFormatTransform : ZTCoreKit.ZTDateFormatterTransform {
  public init(formatString: Swift.String)
  @objc deinit
}
extension ZTCoreKit.ZTDevice : CoreBluetooth.CBPeripheralDelegate {
  @objc dynamic public func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didWriteValueFor descriptor: CoreBluetooth.CBDescriptor, error: (any Swift.Error)?)
  @objc dynamic public func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didDiscoverServices error: (any Swift.Error)?)
  @objc dynamic public func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didDiscoverCharacteristicsFor service: CoreBluetooth.CBService, error: (any Swift.Error)?)
  @objc dynamic public func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didUpdateValueFor characteristic: CoreBluetooth.CBCharacteristic, error: (any Swift.Error)?)
  @objc dynamic public func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didWriteValueFor characteristic: CoreBluetooth.CBCharacteristic, error: (any Swift.Error)?)
  @objc dynamic public func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didUpdateNotificationStateFor characteristic: CoreBluetooth.CBCharacteristic, error: (any Swift.Error)?)
  @objc dynamic public func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didReadRSSI RSSI: Foundation.NSNumber, error: (any Swift.Error)?)
  @objc dynamic public func peripheralDidUpdateName(_ peripheral: CoreBluetooth.CBPeripheral)
  @objc dynamic public func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didModifyServices invalidatedServices: [CoreBluetooth.CBService])
  @objc dynamic public func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didDiscoverIncludedServicesFor service: CoreBluetooth.CBService, error: (any Swift.Error)?)
  @objc dynamic public func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didDiscoverDescriptorsFor characteristic: CoreBluetooth.CBCharacteristic, error: (any Swift.Error)?)
  @objc dynamic public func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didUpdateValueFor descriptor: CoreBluetooth.CBDescriptor, error: (any Swift.Error)?)
  @objc dynamic public func peripheralIsReady(toSendWriteWithoutResponse peripheral: CoreBluetooth.CBPeripheral)
  @objc dynamic public func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didOpen channel: CoreBluetooth.CBL2CAPChannel?, error: (any Swift.Error)?)
  public func sendCommand(_ command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func sendCommandWithAck(command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil, completion: @escaping ZTCoreKit.ZTBaseResult)
  public func sendCommandWithRightAck(command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil, completion: @escaping ZTCoreKit.ZTBaseResult)
  public func sendRawCommand(bytes: [Swift.UInt8], completion: ((Swift.Bool) -> Swift.Void)? = nil)
  public func send(_ command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil) async throws
  public func sendWithAck(_ command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil) async throws
  public func sendCommandWithRightAck(_ command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil) async throws
  @discardableResult
  public func sendCommand(_ command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil) async -> Swift.Bool
  @discardableResult
  public func sendCommandWithAck(_ command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil) async -> Swift.Bool
  @discardableResult
  public func sendCommandWithStateUpdate(_ command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil, timeout: Swift.Double = 15) async throws -> ZTCoreKit.ZTDeviceActualState?
  @discardableResult
  public func sendCommandWithUpdate<T>(_ command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil, timeout: Swift.Double = 15, name: Swift.String?, signal: ZTCoreKit.ZTSignal<T>) async throws -> T?
}
extension ZTCoreKit.ZTCore {
  final public func sendToConnectedDevice(_ command: ZTCoreKit.ZTCommand, parameters: [Swift.UInt8]? = nil) async throws
}
public enum ZTNotifyData {
  public enum GroupID : Swift.UInt8 {
    case common
    case warm
    case running
    case cycling
    case safety
    case generic
    case standardize
    public var description: Swift.String {
      get
    }
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum CommonMessageId : Swift.UInt8 {
    case MSG_GENERAL_STATES
    case MSG_BATTERY_LEVEL
    case MSG_MEMS
    case MSG_FLASH
    case MSG_TIME
    case MSG_HARDWARE
    case MSG_SOFTWARE
    case MSG_ACTIVITY_INFO
    case MSG_ACTIVITY_METADATA
    case MSG_RAWDATA_HEADER
    case MSG_RAWDATA_FRAME
    case MSG_BTLOADER_INFO
    case MSG_INACTIVITY_TIMEOUT
    case MSG_CHUNK_SEND_STATUS
    case MSG_CHUNK_DATA
    case MSG_CHUNK_CONFIG
    case MSG_DEBUG
    public var description: Swift.String {
      get
    }
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
extension ZTCoreKit.ZTNotifyData {
  public enum WarmMessageId : Swift.UInt8 {
    case MSG_HEATING_TEMP_1
    case MSG_HEATING_TEMP_2
    case MSG_HEATING_STEP_R_CNT
    case MSG_HEATING_STEP_L_CNT
    case MSG_HEATING_SETPOINT_R
    case MSG_HEATING_SETPOINT_L
    case MSG_GET_HEAT_TIMER
    case MSG_HEATING_DEBUG_R
    case MSG_HEATING_DEBUG_L
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
extension ZTCoreKit.ZTNotifyData {
  public enum RunningMessageId : Swift.UInt8 {
    case UNKNOWN
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
extension ZTCoreKit.ZTNotifyData {
  public enum CyclingMessageId : Swift.UInt8 {
    case MSG_CADENCE
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
extension ZTCoreKit.ZTNotifyData {
  public enum SafetyMessageId : Swift.UInt8 {
    case MSG_CALIBRATION_SAFETY
    case MSG_ALGO_RT_EVENT
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
extension ZTCoreKit.ZTNotifyData {
  public enum GenericMessageId : Swift.UInt8 {
    case MSG_ALGO_RT_EVENT
    public var description: Swift.String {
      get
    }
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum StandardizeMessageId : Swift.UInt8 {
    case MSG_GET_DEVICE_PUBKEY
    public var description: Swift.String {
      get
    }
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
public enum ZTDeviceActualState : Swift.UInt8, Swift.Codable {
  case activityNone
  case activityStarting
  case eraseMemory
  case activityRunning
  case activityPaused
  case activityStopping
  case activityPendData
  case activitySendData
  case unknown
  public var description: Swift.String {
    get
  }
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension ZTCoreKit.ZTCore {
  final public func initiateBackgroundDFU(isRestartRequired: Swift.Bool = false, isManualMode: Swift.Bool = false)
  final public func initiateBackgroundDFU(path: Swift.String, isManualMode: Swift.Bool = false)
  final public func isFirmwareUpdateRequired(firmwareRevision: ZTCoreKit.ZTFirmwareRevision, completion: @escaping (Swift.Bool, ZTCoreKit.ZTError?) -> Swift.Void)
}
@_hasMissingDesignatedInitializers final public class ZTLogger {
  public static let instance: ZTCoreKit.ZTLogger
  final public var indent: Swift.UInt
  @objc deinit
}
extension ZTCoreKit.ZTLogger : ZTCoreKit.ZhortechLoggerProtocol {
  final public func ztDebugPrint(_ message: Swift.String)
  final public func debug(_ message: Swift.StaticString, _ args: any Swift.CVarArg...)
  final public func info(_ message: Swift.StaticString, _ args: any Swift.CVarArg...)
  final public func error(_ message: Swift.StaticString, _ args: any Swift.CVarArg...)
  final public func fatal(_ message: Swift.StaticString, _ args: any Swift.CVarArg...)
}
public struct ZTLoggerLine : Swift.Codable {
  public static let notification: Foundation.Notification.Name
  public static let ble: Foundation.Notification.Name
  public var date: Foundation.Date
  public let message: Swift.String
  public let level: Swift.String
  public let category: Swift.String
  public init(message: Swift.String, level: ZTCoreKit.ZTLogLevel, category: ZTCoreKit.ZTLogCategory)
  public func post()
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@objc @_hasMissingDesignatedInitializers final public class ZTBleManager : ObjectiveC.NSObject {
  final public var advertisingServices: [CoreBluetooth.CBUUID]?
  final public var managerState: ZTCoreKit.ZTBleManagerState {
    get
    set
  }
  final public class var instance: ZTCoreKit.ZTBleManager {
    get
  }
  final public var centralManager: (any ZTCoreKit.ZTCBCentralManagerProtocol)! {
    get
  }
  final public var macAddress: Swift.String? {
    get
  }
  final public var deviceInfo: ZTCoreKit.ZTDeviceInfo?
  final public var serviceTypes: [Swift.String : ZTCoreKit.ZTService.Type] {
    get
  }
  final public var product: ZTCoreKit.ZTProductType? {
    get
    set
  }
  final public var connectedDevice: ZTCoreKit.ZTDevice? {
    get
  }
  final public var foundPeripherals: [CoreBluetooth.CBPeripheral] {
    get
    set
  }
  final public func appendFoundPeripheral(_ peripheral: CoreBluetooth.CBPeripheral)
  final public func removeAllFoundPeripherals()
  final public var scanning: Swift.Bool {
    get
  }
  final public var isDfuMode: Swift.Bool {
    get
  }
  final public let onAuthorizationChange: ZTCoreKit.ZTSignal<CoreBluetooth.CBManagerAuthorization>
  final public let onBluetoothStateChange: ZTCoreKit.ZTSignal<CoreBluetooth.CBManagerState>
  final public let onDeviceStateChange: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTDevice?, (any Swift.Error)?)>
  final public let onDeviceDiscovered: ZTCoreKit.ZTSignal<ZTCoreKit.ZTDevice>
  final public let onDeviceConnectionFailed: ZTCoreKit.ZTSignal<(ZTCoreKit.ZTDevice?, (any Swift.Error)?)>
  final public let onScanFinished: ZTCoreKit.ZTSignal<(any Swift.Error)?>
  final public let onReconnectFailed: ZTCoreKit.ZTSignal<(any Swift.Error)?>
  final public let onGeneralStateUpdated: ZTCoreKit.ZTSignal<ZTCoreKit.ZTMessageGeneralState>
  final public let onCommandAck: ZTCoreKit.ZTSignal<ZTCoreKit.ZTCommandResponse?>
  public init(background: Swift.Bool = false)
  @objc deinit
}
extension ZTCoreKit.ZTBleManager : CoreBluetooth.CBCentralManagerDelegate {
  @objc final public func centralManager(_ central: CoreBluetooth.CBCentralManager, willRestoreState dict: [Swift.String : Any])
  @objc final public func centralManager(_ central: CoreBluetooth.CBCentralManager, connectionEventDidOccur event: CoreBluetooth.CBConnectionEvent, for peripheral: CoreBluetooth.CBPeripheral)
  @objc final public func centralManager(_ central: CoreBluetooth.CBCentralManager, didDiscover peripheral: CoreBluetooth.CBPeripheral, advertisementData: [Swift.String : Any], rssi RSSI: Foundation.NSNumber)
  @objc final public func centralManager(_ central: CoreBluetooth.CBCentralManager, didFailToConnect peripheral: CoreBluetooth.CBPeripheral, error: (any Swift.Error)?)
  @objc final public func centralManager(_ central: CoreBluetooth.CBCentralManager, didConnect peripheral: CoreBluetooth.CBPeripheral)
  @objc final public func centralManager(_ central: CoreBluetooth.CBCentralManager, didDisconnectPeripheral peripheral: CoreBluetooth.CBPeripheral, error: (any Swift.Error)?)
  @objc final public func centralManagerDidUpdateState(_ central: CoreBluetooth.CBCentralManager)
}
@_inheritsConvenienceInitializers @objc(ZTActivity) public class ZTActivity : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension ZTCoreKit.ZTActivity {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<ZTCoreKit.ZTActivity>
  @objc @NSManaged dynamic public var activityIdentifier: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var activityType: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var anchorTimestamp: Swift.Int64 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var appId: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var chunkCount: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var customActivityFirstChunkId: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var customActivityStartTimestamp: Swift.Int64 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var endDate: Foundation.Date? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var endTimestamp: Swift.Int64 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var firstChunkId: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var forceStop: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var fwVersion: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var id: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var invalid: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var isAutomatic: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var isInterrupted: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var isRawDataMode: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var lastChunkId: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var metaDataRawValue: Foundation.Data? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var shoesSerial: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var startDate: Foundation.Date? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var startTimestamp: Swift.Int64 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var status: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var stopReasonRawValue: Foundation.Data? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var tz: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var packets: Foundation.NSSet? {
    @objc get
    @objc set
  }
}
extension ZTCoreKit.ZTActivity {
  @objc(addPacketsObject:) @NSManaged dynamic public func addToPackets(_ value: ZTCoreKit.ZTPacket)
  @objc(removePacketsObject:) @NSManaged dynamic public func removeFromPackets(_ value: ZTCoreKit.ZTPacket)
  @objc(addPackets:) @NSManaged dynamic public func addToPackets(_ values: Foundation.NSSet)
  @objc(removePackets:) @NSManaged dynamic public func removeFromPackets(_ values: Foundation.NSSet)
}
extension ZTCoreKit.ZTActivity : Swift.Identifiable {
  public typealias ID = Swift.String?
}
@_inheritsConvenienceInitializers @objc(ZTPacket) public class ZTPacket : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension ZTCoreKit.ZTPacket {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<ZTCoreKit.ZTPacket>
  @objc @NSManaged dynamic public var activityTypeRawValue: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var bmTimestampTypeRawValue: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var createdAt: Foundation.Date? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var duration: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var fulfilledAt: Foundation.Date? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var fwVersion: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var id: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var originalTimestamp: Swift.Int64 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var packetsNumber: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var packetTypeRawValue: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var rawData: Foundation.Data? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var retryCount: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var scheduledDeleted: Foundation.Date? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var sentAt: Foundation.Date? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var statusRawValue: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var timestamp: Swift.Int64 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var timestampTypeRawValue: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var activity: ZTCoreKit.ZTActivity? {
    @objc get
    @objc set
  }
}
extension ZTCoreKit.ZTPacket : Swift.Identifiable {
  public typealias ID = Swift.Int16
}
extension ZTCoreKit.ZTMessageChunkSendStatus.Status : Swift.Equatable {}
extension ZTCoreKit.ZTMessageChunkSendStatus.Status : Swift.Hashable {}
extension ZTCoreKit.ZTMessageChunkSendStatus.Status : Swift.RawRepresentable {}
extension ZTCoreKit.ZTAlgoPrecisionMode : Swift.Equatable {}
extension ZTCoreKit.ZTAlgoPrecisionMode : Swift.Hashable {}
extension ZTCoreKit.ZTAlgoPrecisionMode : Swift.RawRepresentable {}
extension ZTCoreKit.ZTAlgoAcknowledgmentStatus : Swift.Equatable {}
extension ZTCoreKit.ZTAlgoAcknowledgmentStatus : Swift.Hashable {}
extension ZTCoreKit.ZTAlgoAcknowledgmentStatus : Swift.RawRepresentable {}
extension ZTCoreKit.ZTRealtimeSide : Swift.Equatable {}
extension ZTCoreKit.ZTRealtimeSide : Swift.Hashable {}
extension ZTCoreKit.ZTRealtimeSide : Swift.RawRepresentable {}
extension ZTCoreKit.ZTRealtimeMessage.Event.EventType : Swift.Equatable {}
extension ZTCoreKit.ZTRealtimeMessage.Event.EventType : Swift.Hashable {}
extension ZTCoreKit.ZTRealtimeMessage.Event.EventType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTRealtimeMessage.Event.MotionId : Swift.Equatable {}
extension ZTCoreKit.ZTRealtimeMessage.Event.MotionId : Swift.Hashable {}
extension ZTCoreKit.ZTRealtimeMessage.Event.MotionId : Swift.RawRepresentable {}
extension ZTCoreKit.ZTRealtimeMessage.Event.MotionIntensity : Swift.Equatable {}
extension ZTCoreKit.ZTRealtimeMessage.Event.MotionIntensity : Swift.Hashable {}
extension ZTCoreKit.ZTRealtimeMessage.Event.MotionIntensity : Swift.RawRepresentable {}
extension ZTCoreKit.DFUStreamHexError : Swift.Equatable {}
extension ZTCoreKit.DFUStreamHexError : Swift.Hashable {}
extension ZTCoreKit.DFUError : Swift.Equatable {}
extension ZTCoreKit.DFUError : Swift.Hashable {}
extension ZTCoreKit.DFUError : Swift.RawRepresentable {}
extension ZTCoreKit.DFUState : Swift.Equatable {}
extension ZTCoreKit.DFUState : Swift.Hashable {}
extension ZTCoreKit.DFUState : Swift.RawRepresentable {}
extension ZTCoreKit.ZTPeriod : Swift.Equatable {}
extension ZTCoreKit.ZTPeriod : Swift.Hashable {}
extension ZTCoreKit.ZTPeriod : Swift.RawRepresentable {}
extension ZTCoreKit.ZTTXPower : Swift.Equatable {}
extension ZTCoreKit.ZTTXPower : Swift.Hashable {}
extension ZTCoreKit.ZTTXPower : Swift.RawRepresentable {}
extension ZTCoreKit.ZTDateDefaultTransform.Unit : Swift.Equatable {}
extension ZTCoreKit.ZTDateDefaultTransform.Unit : Swift.Hashable {}
extension ZTCoreKit.ZTDateDefaultTransform.Unit : Swift.RawRepresentable {}
extension ZTCoreKit.ZTLogLevel : Swift.Equatable {}
extension ZTCoreKit.ZTLogLevel : Swift.Hashable {}
extension ZTCoreKit.ZTLogLevel : Swift.RawRepresentable {}
extension ZTCoreKit.ZTLogCategory : Swift.Equatable {}
extension ZTCoreKit.ZTLogCategory : Swift.Hashable {}
extension ZTCoreKit.ZTLogCategory : Swift.RawRepresentable {}
extension ZTCoreKit.ZTBleManagerState : Swift.Equatable {}
extension ZTCoreKit.ZTBleManagerState : Swift.Hashable {}
extension ZTCoreKit.ZTError.Enums.ScanningError : Swift.Equatable {}
extension ZTCoreKit.ZTError.Enums.ScanningError : Swift.Hashable {}
extension ZTCoreKit.ZTError.Enums.BleError : Swift.Equatable {}
extension ZTCoreKit.ZTError.Enums.BleError : Swift.Hashable {}
extension ZTCoreKit.ZTError.Enums.FirmwareError : Swift.Equatable {}
extension ZTCoreKit.ZTError.Enums.FirmwareError : Swift.Hashable {}
extension ZTCoreKit.ZTError.Enums.DfuError : Swift.Equatable {}
extension ZTCoreKit.ZTError.Enums.DfuError : Swift.Hashable {}
extension ZTCoreKit.ZTError.Enums.ActivityError : Swift.Equatable {}
extension ZTCoreKit.ZTError.Enums.ActivityError : Swift.Hashable {}
extension ZTCoreKit.ZTError.Enums.DecodableError : Swift.Equatable {}
extension ZTCoreKit.ZTError.Enums.DecodableError : Swift.Hashable {}
extension ZTCoreKit.ZTProductType : Swift.Equatable {}
extension ZTCoreKit.ZTProductType : Swift.Hashable {}
extension ZTCoreKit.ZTProductType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTProjectCodeType : Swift.Equatable {}
extension ZTCoreKit.ZTProjectCodeType : Swift.Hashable {}
extension ZTCoreKit.ZTProjectCodeType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTProductCodeType : Swift.Equatable {}
extension ZTCoreKit.ZTProductCodeType : Swift.Hashable {}
extension ZTCoreKit.ZTProductCodeType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTManufacturerCodeType : Swift.Equatable {}
extension ZTCoreKit.ZTManufacturerCodeType : Swift.Hashable {}
extension ZTCoreKit.ZTManufacturerCodeType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTProductTypeCode : Swift.Equatable {}
extension ZTCoreKit.ZTProductTypeCode : Swift.Hashable {}
extension ZTCoreKit.ZTProductTypeCode : Swift.RawRepresentable {}
extension ZTCoreKit.ZTGenderCodeType : Swift.Equatable {}
extension ZTCoreKit.ZTGenderCodeType : Swift.Hashable {}
extension ZTCoreKit.ZTGenderCodeType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTGenderSizeCodeType : Swift.Equatable {}
extension ZTCoreKit.ZTGenderSizeCodeType : Swift.Hashable {}
extension ZTCoreKit.ZTGenderSizeCodeType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTUnitSizeCodeType : Swift.Equatable {}
extension ZTCoreKit.ZTUnitSizeCodeType : Swift.Hashable {}
extension ZTCoreKit.ZTUnitSizeCodeType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTCommand : Swift.Equatable {}
extension ZTCoreKit.ZTCommand : Swift.Hashable {}
extension ZTCoreKit.ZTCommand : Swift.RawRepresentable {}
extension ZTCoreKit.ZTActivitySummaryStatus : Swift.Equatable {}
extension ZTCoreKit.ZTActivitySummaryStatus : Swift.Hashable {}
extension ZTCoreKit.ZTActivitySummaryStatus : Swift.RawRepresentable {}
extension ZTCoreKit.ZTAlgoState : Swift.Equatable {}
extension ZTCoreKit.ZTAlgoState : Swift.Hashable {}
extension ZTCoreKit.ZTAlgoState : Swift.RawRepresentable {}
extension ZTCoreKit.ZTAlgoCommand : Swift.Equatable {}
extension ZTCoreKit.ZTAlgoCommand : Swift.Hashable {}
extension ZTCoreKit.ZTAlgoCommand : Swift.RawRepresentable {}
extension ZTCoreKit.ZTRealtimeMessageEventType : Swift.Equatable {}
extension ZTCoreKit.ZTRealtimeMessageEventType : Swift.Hashable {}
extension ZTCoreKit.ZTRealtimeMessageEventType : Swift.RawRepresentable {}
extension ZTCoreKit.DFUStreamZipError : Swift.Equatable {}
extension ZTCoreKit.DFUStreamZipError : Swift.Hashable {}
extension ZTCoreKit.DFUFirmwareType : Swift.Equatable {}
extension ZTCoreKit.DFUFirmwareType : Swift.Hashable {}
extension ZTCoreKit.DFUFirmwareType : Swift.RawRepresentable {}
extension ZTCoreKit.DFUFirmwareError.FileType : Swift.Equatable {}
extension ZTCoreKit.DFUFirmwareError.FileType : Swift.Hashable {}
extension ZTCoreKit.ZhortechActivity.ActualStates : Swift.Equatable {}
extension ZTCoreKit.ZhortechActivity.ActualStates : Swift.Hashable {}
extension ZTCoreKit.ZhortechActivity.ActualStates : Swift.RawRepresentable {}
extension ZTCoreKit.ZhortechActivity.StopReason : Swift.Equatable {}
extension ZTCoreKit.ZhortechActivity.StopReason : Swift.Hashable {}
extension ZTCoreKit.ZhortechActivity.StopReason : Swift.RawRepresentable {}
extension ZTCoreKit.ZTLoggerComponent : Swift.Equatable {}
extension ZTCoreKit.ZTLoggerComponent : Swift.Hashable {}
extension ZTCoreKit.ZTLoggerComponent : Swift.RawRepresentable {}
extension ZTCoreKit.ZTLoggerSeverity : Swift.Equatable {}
extension ZTCoreKit.ZTLoggerSeverity : Swift.Hashable {}
extension ZTCoreKit.ZTLoggerSeverity : Swift.RawRepresentable {}
extension ZTCoreKit.ZTMessageChunkData.Mode : Swift.Equatable {}
extension ZTCoreKit.ZTMessageChunkData.Mode : Swift.Hashable {}
extension ZTCoreKit.ZTMessageChunkData.Mode : Swift.RawRepresentable {}
extension ZTCoreKit.ZTDfuPackageType : Swift.Equatable {}
extension ZTCoreKit.ZTDfuPackageType : Swift.Hashable {}
extension ZTCoreKit.ZTDfuPackageType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTServices.Primary.Characteristic : Swift.Equatable {}
extension ZTCoreKit.ZTServices.Primary.Characteristic : Swift.Hashable {}
extension ZTCoreKit.ZTServices.PrimaryOld.Characteristic : Swift.Equatable {}
extension ZTCoreKit.ZTServices.PrimaryOld.Characteristic : Swift.Hashable {}
extension ZTCoreKit.ZTServices.DeviceInformation.Characteristic : Swift.Equatable {}
extension ZTCoreKit.ZTServices.DeviceInformation.Characteristic : Swift.Hashable {}
extension ZTCoreKit.ZTServices.DeviceDFU.Characteristic : Swift.Equatable {}
extension ZTCoreKit.ZTServices.DeviceDFU.Characteristic : Swift.Hashable {}
extension ZTCoreKit.ZTSamplingMode : Swift.Equatable {}
extension ZTCoreKit.ZTSamplingMode : Swift.Hashable {}
extension ZTCoreKit.ZTSamplingMode : Swift.RawRepresentable {}
extension ZTCoreKit.ZTCommandStatus : Swift.Equatable {}
extension ZTCoreKit.ZTCommandStatus : Swift.Hashable {}
extension ZTCoreKit.ZTCommandStatus : Swift.RawRepresentable {}
extension ZTCoreKit.ZTActivityLastStopReason : Swift.Equatable {}
extension ZTCoreKit.ZTActivityLastStopReason : Swift.Hashable {}
extension ZTCoreKit.ZTActivityLastStopReason : Swift.RawRepresentable {}
extension ZTCoreKit.ZTAlgoStatus : Swift.Equatable {}
extension ZTCoreKit.ZTAlgoStatus : Swift.Hashable {}
extension ZTCoreKit.ZTAlgoStatus : Swift.RawRepresentable {}
extension ZTCoreKit.ZhorthechPacket.Status : Swift.Hashable {}
extension ZTCoreKit.ZhorthechPacket.Status : Swift.RawRepresentable {}
extension ZTCoreKit.ZhorthechPacket.TimestampType : Swift.Equatable {}
extension ZTCoreKit.ZhorthechPacket.TimestampType : Swift.Hashable {}
extension ZTCoreKit.ZhorthechPacket.TimestampType : Swift.RawRepresentable {}
extension ZTCoreKit.ZhorthechPacket.BmTimestampType : Swift.Equatable {}
extension ZTCoreKit.ZhorthechPacket.BmTimestampType : Swift.Hashable {}
extension ZTCoreKit.ZhorthechPacket.BmTimestampType : Swift.RawRepresentable {}
extension ZTCoreKit.ZhorthechPacket.PacketType : Swift.Equatable {}
extension ZTCoreKit.ZhorthechPacket.PacketType : Swift.Hashable {}
extension ZTCoreKit.ZhorthechPacket.PacketType : Swift.RawRepresentable {}
extension ZTCoreKit.ZhorthechPacket.Mode : Swift.Equatable {}
extension ZTCoreKit.ZhorthechPacket.Mode : Swift.Hashable {}
extension ZTCoreKit.ZhorthechPacket.Mode : Swift.RawRepresentable {}
extension ZTCoreKit.ZTAlgoMode : Swift.Equatable {}
extension ZTCoreKit.ZTAlgoMode : Swift.Hashable {}
extension ZTCoreKit.ZTAlgoMode : Swift.RawRepresentable {}
extension ZTCoreKit.ZTActivityType : Swift.Equatable {}
extension ZTCoreKit.ZTActivityType : Swift.Hashable {}
extension ZTCoreKit.ZTActivityType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTRealtimeMetric : Swift.Equatable {}
extension ZTCoreKit.ZTRealtimeMetric : Swift.Hashable {}
extension ZTCoreKit.ZTRealtimeMetric : Swift.RawRepresentable {}
extension ZTCoreKit.ZTMappingType : Swift.Equatable {}
extension ZTCoreKit.ZTMappingType : Swift.Hashable {}
extension ZTCoreKit.ZTRealtimeMessage.Side : Swift.Equatable {}
extension ZTCoreKit.ZTRealtimeMessage.Side : Swift.Hashable {}
extension ZTCoreKit.ZTRealtimeMessage.Side : Swift.RawRepresentable {}
extension ZTCoreKit.LogLevel : Swift.Equatable {}
extension ZTCoreKit.LogLevel : Swift.Hashable {}
extension ZTCoreKit.LogLevel : Swift.RawRepresentable {}
extension ZTCoreKit.ZTReachability.Adapter : Swift.Hashable {}
extension ZTCoreKit.DFUUuidType : Swift.Equatable {}
extension ZTCoreKit.DFUUuidType : Swift.Hashable {}
extension ZTCoreKit.DFUUuidType : Swift.RawRepresentable {}
extension ZTCoreKit.ZTEnvironment : Swift.Equatable {}
extension ZTCoreKit.ZTEnvironment : Swift.Hashable {}
extension ZTCoreKit.ZTModuleSide : Swift.Equatable {}
extension ZTCoreKit.ZTModuleSide : Swift.Hashable {}
extension ZTCoreKit.ZTModuleSide : Swift.RawRepresentable {}
extension ZTCoreKit.ZTBaseError : Swift.Hashable {}
extension ZTCoreKit.ZTMessageBootloaderInfo.DfuState : Swift.Equatable {}
extension ZTCoreKit.ZTMessageBootloaderInfo.DfuState : Swift.Hashable {}
extension ZTCoreKit.ZTMessageBootloaderInfo.DfuState : Swift.RawRepresentable {}
extension ZTCoreKit.ZTActivityMode : Swift.Equatable {}
extension ZTCoreKit.ZTActivityMode : Swift.Hashable {}
extension ZTCoreKit.ZTActivityMode : Swift.RawRepresentable {}
extension ZTCoreKit.ZTDFUState : Swift.Equatable {}
extension ZTCoreKit.ZTDFUState : Swift.Hashable {}
extension ZTCoreKit.ZTDFUState : Swift.RawRepresentable {}
extension ZTCoreKit.ZTNotifyData.GroupID : Swift.Equatable {}
extension ZTCoreKit.ZTNotifyData.GroupID : Swift.Hashable {}
extension ZTCoreKit.ZTNotifyData.GroupID : Swift.RawRepresentable {}
extension ZTCoreKit.ZTNotifyData.CommonMessageId : Swift.Equatable {}
extension ZTCoreKit.ZTNotifyData.CommonMessageId : Swift.Hashable {}
extension ZTCoreKit.ZTNotifyData.CommonMessageId : Swift.RawRepresentable {}
extension ZTCoreKit.ZTNotifyData.WarmMessageId : Swift.Equatable {}
extension ZTCoreKit.ZTNotifyData.WarmMessageId : Swift.Hashable {}
extension ZTCoreKit.ZTNotifyData.WarmMessageId : Swift.RawRepresentable {}
extension ZTCoreKit.ZTNotifyData.RunningMessageId : Swift.Equatable {}
extension ZTCoreKit.ZTNotifyData.RunningMessageId : Swift.Hashable {}
extension ZTCoreKit.ZTNotifyData.RunningMessageId : Swift.RawRepresentable {}
extension ZTCoreKit.ZTNotifyData.CyclingMessageId : Swift.Equatable {}
extension ZTCoreKit.ZTNotifyData.CyclingMessageId : Swift.Hashable {}
extension ZTCoreKit.ZTNotifyData.CyclingMessageId : Swift.RawRepresentable {}
extension ZTCoreKit.ZTNotifyData.SafetyMessageId : Swift.Equatable {}
extension ZTCoreKit.ZTNotifyData.SafetyMessageId : Swift.Hashable {}
extension ZTCoreKit.ZTNotifyData.SafetyMessageId : Swift.RawRepresentable {}
extension ZTCoreKit.ZTNotifyData.GenericMessageId : Swift.Equatable {}
extension ZTCoreKit.ZTNotifyData.GenericMessageId : Swift.Hashable {}
extension ZTCoreKit.ZTNotifyData.GenericMessageId : Swift.RawRepresentable {}
extension ZTCoreKit.ZTNotifyData.StandardizeMessageId : Swift.Equatable {}
extension ZTCoreKit.ZTNotifyData.StandardizeMessageId : Swift.Hashable {}
extension ZTCoreKit.ZTNotifyData.StandardizeMessageId : Swift.RawRepresentable {}
extension ZTCoreKit.ZTDeviceActualState : Swift.Equatable {}
extension ZTCoreKit.ZTDeviceActualState : Swift.Hashable {}
extension ZTCoreKit.ZTDeviceActualState : Swift.RawRepresentable {}
