#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 6.2 effective-5.10 (swiftlang-6.2.0.19.9 clang-1700.3.19.1)
#ifndef ZTCOREKIT_SWIFT_H
#define ZTCOREKIT_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wnon-modular-include-in-framework-module"
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#pragma clang diagnostic pop
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef unsigned char char8_t;
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreBluetooth;
@import CoreData;
@import Dispatch;
@import Foundation;
@import ObjectiveC;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="ZTCoreKit",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)

/// A DFU error enumeration.
typedef SWIFT_ENUM(NSInteger, DFUError, open) {
/// Legacy DFU bootloader reported success.
  DFUErrorRemoteLegacyDFUSuccess = 1,
/// Legacy DFU bootloader is in invalid state.
  DFUErrorRemoteLegacyDFUInvalidState = 2,
/// Requested operation is not supported.
  DFUErrorRemoteLegacyDFUNotSupported = 3,
/// The firmware size exceeds limit.
  DFUErrorRemoteLegacyDFUDataExceedsLimit = 4,
/// A CRC (checksum) error.
  DFUErrorRemoteLegacyDFUCrcError = 5,
/// Operation failed for an unknown reason.
  DFUErrorRemoteLegacyDFUOperationFailed = 6,
/// Secure DFU bootloader reported success.
  DFUErrorRemoteSecureDFUSuccess = 11,
/// Requested Op Code is not supported.
  DFUErrorRemoteSecureDFUOpCodeNotSupported = 12,
/// Invalid parameter.
  DFUErrorRemoteSecureDFUInvalidParameter = 13,
/// Secure DFU bootloader cannot complete due to insufficient resources.
  DFUErrorRemoteSecureDFUInsufficientResources = 14,
/// The object is invalid.
  DFUErrorRemoteSecureDFUInvalidObject = 15,
/// Firmware signature is invalid.
  DFUErrorRemoteSecureDFUSignatureMismatch = 16,
/// Requested type is not supported.
  DFUErrorRemoteSecureDFUUnsupportedType = 17,
/// Requested operation is not permitted.
  DFUErrorRemoteSecureDFUOperationNotPermitted = 18,
/// Operation failed for an unknown reason.
  DFUErrorRemoteSecureDFUOperationFailed = 20,
/// The Secure DFU bootloader reported a detailed error.
/// note:
/// This error is not reported to the app. Instead, the library will
/// return one of the <code>remoteExtendedError...</code> errors.
  DFUErrorRemoteSecureDFUExtendedError = 21,
/// The format of the command was incorrect.
/// This error code is not used in the current implementation, because
/// <code>remoteSecureDFUOpCodeNotSupported</code> and
/// <code>remoteSecureDFUInvalidParameter</code> cover all possible format errors.
  DFUErrorRemoteExtendedErrorWrongCommandFormat = 22,
/// The command was successfully parsed, but it is not supported or unknown.
  DFUErrorRemoteExtendedErrorUnknownCommand = 23,
/// The init command is invalid.
/// The init packet either has an invalid update type or it is missing required fields for
/// the update type (for example, the init packet for a SoftDevice update is missing the
/// SoftDevice size field).
  DFUErrorRemoteExtendedErrorInitCommandInvalid = 24,
/// The firmware version is too low.
/// For an application or SoftDevice, the version must be greater than or equal to the
/// current version. For a bootloader, it must be greater than the current version.
/// This requirement prevents downgrade attacks.
  DFUErrorRemoteExtendedErrorFwVersionFailure = 25,
/// The hardware version of the device does not match the required hardware version
/// for the update.
/// This error may be thrown if a user tries to update a wrong device.
  DFUErrorRemoteExtendedErrorHwVersionFailure = 26,
/// The array of supported SoftDevices for the update does not contain the FWID
/// of the current SoftDevice or the first FWID is ‘0’ on a bootloader which requires
/// the SoftDevice to be present.
  DFUErrorRemoteExtendedErrorSdVersionFailure = 27,
/// The init packet does not contain a signature.
/// This error code is not used in the current implementation, because init packets
/// without a signature are regarded as invalid.
  DFUErrorRemoteExtendedErrorSignatureMissing = 28,
/// The hash type that is specified by the init packet is not supported by the DFU bootloader.
  DFUErrorRemoteExtendedErrorWrongHashType = 29,
/// The hash of the firmware image cannot be calculated.
  DFUErrorRemoteExtendedErrorHashFailed = 30,
/// The type of the signature is unknown or not supported by the DFU bootloader.
  DFUErrorRemoteExtendedErrorWrongSignatureType = 31,
/// The hash of the received firmware image does not match the hash in the init packet.
  DFUErrorRemoteExtendedErrorVerificationFailed = 32,
/// The available space on the device is insufficient to hold the firmware.
  DFUErrorRemoteExtendedErrorInsufficientSpace = 33,
/// Experimental Buttonless DFU service reported success.
  DFUErrorRemoteExperimentalButtonlessDFUSuccess = 9001,
/// The Op Code is not supported.
  DFUErrorRemoteExperimentalButtonlessDFUOpCodeNotSupported = 9002,
/// Jumping to bootloader mode failed.
  DFUErrorRemoteExperimentalButtonlessDFUOperationFailed = 9004,
/// Buttonless DFU service reported success.
  DFUErrorRemoteButtonlessDFUSuccess = 91,
/// The Op Code is not supported.
  DFUErrorRemoteButtonlessDFUOpCodeNotSupported = 92,
/// Jumping to bootloader mode failed.
  DFUErrorRemoteButtonlessDFUOperationFailed = 94,
/// The requested advertising name is invalid.
/// Maximum length for the name is 20 bytes..
  DFUErrorRemoteButtonlessDFUInvalidAdvertisementName = 95,
/// The service is busy.
  DFUErrorRemoteButtonlessDFUBusy = 96,
/// The Buttonless service requires the device to be bonded.
  DFUErrorRemoteButtonlessDFUNotBonded = 97,
/// Providing the DFUFirmware is required.
  DFUErrorFileNotSpecified = 101,
/// Given firmware file is not supported.
  DFUErrorFileInvalid = 102,
/// Since SDK 7.0.0 the DFU Bootloader requires the extended Init Packet.
/// For more details, see <a href="http://infocenter.nordicsemi.com/topic/com.nordic.infocenter.sdk5.v11.0.0/bledfu_example_init.html?cp=4_0_0_4_2_1_1_3">Infocenter</a>.
  DFUErrorExtendedInitPacketRequired = 103,
/// The Init packet is required and has not been found.
/// Before SDK 7.0.0 the init packet could have contained only 2-byte CRC
/// value, and was optional. Providing an extended one instead would cause
/// CRC error during validation (the bootloader assumes that the 2 first
/// bytes of the init packet are the firmware CRC).
  DFUErrorInitPacketRequired = 104,
/// The DFU service failed to connect to the target peripheral.
  DFUErrorFailedToConnect = 201,
/// The DFU target disconnected unexpectedly.
  DFUErrorDeviceDisconnected = 202,
/// Bluetooth adapter is disabled.
  DFUErrorBluetoothDisabled = 203,
/// Service discovery has failed.
  DFUErrorServiceDiscoveryFailed = 301,
/// The selected device does not support Legacy or Secure DFU
/// or any of Buttonless services.
  DFUErrorDeviceNotSupported = 302,
/// Reading DFU version characteristic has failed.
  DFUErrorReadingVersionFailed = 303,
/// Enabling Control Point notifications failed.
  DFUErrorEnablingControlPointFailed = 304,
/// Writing a characteristic has failed.
  DFUErrorWritingCharacteristicFailed = 305,
/// There was an error reported for a notification.
  DFUErrorReceivingNotificationFailed = 306,
/// Received response is not supported.
  DFUErrorUnsupportedResponse = 307,
/// Error raised during upload when the number of bytes sent is not equal to
/// number of bytes confirmed in Packet Receipt Notification.
  DFUErrorBytesLost = 308,
/// Error raised when the CRC reported by the remote device does not match.
/// Service has done 3 attempts to send the data.
  DFUErrorCrcError = 309,
/// The service went into an invalid state. The service will try to close
/// without crashing. Recovery to a know state is not possible.
  DFUErrorInvalidInternalState = 500,
};

@class NSString;
@class NSURL;
@class DFUFirmwareSize;
enum DFUFirmwareType : uint8_t;
@class NSData;
/// The DFU Firmware object wraps the firmware file and provides access to its content.
SWIFT_CLASS("_TtC9ZTCoreKit11DFUFirmware")
@interface DFUFirmware : NSObject
/// The name of the firmware file.
@property (nonatomic, readonly, copy) NSString * _Nullable fileName;
/// The URL to the firmware file.
@property (nonatomic, readonly, copy) NSURL * _Nullable fileUrl;
/// Information whether the firmware was successfully initialized.
@property (nonatomic, readonly) BOOL valid;
/// The size of each component of the firmware.
@property (nonatomic, readonly, strong) DFUFirmwareSize * _Nonnull size;
/// Number of connections required to transfer the firmware.
/// If a ZIP file contains a new firmware for the SoftDevice (and/or Bootloader)
/// and the Application, the number of parts is equal to 2. Otherwise this is
/// always 1.
@property (nonatomic, readonly) NSInteger parts;
/// Creates the DFU Firmware object from a Distribution packet (ZIP).
/// Such file must contain a manifest.json file with firmware metadata and at
/// least one firmware binaries. Read more about the Distribution packet on
/// the DFU documentation.
/// \param urlToZipFile URL to the Distribution packet (ZIP).
///
///
/// throws:
/// <code>DFUFirmwareError</code> if the file is invalid, or
/// <code>DFUStreamZipError</code> if creating a Zip stream failed.
///
/// returns:
/// The DFU firmware object or <code>nil</code> in case of an error.
- (nullable instancetype)initWithUrlToZipFile:(NSURL * _Nonnull)urlToZipFile error:(NSError * _Nullable * _Nullable)error;
/// Creates the DFU Firmware object from a Distribution packet (ZIP).
/// Such file must contain a manifest.json file with firmware metadata and at
/// least one firmware binaries. Read more about the Distribution packet on
/// the DFU documentation.
/// \param urlToZipFile URL to the Distribution packet (ZIP).
///
/// \param type The type of the firmware to use.
///
///
/// throws:
/// <code>DFUFirmwareError</code> if the file is invalid, or
/// <code>DFUStreamZipError</code> if creating a Zip stream failed.
///
/// returns:
/// The DFU firmware object or <code>nil</code> in case of an error.
- (nullable instancetype)initWithUrlToZipFile:(NSURL * _Nonnull)urlToZipFile type:(enum DFUFirmwareType)type error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
/// Creates the DFU Firmware object from a Distribution packet (ZIP).
/// Such file must contain a manifest.json file with firmware metadata and at
/// least one firmware binaries. Read more about the Distribution packet on
/// the DFU documentation.
/// \param zipFile The Distribution packet (ZIP) data.
///
///
/// throws:
/// <code>DFUFirmwareError</code> if the file is invalid,
/// <code>DFUStreamZipError</code> if creating a Zip stream failed,
/// or an error in the Cocoa domain, if the data cannot be written
/// to a temporary location.
///
/// returns:
/// The DFU firmware object or <code>nil</code> in case of an error.
- (nullable instancetype)initWithZipFile:(NSData * _Nonnull)zipFile error:(NSError * _Nullable * _Nullable)error;
/// Creates the DFU Firmware object from a Distribution packet (ZIP).
/// Such file must contain a manifest.json file with firmware metadata and at
/// least one firmware binaries. Read more about the Distribution packet on
/// the DFU documentation.
/// \param zipFile The Distribution packet (ZIP) data.
///
/// \param type The type of the firmware to use.
///
///
/// throws:
/// <code>DFUFirmwareError</code> if the file is invalid,
/// <code>DFUStreamZipError</code> if creating a Zip stream failed,
/// or an error in the Cocoa domain, if the data cannot be written
/// to a temporary location.
///
/// returns:
/// The DFU firmware object or <code>nil</code> in case of an error.
- (nullable instancetype)initWithZipFile:(NSData * _Nonnull)zipFile type:(enum DFUFirmwareType)type error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
/// Creates the DFU Firmware object from a BIN or HEX file.
/// Setting the DAT file with an Init packet is optional, but may be required by the
/// bootloader (SDK 7.0.0+).
/// \param urlToBinOrHexFile URL to a BIN or HEX file with the firmware.
///
/// \param urlToDatFile An optional URL to a DAT file with the Init packet.
///
/// \param type The type of the firmware.
///
///
/// throws:
/// <code>DFUFirmwareError</code> if the file is invalid,
/// <code>DFUStreamHexError</code> if the hex file is invalid,
/// or an error in the Cocoa domain, if <code>url</code> cannot be read.
///
/// returns:
/// The DFU firmware object or <code>nil</code> in case of an error.
- (nullable instancetype)initWithUrlToBinOrHexFile:(NSURL * _Nonnull)urlToBinOrHexFile urlToDatFile:(NSURL * _Nullable)urlToDatFile type:(enum DFUFirmwareType)type error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
/// Creates the DFU Firmware object from a BIN data.
/// Setting the DAT file with an Init packet is optional, but may be required by the
/// bootloader (SDK 7.0.0+).
/// \param binFile Content of the new firmware as BIN.
///
/// \param datFile An optional DAT file data with the Init packet.
///
/// \param type The type of the firmware.
///
///
/// returns:
/// The DFU firmware object or <code>nil</code> in case of an error.
- (nonnull instancetype)initWithBinFile:(NSData * _Nonnull)binFile datFile:(NSData * _Nullable)datFile type:(enum DFUFirmwareType)type OBJC_DESIGNATED_INITIALIZER;
/// Creates the DFU Firmware object from a HEX data.
/// Setting the DAT file with an Init packet is optional, but may be required by the
/// bootloader (SDK 7.0.0+).
/// \param hexFile Content of the HEX file containing new firmware.
///
/// \param datFile An optional DAT file data with the Init packet.
///
/// \param type The type of the firmware.
///
///
/// throws:
/// <code>DFUStreamHexError</code> if the hex file is invalid.
///
/// returns:
/// The DFU firmware object or <code>nil</code> in case of an error.
- (nullable instancetype)initWithHexFile:(NSData * _Nonnull)hexFile datFile:(NSData * _Nullable)datFile type:(enum DFUFirmwareType)type error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// An object containing sizes of all parts of the new firmware.
/// A firmware which is composed of SoftDevice and Bootloader has only
/// the total size of the stack component, not individual sizes. To indicate that
/// the size of the bootloader is 1 and the size of SoftDevice is the total size - 1.
SWIFT_CLASS("_TtC9ZTCoreKit15DFUFirmwareSize")
@interface DFUFirmwareSize : NSObject
/// Size of the SoftDevice in bytes.
/// If not even, add it to the bootloader size to get size of
/// the system component.
@property (nonatomic, readonly) uint32_t softdevice;
/// Size of the bootloader in bytes.
/// If equal to 1 the ZIP contains SD+BL and size of SD or BL is not known exactly,
/// but their sum is known.
@property (nonatomic, readonly) uint32_t bootloader;
/// Size of the application in bytes.
@property (nonatomic, readonly) uint32_t application;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// The type of the BIN or HEX file, or selection of content from the Distribution
/// packet (ZIP) file.
/// Select <code>softdeviceBootloaderApplication</code> to sent all files from the ZIP
/// (even it there is let’s say only application). This works as a filter.
/// If you have SD+BL+App in the ZIP, but want to send only App, you may set the
/// type to <code>application</code>.
typedef SWIFT_ENUM(uint8_t, DFUFirmwareType, open) {
/// Firmware file will be sent as a new SoftDevice.
  DFUFirmwareTypeSoftdevice = 1,
/// Firmware file will be sent as a new Bootloader.
  DFUFirmwareTypeBootloader = 2,
/// Firmware file will be sent as a new Application.
  DFUFirmwareTypeApplication = 4,
/// Firmware file will be sent as a new SoftDevice + Bootloader.
  DFUFirmwareTypeSoftdeviceBootloader = 3,
/// All content of the ZIP file will be sent.
  DFUFirmwareTypeSoftdeviceBootloaderApplication = 7,
};

@class CBPeripheral;
@class NSNumber;
@class CBUUID;
/// The DFU peripheral selector delegate is used to select the device advertising in
/// DFU bootloader mode after switching from application mode.
/// When a peripheral is switching to the bootloader mode that will change its MAC
/// address the library needs to select the correct device to continue the DFU
/// process. As MAC addresses are not exposed using iOS API, the selector
/// provides a mechanism choosing the correct target.
/// The default implementation is provided by <code>DFUPeripheralSelector</code>.
/// This library supports sending both BIN files from a ZIP Distribution
/// Packet automatically. However, when sending the SoftDevice update, the
/// DFU Bootloader may remove the current application in order to make space
/// for the new SoftDevice firmware (Legacy DFU, or Secure DFU with single
/// bank enabled when new SD+BL are larger then space available) or may
/// advertise in Bootloader mode for number of seconds (Secure DFU). When the
/// new SoftDevice is flashed the bootloader restarts the device and starts
/// advertising in DFU Bootloader mode.
/// Since SDK 8.0.0, to solve caching problem on a host that is not bonded
/// (in case there is no Service Changed characteristic), the bootloader
/// starts to advertise with an address incremented by 1. The DFU Library has
/// to scan for a peripheral with this new address. However, as iOS does not
/// expose the device address in the public CoreBluetooth API, address matching,
/// used on Android, can not be used. Instead, this selector is used. The DFU
/// Service will start scanning for peripherals with a UUID filter, where the
/// list of required UUID is returned by the <code>filterBy(hint:)</code> method. If your
/// device in the Bootloader mode does not advertise with any service UUIDs,
/// or this is not enough, you may select a target device by their advertising
/// packet or RSSI using this delegate.
/// In SDK 14.0.0 a new feature was added to the Buttonless DFU for non-bonded
/// devices which allows to send a unique name to the device before it is
/// switched to bootloader mode. After jump, the bootloader will advertise
/// with this name as the Complete Local Name making it easy to select proper
/// device. In this case you don’t have to override the default peripheral
/// selector.
/// Read more about the new feature on <a href="https://infocenter.nordicsemi.com/topic/sdk_nrf5_v17.1.0/ble_sdk_app_buttonless_dfu.html?cp=9_1_4_4_1">Infocenter</a>.
SWIFT_PROTOCOL("_TtP9ZTCoreKit29DFUPeripheralSelectorDelegate_")
@protocol DFUPeripheralSelectorDelegate
/// Returns whether the given peripheral is a device in DFU Bootloader mode.
/// \param peripheral The peripheral to be checked.
///
/// \param advertisementData Scanned advertising data.
///
/// \param RSSI Received signal strength indication in dBm.
///
/// \param name An optional name to look for in the
/// advertisement packet (see Buttonless DFU in SDK 14).
///
///
/// returns:
/// True (YES) if given peripheral is what service is looking for.
- (BOOL)select:(CBPeripheral * _Nonnull)peripheral advertisementData:(NSDictionary<NSString *, id> * _Nonnull)advertisementData RSSI:(NSNumber * _Nonnull)RSSI hint:(NSString * _Nullable)name SWIFT_WARN_UNUSED_RESULT;
/// Returns an optional list of services that the scanner will use to filter
/// advertising packets when scanning for a device in DFU Bootloader mode.
/// To find out what UUID you should return, switch your device to DFU Bootloader
/// mode (with a button!) and check the advertisement packet. The result of this
/// method will be applied to
/// <code>centralManager.scanForPeripherals(withServices: [CBUUID]?, options: [String : AnyObject]?)</code>.
/// \param dfuServiceUUID The UUID of the DFU service that was used to
/// flash SoftDevice and/or Bootloader. Usually, this
/// service UUID is present in the DFU Bootloader’s
/// advertising packet. Then this method may simply
/// return <code>[dfuServiceUUID]</code>.
///
///
/// returns:
/// An optional list of services or nil.
- (NSArray<CBUUID *> * _Nullable)filterByHint:(CBUUID * _Nonnull)dfuServiceUUID SWIFT_WARN_UNUSED_RESULT;
@end

/// The default implementation of <code>DFUPeripheralSelectorDelegate</code>.
/// Selects the first device with Legacy or Secure DFU Service UUID in the advertising packet.
SWIFT_CLASS("_TtC9ZTCoreKit21DFUPeripheralSelector")
@interface DFUPeripheralSelector : NSObject <DFUPeripheralSelectorDelegate>
- (BOOL)select:(CBPeripheral * _Nonnull)peripheral advertisementData:(NSDictionary<NSString *, id> * _Nonnull)advertisementData RSSI:(NSNumber * _Nonnull)RSSI hint:(NSString * _Nullable)name SWIFT_WARN_UNUSED_RESULT;
- (NSArray<CBUUID *> * _Nullable)filterByHint:(CBUUID * _Nonnull)dfuServiceUUID SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// The progress delegates may be used to notify user about progress updates.
/// The only method of the delegate is only called when the service is in the
/// Uploading state.
SWIFT_PROTOCOL("_TtP9ZTCoreKit19DFUProgressDelegate_")
@protocol DFUProgressDelegate
/// Callback called in the <code>DFUState/uploading</code> state during firmware upload.
/// Gives detailed information about the progress and speed of transmission.
/// This method is always called at least two times (for 0% and 100%) if upload has
/// started and did not fail and is not called multiple times for the same number of
/// percentage.
/// This method is called in the thread set as <code>progressQueue</code> in
/// <code>DFUServiceInitiator/init(queue:delegateQueue:progressQueue:loggerQueue:centralManagerOptions:)</code>.
/// \param part Number of part that is currently being transmitted. Parts
/// start from 1 and may have value either 1 or 2. Part 2 is
/// used only when there were Soft Device and/or Bootloader AND
/// an Application in the Distribution Packet and the DFU target
/// does not support sending all files in a single connection.
/// First the SD and/or BL will be sent, then the service will
/// disconnect, reconnect again to the (new) bootloader and send
/// the Application.
///
/// \param totalParts Total number of parts that are to be send (this is always
/// equal to 1 or 2).
///
/// \param progress The current progress of uploading the current part in
/// percentage (values 0-100).
/// Each value will be called at most once - in case of a large
/// file a value e.g. 3% will be called only once, despite that
/// it will take more than one packet to reach 4%. In case of
/// a small firmware file some values may be omitted.
/// For example, if firmware file would be only 20 bytes you
/// would get a callback 0% (called always) and then 100% when done.
///
/// \param currentSpeedBytesPerSecond The current speed in bytes per second.
///
/// \param avgSpeedBytesPerSecond The average speed in bytes per second.
///
- (void)dfuProgressDidChangeFor:(NSInteger)part outOf:(NSInteger)totalParts to:(NSInteger)progress currentSpeedBytesPerSecond:(double)currentSpeedBytesPerSecond avgSpeedBytesPerSecond:(double)avgSpeedBytesPerSecond;
@end

/// The controller allows pausing, resuming or aborting the ongoing DFU operation.
/// Use of the controller is optional. An application does not have to allow users to do any of the actions.
SWIFT_CLASS("_TtC9ZTCoreKit20DFUServiceController")
@interface DFUServiceController : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Call this method to pause uploading during the transmission process.
/// The transmission can be resumed only when connection remains. If service
/// has already started sending firmware data it will pause after receiving
/// next Packet Receipt Notification. Otherwise it will continue to send
/// Op Codes and pause before sending the first bytes of the firmware. With
/// Packet Receipt Notifications disabled it is the only moment when upload
/// may be paused.
- (void)pause;
/// Call this method to resume the paused transfer, otherwise does nothing.
- (void)resume;
/// Aborts the upload.
/// As a result, the phone will disconnect from peripheral. The peripheral
/// will try to recover the last firmware. Had the application been removed, the device
/// will restart in the DFU bootloader mode.
/// Aborting DFU does not cancel pending connection attempt. It is only when the service
/// is sending firmware or an Op Code that the operation can be stopped.
///
/// returns:
/// <code>True</code> if DFU has been aborted; <code>false</code> otherwise.
- (BOOL)abort SWIFT_WARN_UNUSED_RESULT;
/// Starts again aborted DFU operation.
- (void)restart;
/// Returns <code>true</code> if DFU operation has been paused.
@property (nonatomic, readonly) BOOL paused;
/// Returns <code>true</code> if DFU operation has been aborted.
@property (nonatomic, readonly) BOOL aborted;
@end

enum DFUState : NSInteger;
/// The service delegate reports about state changes and errors.
SWIFT_PROTOCOL("_TtP9ZTCoreKit18DFUServiceDelegate_")
@protocol DFUServiceDelegate
/// Callback called when state of the DFU Service has changed.
/// This method is called in the <code>delegateQueue</code> specified in the
/// <code>DFUServiceInitiator/init(queue:delegateQueue:progressQueue:loggerQueue:centralManagerOptions:)</code>.
/// \param state The new state of the service.
///
- (void)dfuStateDidChangeTo:(enum DFUState)state;
/// Called after an error occurred.
/// The device will be disconnected and DFU operation has been cancelled.
/// note:
/// When an error is received the DFU state will not change to <code>DFUState/aborted</code>.
/// This method is called in the <code>delegateQueue</code> specified in the
/// <code>DFUServiceInitiator/init(queue:delegateQueue:progressQueue:loggerQueue:centralManagerOptions:)</code>.
/// \param error The error code.
///
/// \param message Error description.
///
- (void)dfuError:(enum DFUError)error didOccurWithMessage:(NSString * _Nonnull)message;
@end

@protocol LoggerDelegate;
@class DFUUuidHelper;
@class CBCentralManager;
@class NSUUID;
/// The initiator object should be used to initiate updating firmware
/// on a remote Bluetooth LE target compatible with the Nordic Semiconductor’s Legacy or
/// Secure DFU (Device Firmware Update) protocol from nRF5 SDK.
/// A <code>delegate</code>, <code>progressDelegate</code> and <code>logger</code> may be specified in
/// order to receive status information.
/// \code
/// let initiator = DFUServiceInitiator()
/// initiator.logger = self // - to get logs
/// initiator.delegate = self // - to be informed about current state and errors
/// initiator.progressDelegate = self // - to get progress updates
/// // TODO: Check out other properties of the initiator.
///
/// let controller = initiator.with(firmware: selectedFirmware).start(target: peripheral)
///
/// \endcodeUsing the <code>DFUServiceController</code> you may pause, resume or abort the DFU operation.
SWIFT_CLASS("_TtC9ZTCoreKit19DFUServiceInitiator")
@interface DFUServiceInitiator : NSObject
/// The service delegate is an object that will be notified about state changes
/// of the DFU Service.
/// Setting it is optional but recommended.
@property (nonatomic, weak) id <DFUServiceDelegate> _Nullable delegate;
/// An optional progress delegate will be called only during upload.
/// t notifies about current upload percentage and speed.
@property (nonatomic, weak) id <DFUProgressDelegate> _Nullable progressDelegate;
/// The logger delegate receives logs from the service.
@property (nonatomic, weak) id <LoggerDelegate> _Nullable logger;
/// The selector object is used when the device needs to disconnect and start
/// advertising with a different address to avoid caching problems, for example
/// after switching to the Bootloader mode, or during sending a firmware containing
/// a SoftDevice (or SoftDevice and Bootloader) and the Application.
/// After flashing the first part (containing the SoftDevice), the device restarts
/// in the DFU Bootloader mode and may (since SDK 8.0.0) start advertising with an
/// address incremented by 1. The peripheral specified in the <code>start(target:)</code>
/// may no longer be used as there is no device advertising with its address.
/// The DFU Service will scan for a new device and connect to the first device
/// returned by the selector.
/// The default selector (<code>DFUPeripheralSelector</code>) returns the first device
/// with the required DFU Service UUID in the advertising packet
/// (Secure or Legacy DFU Service UUID).
/// Set own selector if your DFU bootloader advertises using custom data.
@property (nonatomic, strong) id <DFUPeripheralSelectorDelegate> _Nonnull peripheralSelector;
/// The number of packets of firmware data to be received by the DFU target before
/// sending a new Packet Receipt Notification.
/// If this value is 0, the packet receipt notification will be disabled by the DFU target.
/// Default value is 12.
/// note:
/// PRNs are no longer required on iOS 11 and MacOS 10.13 or newer, but
/// make sure your device is able to be updated without. Old SDKs, before SDK 7
/// had very slow memory management and could not handle packets that fast.
/// If your device is based on such SDK it is recommended to leave the default value.
/// Disabling PRNs increases upload speed but may cause failures on devices with slow flash
/// memory.
/// On older versions, higher values of PRN (~20+), or disabling it, may speed up
/// the upload process, but also cause a buffer overflow and hang the Bluetooth adapter.
/// Maximum verified values were 29 for iPhone 6 Plus or 22 for iPhone 7, both iOS 10.1.
@property (nonatomic) uint16_t packetReceiptNotificationParameter;
/// Should the Legacy DFU service assume the device is in bootloader mode despite
/// absence of the DFU Version characteristic.
/// important:
/// This property is only meaningful for devices supporting Legacy DFU without
/// DFU Version characteristic  (nRF5 SDK 4.3 - 7) and is ignored otherwise.
/// Setting this property to <code>true</code> will prevent from jumping to the DFU Bootloader
/// mode in case there is no DFU Version characteristic. Use it if the DFU operation
/// can be handled by your device running in the application mode. If the DFU Version
/// characteristic exists, the information whether to begin DFU operation, or jump to
/// bootloader, is taken from the characteristic’s value. The value returned equal to
/// <code>0x0100</code> (read as: minor=1, major=0, or version 0.1) means that the device is in the
/// application mode and buttonless jump to DFU Bootloader is supported.
/// Currently, the following values of the DFU Version characteristic are supported:
/// <em>No DFU Version characteristic</em> - one of the first implementations of DFU Service.
/// The device may support only Application update (version from SDK 4.3.0), may support
/// Soft Device, Bootloader and Application update but without buttonless jump to
/// bootloader (SDK 6.0.0) or with buttonless jump (SDK 6.1.0).
/// The DFU Library determines whether the device is in application mode or in DFU
/// Bootloader mode by counting number of services: if no DFU Service found - device
/// is in app mode and does not support buttonless jump, if the DFU Service is the only
/// service found (except General Access and General Attribute services) - it assumes
/// it is in DFU Bootloader mode and may start DFU immediately, if there is at least
/// one service except DFU Service - the device is in application mode and supports
/// buttonless jump. In the last case, you want to perform DFU operation without
/// jumping - set the <code>forceDfu</code> property to <code>true</code>.
/// <em>0.1</em> - Device is in a mode that supports buttonless jump to the DFU Bootloader.
/// <em>0.5</em> - Device can handle DFU operation. Extended Init packet is required.
/// Bond information is lost in the bootloader mode and after updating an app.
/// Released in SDK 7.0.0.
/// <em>0.6</em> - Bond information is kept in bootloader mode and may be kept after
/// updating application (DFU Bootloader must be configured to preserve the bond
/// information).
/// <em>0.7</em> - The SHA-256 firmware hash is used in the Extended Init Packet instead
/// of CRC-16. This feature is transparent for the DFU Service.
/// <em>0.8</em> - The Extended Init Packet is signed using the private key. The bootloader,
/// using the public key, is able to verify the content. Released in SDK 9.0.0 as
/// experimental feature.
/// Caution! The firmware type (Application, Bootloader, SoftDevice or SoftDevice +
/// Bootloader) is not encrypted as it is not a part of the Extended Init Packet.
/// A change in the protocol will be required to fix this issue.
/// By default the DFU Library will try to switch the device to the DFU Bootloader
/// mode if it finds more services then one (DFU Service). It assumes it is already
/// in the bootloader mode if the only service found is the DFU Service. Setting the
/// <code>forceDfu</code> to <code>true</code> will prevent from jumping in these both cases.
@property (nonatomic) BOOL forceDfu;
/// Should the Legacy DFU service scan for the device after switching to bootloader mode.
/// By default, the Legacy DFU bootloader, starting from SDK 7.1, when enabled using
/// buttonless service, advertises with the same Bluetooth address as the application
/// using direct advertisement. This complies with the Bluetooth specification.
/// However, on iOS 13.x, iPhones and iPads use random addresses on each
/// connection and do not expect direct advertising unless bonded. This causes those
/// packets being missed and not reported to the library, making reconnection to the
/// bootloader and proceeding with DFU impossible.
/// A solution requires modifying either the bootloader not to use the direct advertising,
/// or the application not to share the peer data with bootloader, in which case it will
/// advertise indirectly using address +1, like it does when the switch to bootloader mode
/// is initiated with a button. After such modification, setting this flag to true will make the
/// library scan for the bootloader using <code>DFUPeripheralSelector</code>.
/// Setting this flag to <code>true</code> without modifying the bootloader behavior will break the DFU,
/// as the direct advertising packets are empty and will not pass the default
/// <code>DFUPeripheralSelector</code>.
/// since:
/// 4.8.0
@property (nonatomic) BOOL forceScanningForNewAddressInLegacyDfu;
/// Connection timeout.
/// When the DFU target does not connect before the time runs out, a timeout error
/// is reported.
/// since:
/// 4.8.0
@property (nonatomic) NSTimeInterval connectionTimeout;
/// Duration of a delay, that the service will wait before sending each data object in
/// Secure DFU.
/// The delay will be done after a data object is created, and before
/// any data byte is sent. The default value is 0, which disables this feature for the
/// second and following data objects, but the first one will be delayed by 0.4 sec.
/// It has been found, that a delay of at least 0.3 sec reduces the risk of packet lose
/// (the bootloader needs some time to prepare flash memory) on DFU bootloader from
/// SDK 15, 16 and 17. The delay does not have to be longer than 0.4 sec, as according to
/// performed tests, such delay is sufficient.
/// The longer the delay, the more time DFU will take to complete (delay will be repeated for
/// each data object (4096 bytes)). However, with too small delay a packet lose may occur,
/// causing the service to enable PRN and set them to 1 making DFU process very, very slow
/// (but reliable).
/// The recommended delay is from 0.3 to 0.4 second if your DFU bootloader is from
/// SDK 15, 16 or 17. Older bootloaders do not need this delay.
/// This variable is ignored in Legacy DFU.
/// since:
/// 4.8.0
@property (nonatomic) NSTimeInterval dataObjectPreparationDelay;
/// Should the bootloader use random name to make it distinguishable from other devices.
/// In SDK 14.0.0 a new feature was added to the Buttonless DFU for non-bonded
/// devices which allows to send a unique name to the device before it is switched
/// to bootloader mode. After jump, the bootloader will advertise with this name
/// as the Complete Local Name making it easy to select proper device. In this case
/// you don’t have to override the default peripheral selector.
/// Read more at <a href="http://infocenter.nordicsemi.com/topic/com.nordic.infocenter.sdk5.v14.0.0/service_dfu.html">SDK 14.0 documentation at Infocenter</a>.
/// Setting this flag to <code>false</code> you will disable this feature. iOS DFU Library will
/// not send the <code>0x02-[len]-[new name]</code> command prior jumping and will
/// rely on the <code>peripheralSelector</code> just like it used to in previous SDK.
/// This flag is ignored in Legacy DFU.
/// <em>It is recommended to keep this flag set to true unless necessary.</em>
/// For more information read <a href="https://github.com/NordicSemiconductor/IOS-nRF-Connect/issues/16">Issue 16</a>.
@property (nonatomic) BOOL alternativeAdvertisingNameEnabled;
/// The name the bootloader should use in advertisement.
/// If <code>alternativeAdvertisingNameEnabled</code> is <code>true</code> then this specifies the
/// alternative name to use. If <code>nil</code> (default) then a random name is generated.
/// The maximum length of the alternative advertising name is 20 bytes.
/// Longer name will be truncated. UTF-8 characters can be cut in the middle.
@property (nonatomic, copy) NSString * _Nullable alternativeAdvertisingName;
/// Should the library discover Experimental Buttonless Service from nRF5 SDK version 12.
/// Set this flag to <code>true</code> to enable experimental buttonless feature in Secure DFU.
/// When the experimental Buttonless DFU Service is found on a device, the service
/// will use it to switch the device to the bootloader mode, connect to it in that
/// mode and proceed with DFU.
/// In the SDK 12.x the Buttonless DFU feature for Secure DFU was experimental.
/// It is NOT recommended to use it: it was not properly tested, had implementation bugs
/// (e.g. <a href="https://devzone.nordicsemi.com/question/100609/sdk-12-bootloader-erased-after-programming/">this one</a>)
/// and does not required encryption and therefore may lead to DOS attack (anyone can
/// use it to switch the device to bootloader mode). However, as there is no other way
/// to trigger bootloader mode on devices without a button, this DFU Library supports
/// this service, but the feature must be explicitly enabled here. Be aware, that setting
/// this flag to <code>false</code> will no protect your devices from this kind of attacks, as
/// an attacker may use another app for that purpose.
/// Spec:
/// Buttonless DFU Service UUID: <code>8E400001-F315-4F60-9FB8-838830DAEA50</code>
/// Buttonless DFU characteristic UUID: <code>8E400001-F315-4F60-9FB8-838830DAEA50</code> (the same)
/// Enter Bootloader Op Code: <code>0x01</code>
/// Correct return value: <code>0x20-01-01</code> , where:
/// <code>0x20</code> - Response Op Code
/// <code>0x01</code> - Request Code
/// <code>0x01</code> - Success
/// The device should disconnect and restart in DFU mode after sending the notification.
/// In SDK 13 this issue was be fixed by a proper implementation (bonding supported,
/// passing bond information to the bootloader, encryption, well tested).
/// It is recommended to migrate to SDK 13 or newer
@property (nonatomic) BOOL enableUnsafeExperimentalButtonlessServiceInSecureDfu;
/// UUIDs used during the DFU Process.
/// This allows you to pass in Custom UUIDs for the DFU Service/Characteristics.
@property (nonatomic, strong) DFUUuidHelper * _Nonnull uuidHelper;
/// Disable the ability for the Secure DFU process to resume from where it was.
/// By default this is set to <code>false</code>. This property applies only to Secure DFU.
/// since:
/// 4.3.0
@property (nonatomic) BOOL disableResume;
/// Creates the <code>DFUServiceInitializer</code> which allows updating firmware on
/// Bluetooth LE devices supporting Legacy or Secure DFU from nRF5 SDK from
/// Nordic Semiconductor..
/// This constructor takes control over the central manager and peripheral objects.
/// Their delegates will be set to internal library objects and will NOT be reverted to
/// original objects, instead they will be set to nil when DFU is complete, aborted or
/// has failed with an error. An app should restore the delegates (if needed) after
/// receiving state <code>DFUState/completed</code> or <code>DFUState/aborted</code>,
/// or receiving an error.
/// important:
/// This constructor has been deprecated in favor of
/// <code>init(queue:delegateQueue:progressQueue:loggerQueue:centralManagerOptions:)</code>,
/// which does not take control over the given peripheral, using a copy instead.
/// seealso:
/// <code>peripheralSelector</code> - a selector used when scanning for a device
/// in DFU Bootloader mode in case you want to update a SoftDevice and
/// Application from a single ZIP Distribution Packet.
/// \param centralManager Manager that will be used to connect to the peripheral
///
/// \param target The DFU target peripheral.
///
///
/// returns:
/// The initiator instance.
- (nonnull instancetype)initWithCentralManager:(CBCentralManager * _Nonnull)centralManager target:(CBPeripheral * _Nonnull)target OBJC_DESIGNATED_INITIALIZER SWIFT_DEPRECATED_MSG("Use init(queue: DispatchQueue?) instead.");
/// Creates the <code>DFUServiceInitializer</code> which allows updating firmware on
/// Bluetooth LE devices supporting Legacy or Secure DFU from nRF5 SDK from
/// Nordic Semiconductor..
/// version:
/// Added in version 4.2 of the iOS DFU Library. Extended in 4.3 to allow
/// setting delegate queues.
/// seealso:
/// <code>peripheralSelector</code> - a selector used when scanning for a
/// device in DFU Bootloader mode in case you want to update a SoftDevice
/// and Application from a single ZIP Distribution Packet.
/// \param queue The dispatch queue to run BLE operations on.
///
/// \param delegateQueue The dispatch queue to invoke all delegate callbacks on.
///
/// \param progressQueue The dispatch queue to invoke all progress delegate
/// callbacks on.
///
/// \param loggerQueue The dispatch queue to invoke all logger events on.
///
/// \param centralManagerOptions An optional dictionary that contains initialization options for <code>CBCentralManager</code>.
///
///
/// returns:
/// The initiator instance.
- (nonnull instancetype)initWithQueue:(dispatch_queue_t _Nullable)queue delegateQueue:(dispatch_queue_t _Nonnull)delegateQueue progressQueue:(dispatch_queue_t _Nonnull)progressQueue loggerQueue:(dispatch_queue_t _Nonnull)loggerQueue centralManagerOptions:(NSDictionary<NSString *, id> * _Nullable)centralManagerOptions OBJC_DESIGNATED_INITIALIZER;
/// Sets the file with the firmware.
/// The file must be specified before calling <code>start(target:)</code>
/// or <code>start(targetWithIdentifier:)</code> method.
/// \param file The firmware wrapper object.
///
///
/// returns:
/// The initiator instance to allow chain use.
- (DFUServiceInitiator * _Nonnull)withFirmware:(DFUFirmware * _Nonnull)file SWIFT_WARN_UNUSED_RESULT;
/// Starts sending the specified firmware to the DFU target specified in
/// <code>init(centralManager:target:)</code>.
/// When started, the service will automatically connect to the target, switch to
/// DFU Bootloader mode (if necessary), and send all the content of the specified
/// firmware file in one or two connections.
/// Two connections will be used if a ZIP file contains a SoftDevice and/or
/// Bootloader and an Application. First the SoftDevice and/or Bootloader will
/// be transferred, then the service will disconnect, reconnect to the (new)
/// Bootloader again and send the Application (unless the target supports
/// receiving all files in a single connection). The peripheral will NOT be
/// reconnected after the DFU is completed, aborted or has failed.
/// important:
/// Use <code>start(target:)</code> or <code>start(targetWithIdentifier:)</code> instead.
///
/// returns:
/// A <code>DFUServiceController</code> object that can be used to control the
/// DFU operation, or <code>nil</code>, if the file was not set, or the target
/// peripheral was not set.
- (DFUServiceController * _Nullable)start SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("Use start(target: CBPeripheral) instead.");
/// Starts sending the specified firmware to the given DFU target.
/// When started, the service will automatically connect to the target, switch to
/// DFU Bootloader mode (if necessary), and send all the content of the specified
/// firmware file in one or two connections. Two connections will be used if a ZIP
/// file contains a SoftDevice and/or Bootloader and an Application. First, the
/// SoftDevice and/or Bootloader will be transferred, then the service will disconnect,
/// reconnect to the (new) Bootloader again and send the Application (unless the
/// target supports receiving all files in a single connection). The peripheral
/// will NOT be reconnected after the DFU is completed, aborted or has failed.
/// This method does not take control over the peripheral.
/// A new central manager is used, from which a copy of the peripheral is retrieved.
/// Be warned, that the original peripheral delegate may receive a lot of calls, and
/// it will restart during the process. The app should not send any data to DFU
/// characteristics when DFU is in progress.
/// \param target The DFU target peripheral.
///
///
/// returns:
/// A <code>DFUServiceController</code> object that can be used to control the DFU
/// operation, or <code>nil</code>, if the file was not set, or the peripheral instance
/// could not be retrieved.
- (DFUServiceController * _Nullable)startWithTarget:(CBPeripheral * _Nonnull)target SWIFT_WARN_UNUSED_RESULT;
/// Starts sending the specified firmware to the DFU target with given identifier.
/// When started, the service will automatically connect to the target, switch to
/// DFU Bootloader mode (if necessary), and send all the content of the specified
/// firmware file in one or two connections. Two connections will be used if a ZIP
/// file contains a SoftDevice and/or Bootloader and an Application. First, the
/// SoftDevice and/or Bootloader will be transferred, then the service will disconnect,
/// reconnect to the (new) Bootloader again and send the Application (unless the
/// target supports receiving all files in a single connection). The peripheral
/// will NOT be reconnected after the DFU is completed, aborted or has failed.
/// This method does not take control over the peripheral.
/// A new central manager is used, from which a copy of the peripheral is retrieved.
/// Be warned, that the original peripheral delegate may receive a lot of calls, and
/// it will restart during the process. The app should not send any data to DFU
/// characteristics when DFU is in progress.
/// \param uuid The UUID associated with the peer.
///
///
/// returns:
/// A <code>DFUServiceController</code> object that can be used to control the DFU
/// operation, or <code>nil</code>, if the file was not set, or the peripheral instance
/// could not be retrieved.
- (DFUServiceController * _Nullable)startWithTargetWithIdentifier:(NSUUID * _Nonnull)uuid SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// The state of the DFU Service.
/// The new state is returned using <code>DFUServiceDelegate/dfuStateDidChange(to:)</code>
/// set as <code>DFUServiceInitiator/delegate</code>.
/// When the DFU operation ends with an error, the error is reported using
/// <code>DFUServiceDelegate/dfuError(_:didOccurWithMessage:)</code>.
/// In that case the state change is not reported.
typedef SWIFT_ENUM(NSInteger, DFUState, open) {
/// Service is connecting to the DFU target.
  DFUStateConnecting = 0,
/// DFU Service is initializing DFU operation.
  DFUStateStarting = 1,
/// DFU Service is switching the device to DFU mode.
  DFUStateEnablingDfuMode = 2,
/// DFU Service is uploading the firmware.
  DFUStateUploading = 3,
/// The DFU target is validating the firmware. This state occurs only in Legacy DFU.
  DFUStateValidating = 4,
/// The iDevice is disconnecting or waiting for disconnection.
  DFUStateDisconnecting = 5,
/// DFU operation is completed and successful.
  DFUStateCompleted = 6,
/// DFU operation was aborted.
  DFUStateAborted = 7,
};

enum DFUUuidType : NSInteger;
/// DFU UUID object.
SWIFT_CLASS("_TtC9ZTCoreKit7DFUUuid")
@interface DFUUuid : NSObject
/// UUID For the DFU UUID Object.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull uuid;
/// Type of DFU UUID.
@property (nonatomic, readonly) enum DFUUuidType type;
- (nonnull instancetype)initWithUUID:(CBUUID * _Nonnull)withUUID forType:(enum DFUUuidType)forType OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// UUID Helper for DFU Process.
/// The UUID can be modified for each of the DFU types supported by
/// the Nordic devices.
SWIFT_CLASS("_TtC9ZTCoreKit13DFUUuidHelper")
@interface DFUUuidHelper : NSObject
/// UUID for Legacy DFU Service.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull legacyDFUService;
/// UUID for Legacy DFU Control Point Characteristic.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull legacyDFUControlPoint;
/// UUID for Legacy DFU Packet Characteristic.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull legacyDFUPacket;
/// UUID for Legacy DFU Version Characteristic.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull legacyDFUVersion;
/// UUID for Secure DFU Service.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull secureDFUService;
/// UUID for Secure DFU Control Characteristic.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull secureDFUControlPoint;
/// UUID for Secure DFU Packet Characteristic.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull secureDFUPacket;
/// UUID for Buttonless DFU Service.
/// This UUID is also used for the Characteristic.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull buttonlessExperimentalService;
/// UUID for Buttonless DFU Characteristic.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull buttonlessExperimentalCharacteristic;
/// UUID for Buttonless DFU Without Bond Sharing Characteristic.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull buttonlessWithoutBonds;
/// UUID for Buttonless DFU With Bond Sharing Characteristic.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull buttonlessWithBonds;
/// Creates the DFU Helper with Default UUIDs.
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Create the DFU UUID Helper with Custom UUIDs.
/// \param uuids Array of Custom UUIDs.
///
- (nonnull instancetype)initWithCustomUuids:(NSArray<DFUUuid *> * _Nonnull)uuids;
@end

/// UUID Types for DFU.
typedef SWIFT_ENUM(NSInteger, DFUUuidType, open) {
/// Legacy DFU Service.
  DFUUuidTypeLegacyService = 0,
/// Legacy DFU Control Point Characteristic.
  DFUUuidTypeLegacyControlPoint = 1,
/// Legacy DFU Packet Characteristic.
  DFUUuidTypeLegacyPacket = 2,
/// Legacy DFU Version Characteristic.
  DFUUuidTypeLegacyVersion = 3,
/// Secure DFU Service.
  DFUUuidTypeSecureService = 4,
/// Secure DFU Control Characteristic.
  DFUUuidTypeSecureControl = 5,
/// Secure DFU Packet Characteristic.
  DFUUuidTypeSecurePacket = 6,
/// Buttonless DFU Service.
  DFUUuidTypeButtonlessService = 7,
/// Buttonless DFU Characteristic.
  DFUUuidTypeButtonlessCharacteristic = 8,
/// Buttonless DFU Without Bond Sharing Characteristic.
  DFUUuidTypeButtonlessWithoutBondSharing = 9,
/// Buttonless DFU With Bond Sharing Characteristic.
  DFUUuidTypeButtonlessWithBondSharing = 10,
};

/// This converter converts Intel HEX file to BIN.
/// The <a href="https://en.wikipedia.org/wiki/Intel_HEX">Intel HEX</a> specification can be found here:
/// <a href="http://www.interlog.com/~speff/usefulinfo/Hexfrmt.pdf">link</a>.
/// note:
/// Not all Intel HEX features are supported. The converter does not support gaps in the firmware.
/// The returned BIN contains data until the first found gap.
/// Supported Record Types:
/// \code
/// 0x04 - Extended Linear Address Record
/// 0x02 - Extended Segment Address Record
/// 0x01 - End of File
/// 0x00 - Data Record
///
/// \endcodeIf MBR size is provided, the values from addresses <code>0..<MBR Size</code> will be ignored.
SWIFT_CLASS("_TtC9ZTCoreKit21IntelHex2BinConverter")
@interface IntelHex2BinConverter : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// This initiator can be used to start a DFU process using Legacy DFU service.
/// The default <code>DFUServiceInitiator</code> will select the proper executor based
/// on the discovered services. If you know your device supports the Legacy DFU you may
/// consider using this initiator instead to skip that part.
SWIFT_CLASS("_TtC9ZTCoreKit25LegacyDFUServiceInitiator")
@interface LegacyDFUServiceInitiator : DFUServiceInitiator
- (DFUServiceController * _Nullable)startWithTargetWithIdentifier:(NSUUID * _Nonnull)uuid SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithCentralManager:(CBCentralManager * _Nonnull)centralManager target:(CBPeripheral * _Nonnull)target OBJC_DESIGNATED_INITIALIZER SWIFT_DEPRECATED_MSG("Use init(queue: DispatchQueue?) instead.");
- (nonnull instancetype)initWithQueue:(dispatch_queue_t _Nullable)queue delegateQueue:(dispatch_queue_t _Nonnull)delegateQueue progressQueue:(dispatch_queue_t _Nonnull)progressQueue loggerQueue:(dispatch_queue_t _Nonnull)loggerQueue centralManagerOptions:(NSDictionary<NSString *, id> * _Nullable)centralManagerOptions OBJC_DESIGNATED_INITIALIZER;
@end

/// Log levels used by the <code>LoggerDelegate</code>.
/// Logger application may filter log entries based on their level.
/// Levels allow to categorize message by importance.
typedef SWIFT_ENUM(NSInteger, LogLevel, open) {
/// Lowest priority. Usually names of called methods or callbacks received.
  LogLevelDebug = 0,
/// Low priority messages what the service is doing.
  LogLevelVerbose = 1,
/// Messages about completed tasks.
  LogLevelInfo = 5,
/// Messages about application level events, in this case DFU message
/// in human-readable form.
  LogLevelApplication = 10,
/// Important messages.
  LogLevelWarning = 15,
/// Highest priority messages with errors.
  LogLevelError = 20,
};

/// The Logger delegate.
SWIFT_PROTOCOL("_TtP9ZTCoreKit14LoggerDelegate_")
@protocol LoggerDelegate
/// This method is called on every log event..
/// The logger implementation should save log entries or present them to the user.
/// It is NOT safe to update any UI from this method as multiple threads may log.
/// \param level The log level.
///
/// \param message The message.
///
- (void)logWith:(enum LogLevel)level message:(NSString * _Nonnull)message;
@end

/// This initiator can be used to start a DFU process using Secure DFU service.
/// The default <code>DFUServiceInitiator</code> will select the proper executor based
/// on the discovered services. If you know your device supports the Secure DFU you may
/// consider using this initiator instead to skip that part.
SWIFT_CLASS("_TtC9ZTCoreKit25SecureDFUServiceInitiator")
@interface SecureDFUServiceInitiator : DFUServiceInitiator
- (DFUServiceController * _Nullable)startWithTargetWithIdentifier:(NSUUID * _Nonnull)uuid SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithCentralManager:(CBCentralManager * _Nonnull)centralManager target:(CBPeripheral * _Nonnull)target OBJC_DESIGNATED_INITIALIZER SWIFT_DEPRECATED_MSG("Use init(queue: DispatchQueue?) instead.");
- (nonnull instancetype)initWithQueue:(dispatch_queue_t _Nullable)queue delegateQueue:(dispatch_queue_t _Nonnull)delegateQueue progressQueue:(dispatch_queue_t _Nonnull)progressQueue loggerQueue:(dispatch_queue_t _Nonnull)loggerQueue centralManagerOptions:(NSDictionary<NSString *, id> * _Nullable)centralManagerOptions OBJC_DESIGNATED_INITIALIZER;
@end

@class NSEntityDescription;
@class NSManagedObjectContext;
SWIFT_CLASS_NAMED("ZTActivity")
@interface ZTActivity : NSManagedObject
- (nonnull instancetype)initWithEntity:(NSEntityDescription * _Nonnull)entity insertIntoManagedObjectContext:(NSManagedObjectContext * _Nullable)context OBJC_DESIGNATED_INITIALIZER;
@end

@class ZTPacket;
@class NSSet;
@interface ZTActivity (SWIFT_EXTENSION(ZTCoreKit))
- (void)addPacketsObject:(ZTPacket * _Nonnull)value;
- (void)removePacketsObject:(ZTPacket * _Nonnull)value;
- (void)addPackets:(NSSet * _Nonnull)values;
- (void)removePackets:(NSSet * _Nonnull)values;
@end

@class NSDate;
@interface ZTActivity (SWIFT_EXTENSION(ZTCoreKit))
@property (nonatomic, copy) NSString * _Nullable activityIdentifier;
@property (nonatomic, copy) NSString * _Nullable activityType;
@property (nonatomic) int64_t anchorTimestamp;
@property (nonatomic, copy) NSString * _Nullable appId;
@property (nonatomic) int16_t chunkCount;
@property (nonatomic) int16_t customActivityFirstChunkId;
@property (nonatomic) int64_t customActivityStartTimestamp;
@property (nonatomic, copy) NSDate * _Nullable endDate;
@property (nonatomic) int64_t endTimestamp;
@property (nonatomic) int16_t firstChunkId;
@property (nonatomic) BOOL forceStop;
@property (nonatomic, copy) NSString * _Nullable fwVersion;
@property (nonatomic, copy) NSString * _Nullable id;
@property (nonatomic) BOOL invalid;
@property (nonatomic) BOOL isAutomatic;
@property (nonatomic) BOOL isInterrupted;
@property (nonatomic) BOOL isRawDataMode;
@property (nonatomic) int16_t lastChunkId;
@property (nonatomic, copy) NSData * _Nullable metaDataRawValue;
@property (nonatomic, copy) NSString * _Nullable shoesSerial;
@property (nonatomic, copy) NSDate * _Nullable startDate;
@property (nonatomic) int64_t startTimestamp;
@property (nonatomic) int16_t status;
@property (nonatomic, copy) NSData * _Nullable stopReasonRawValue;
@property (nonatomic, copy) NSString * _Nullable tz;
@property (nonatomic, strong) NSSet * _Nullable packets;
@end

/// BLE Manager responsible for finding and connecting to peripherals. It can be subscribed to be notified about
/// <ul>
///   <li>
///     onBluetoothStateChange (Bluetooth state changed)
///   </li>
///   <li>
///     onDeviceDiscovered (Device discovered)
///   </li>
///   <li>
///     onDeviceStateChange (Device connected / disconnected)
///   </li>
///   <li>
///     onDeviceConnectionFailed ()
///   </li>
/// </ul>
SWIFT_CLASS("_TtC9ZTCoreKit12ZTBleManager")
@interface ZTBleManager : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@interface ZTBleManager (SWIFT_EXTENSION(ZTCoreKit)) <CBCentralManagerDelegate>
/// :nodoc:
- (void)centralManager:(CBCentralManager * _Nonnull)central willRestoreState:(NSDictionary<NSString *, id> * _Nonnull)dict;
- (void)centralManager:(CBCentralManager * _Nonnull)central connectionEventDidOccur:(CBConnectionEvent)event forPeripheral:(CBPeripheral * _Nonnull)peripheral;
/// :nodoc:
- (void)centralManager:(CBCentralManager * _Nonnull)central didDiscoverPeripheral:(CBPeripheral * _Nonnull)peripheral advertisementData:(NSDictionary<NSString *, id> * _Nonnull)advertisementData RSSI:(NSNumber * _Nonnull)RSSI;
/// :nodoc:
- (void)centralManager:(CBCentralManager * _Nonnull)central didFailToConnectPeripheral:(CBPeripheral * _Nonnull)peripheral error:(NSError * _Nullable)error;
/// :nodoc:
- (void)centralManager:(CBCentralManager * _Nonnull)central didConnectPeripheral:(CBPeripheral * _Nonnull)peripheral;
/// :nodoc:
- (void)centralManager:(CBCentralManager * _Nonnull)central didDisconnectPeripheral:(CBPeripheral * _Nonnull)peripheral error:(NSError * _Nullable)error;
/// :nodoc:
- (void)centralManagerDidUpdateState:(CBCentralManager * _Nonnull)central;
@end

/// Instance of peripheral device
SWIFT_CLASS("_TtC9ZTCoreKit8ZTDevice")
@interface ZTDevice : NSObject
/// :nodoc:
- (void)observeValueForKeyPath:(NSString * _Nullable)keyPath ofObject:(id _Nullable)object change:(NSDictionary<NSKeyValueChangeKey, id> * _Nullable)change context:(void * _Nullable)context;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CBDescriptor;
@class CBService;
@class CBCharacteristic;
@class CBL2CAPChannel;
@interface ZTDevice (SWIFT_EXTENSION(ZTCoreKit)) <CBPeripheralDelegate>
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didWriteValueForDescriptor:(CBDescriptor * _Nonnull)descriptor error:(NSError * _Nullable)error;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didDiscoverServices:(NSError * _Nullable)error;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didDiscoverCharacteristicsForService:(CBService * _Nonnull)service error:(NSError * _Nullable)error;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didUpdateValueForCharacteristic:(CBCharacteristic * _Nonnull)characteristic error:(NSError * _Nullable)error;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didWriteValueForCharacteristic:(CBCharacteristic * _Nonnull)characteristic error:(NSError * _Nullable)error;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic * _Nonnull)characteristic error:(NSError * _Nullable)error;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didReadRSSI:(NSNumber * _Nonnull)RSSI error:(NSError * _Nullable)error;
/// :nodoc:
- (void)peripheralDidUpdateName:(CBPeripheral * _Nonnull)peripheral;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didModifyServices:(NSArray<CBService *> * _Nonnull)invalidatedServices;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didDiscoverIncludedServicesForService:(CBService * _Nonnull)service error:(NSError * _Nullable)error;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic * _Nonnull)characteristic error:(NSError * _Nullable)error;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didUpdateValueForDescriptor:(CBDescriptor * _Nonnull)descriptor error:(NSError * _Nullable)error;
/// :nodoc:
- (void)peripheralIsReadyToSendWriteWithoutResponse:(CBPeripheral * _Nonnull)peripheral;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didOpenL2CAPChannel:(CBL2CAPChannel * _Nullable)channel error:(NSError * _Nullable)error;
@end

SWIFT_CLASS_NAMED("ZTPacket")
@interface ZTPacket : NSManagedObject
- (nonnull instancetype)initWithEntity:(NSEntityDescription * _Nonnull)entity insertIntoManagedObjectContext:(NSManagedObjectContext * _Nullable)context OBJC_DESIGNATED_INITIALIZER;
@end

@interface ZTPacket (SWIFT_EXTENSION(ZTCoreKit))
@property (nonatomic) int16_t activityTypeRawValue;
@property (nonatomic) int16_t bmTimestampTypeRawValue;
@property (nonatomic, copy) NSDate * _Nullable createdAt;
@property (nonatomic) int16_t duration;
@property (nonatomic, copy) NSDate * _Nullable fulfilledAt;
@property (nonatomic, copy) NSString * _Nullable fwVersion;
@property (nonatomic) int16_t id;
@property (nonatomic) int64_t originalTimestamp;
@property (nonatomic) int16_t packetsNumber;
@property (nonatomic) int16_t packetTypeRawValue;
@property (nonatomic, copy) NSData * _Nullable rawData;
@property (nonatomic) int16_t retryCount;
@property (nonatomic, copy) NSDate * _Nullable scheduledDeleted;
@property (nonatomic, copy) NSDate * _Nullable sentAt;
@property (nonatomic) int16_t statusRawValue;
@property (nonatomic) int64_t timestamp;
@property (nonatomic) int16_t timestampTypeRawValue;
@property (nonatomic, strong) ZTActivity * _Nullable activity;
@end

#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 6.2 effective-5.10 (swiftlang-6.2.0.19.9 clang-1700.3.19.1)
#ifndef ZTCOREKIT_SWIFT_H
#define ZTCOREKIT_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wnon-modular-include-in-framework-module"
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#pragma clang diagnostic pop
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef unsigned char char8_t;
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreBluetooth;
@import CoreData;
@import Dispatch;
@import Foundation;
@import ObjectiveC;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="ZTCoreKit",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)

/// A DFU error enumeration.
typedef SWIFT_ENUM(NSInteger, DFUError, open) {
/// Legacy DFU bootloader reported success.
  DFUErrorRemoteLegacyDFUSuccess = 1,
/// Legacy DFU bootloader is in invalid state.
  DFUErrorRemoteLegacyDFUInvalidState = 2,
/// Requested operation is not supported.
  DFUErrorRemoteLegacyDFUNotSupported = 3,
/// The firmware size exceeds limit.
  DFUErrorRemoteLegacyDFUDataExceedsLimit = 4,
/// A CRC (checksum) error.
  DFUErrorRemoteLegacyDFUCrcError = 5,
/// Operation failed for an unknown reason.
  DFUErrorRemoteLegacyDFUOperationFailed = 6,
/// Secure DFU bootloader reported success.
  DFUErrorRemoteSecureDFUSuccess = 11,
/// Requested Op Code is not supported.
  DFUErrorRemoteSecureDFUOpCodeNotSupported = 12,
/// Invalid parameter.
  DFUErrorRemoteSecureDFUInvalidParameter = 13,
/// Secure DFU bootloader cannot complete due to insufficient resources.
  DFUErrorRemoteSecureDFUInsufficientResources = 14,
/// The object is invalid.
  DFUErrorRemoteSecureDFUInvalidObject = 15,
/// Firmware signature is invalid.
  DFUErrorRemoteSecureDFUSignatureMismatch = 16,
/// Requested type is not supported.
  DFUErrorRemoteSecureDFUUnsupportedType = 17,
/// Requested operation is not permitted.
  DFUErrorRemoteSecureDFUOperationNotPermitted = 18,
/// Operation failed for an unknown reason.
  DFUErrorRemoteSecureDFUOperationFailed = 20,
/// The Secure DFU bootloader reported a detailed error.
/// note:
/// This error is not reported to the app. Instead, the library will
/// return one of the <code>remoteExtendedError...</code> errors.
  DFUErrorRemoteSecureDFUExtendedError = 21,
/// The format of the command was incorrect.
/// This error code is not used in the current implementation, because
/// <code>remoteSecureDFUOpCodeNotSupported</code> and
/// <code>remoteSecureDFUInvalidParameter</code> cover all possible format errors.
  DFUErrorRemoteExtendedErrorWrongCommandFormat = 22,
/// The command was successfully parsed, but it is not supported or unknown.
  DFUErrorRemoteExtendedErrorUnknownCommand = 23,
/// The init command is invalid.
/// The init packet either has an invalid update type or it is missing required fields for
/// the update type (for example, the init packet for a SoftDevice update is missing the
/// SoftDevice size field).
  DFUErrorRemoteExtendedErrorInitCommandInvalid = 24,
/// The firmware version is too low.
/// For an application or SoftDevice, the version must be greater than or equal to the
/// current version. For a bootloader, it must be greater than the current version.
/// This requirement prevents downgrade attacks.
  DFUErrorRemoteExtendedErrorFwVersionFailure = 25,
/// The hardware version of the device does not match the required hardware version
/// for the update.
/// This error may be thrown if a user tries to update a wrong device.
  DFUErrorRemoteExtendedErrorHwVersionFailure = 26,
/// The array of supported SoftDevices for the update does not contain the FWID
/// of the current SoftDevice or the first FWID is ‘0’ on a bootloader which requires
/// the SoftDevice to be present.
  DFUErrorRemoteExtendedErrorSdVersionFailure = 27,
/// The init packet does not contain a signature.
/// This error code is not used in the current implementation, because init packets
/// without a signature are regarded as invalid.
  DFUErrorRemoteExtendedErrorSignatureMissing = 28,
/// The hash type that is specified by the init packet is not supported by the DFU bootloader.
  DFUErrorRemoteExtendedErrorWrongHashType = 29,
/// The hash of the firmware image cannot be calculated.
  DFUErrorRemoteExtendedErrorHashFailed = 30,
/// The type of the signature is unknown or not supported by the DFU bootloader.
  DFUErrorRemoteExtendedErrorWrongSignatureType = 31,
/// The hash of the received firmware image does not match the hash in the init packet.
  DFUErrorRemoteExtendedErrorVerificationFailed = 32,
/// The available space on the device is insufficient to hold the firmware.
  DFUErrorRemoteExtendedErrorInsufficientSpace = 33,
/// Experimental Buttonless DFU service reported success.
  DFUErrorRemoteExperimentalButtonlessDFUSuccess = 9001,
/// The Op Code is not supported.
  DFUErrorRemoteExperimentalButtonlessDFUOpCodeNotSupported = 9002,
/// Jumping to bootloader mode failed.
  DFUErrorRemoteExperimentalButtonlessDFUOperationFailed = 9004,
/// Buttonless DFU service reported success.
  DFUErrorRemoteButtonlessDFUSuccess = 91,
/// The Op Code is not supported.
  DFUErrorRemoteButtonlessDFUOpCodeNotSupported = 92,
/// Jumping to bootloader mode failed.
  DFUErrorRemoteButtonlessDFUOperationFailed = 94,
/// The requested advertising name is invalid.
/// Maximum length for the name is 20 bytes..
  DFUErrorRemoteButtonlessDFUInvalidAdvertisementName = 95,
/// The service is busy.
  DFUErrorRemoteButtonlessDFUBusy = 96,
/// The Buttonless service requires the device to be bonded.
  DFUErrorRemoteButtonlessDFUNotBonded = 97,
/// Providing the DFUFirmware is required.
  DFUErrorFileNotSpecified = 101,
/// Given firmware file is not supported.
  DFUErrorFileInvalid = 102,
/// Since SDK 7.0.0 the DFU Bootloader requires the extended Init Packet.
/// For more details, see <a href="http://infocenter.nordicsemi.com/topic/com.nordic.infocenter.sdk5.v11.0.0/bledfu_example_init.html?cp=4_0_0_4_2_1_1_3">Infocenter</a>.
  DFUErrorExtendedInitPacketRequired = 103,
/// The Init packet is required and has not been found.
/// Before SDK 7.0.0 the init packet could have contained only 2-byte CRC
/// value, and was optional. Providing an extended one instead would cause
/// CRC error during validation (the bootloader assumes that the 2 first
/// bytes of the init packet are the firmware CRC).
  DFUErrorInitPacketRequired = 104,
/// The DFU service failed to connect to the target peripheral.
  DFUErrorFailedToConnect = 201,
/// The DFU target disconnected unexpectedly.
  DFUErrorDeviceDisconnected = 202,
/// Bluetooth adapter is disabled.
  DFUErrorBluetoothDisabled = 203,
/// Service discovery has failed.
  DFUErrorServiceDiscoveryFailed = 301,
/// The selected device does not support Legacy or Secure DFU
/// or any of Buttonless services.
  DFUErrorDeviceNotSupported = 302,
/// Reading DFU version characteristic has failed.
  DFUErrorReadingVersionFailed = 303,
/// Enabling Control Point notifications failed.
  DFUErrorEnablingControlPointFailed = 304,
/// Writing a characteristic has failed.
  DFUErrorWritingCharacteristicFailed = 305,
/// There was an error reported for a notification.
  DFUErrorReceivingNotificationFailed = 306,
/// Received response is not supported.
  DFUErrorUnsupportedResponse = 307,
/// Error raised during upload when the number of bytes sent is not equal to
/// number of bytes confirmed in Packet Receipt Notification.
  DFUErrorBytesLost = 308,
/// Error raised when the CRC reported by the remote device does not match.
/// Service has done 3 attempts to send the data.
  DFUErrorCrcError = 309,
/// The service went into an invalid state. The service will try to close
/// without crashing. Recovery to a know state is not possible.
  DFUErrorInvalidInternalState = 500,
};

@class NSString;
@class NSURL;
@class DFUFirmwareSize;
enum DFUFirmwareType : uint8_t;
@class NSData;
/// The DFU Firmware object wraps the firmware file and provides access to its content.
SWIFT_CLASS("_TtC9ZTCoreKit11DFUFirmware")
@interface DFUFirmware : NSObject
/// The name of the firmware file.
@property (nonatomic, readonly, copy) NSString * _Nullable fileName;
/// The URL to the firmware file.
@property (nonatomic, readonly, copy) NSURL * _Nullable fileUrl;
/// Information whether the firmware was successfully initialized.
@property (nonatomic, readonly) BOOL valid;
/// The size of each component of the firmware.
@property (nonatomic, readonly, strong) DFUFirmwareSize * _Nonnull size;
/// Number of connections required to transfer the firmware.
/// If a ZIP file contains a new firmware for the SoftDevice (and/or Bootloader)
/// and the Application, the number of parts is equal to 2. Otherwise this is
/// always 1.
@property (nonatomic, readonly) NSInteger parts;
/// Creates the DFU Firmware object from a Distribution packet (ZIP).
/// Such file must contain a manifest.json file with firmware metadata and at
/// least one firmware binaries. Read more about the Distribution packet on
/// the DFU documentation.
/// \param urlToZipFile URL to the Distribution packet (ZIP).
///
///
/// throws:
/// <code>DFUFirmwareError</code> if the file is invalid, or
/// <code>DFUStreamZipError</code> if creating a Zip stream failed.
///
/// returns:
/// The DFU firmware object or <code>nil</code> in case of an error.
- (nullable instancetype)initWithUrlToZipFile:(NSURL * _Nonnull)urlToZipFile error:(NSError * _Nullable * _Nullable)error;
/// Creates the DFU Firmware object from a Distribution packet (ZIP).
/// Such file must contain a manifest.json file with firmware metadata and at
/// least one firmware binaries. Read more about the Distribution packet on
/// the DFU documentation.
/// \param urlToZipFile URL to the Distribution packet (ZIP).
///
/// \param type The type of the firmware to use.
///
///
/// throws:
/// <code>DFUFirmwareError</code> if the file is invalid, or
/// <code>DFUStreamZipError</code> if creating a Zip stream failed.
///
/// returns:
/// The DFU firmware object or <code>nil</code> in case of an error.
- (nullable instancetype)initWithUrlToZipFile:(NSURL * _Nonnull)urlToZipFile type:(enum DFUFirmwareType)type error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
/// Creates the DFU Firmware object from a Distribution packet (ZIP).
/// Such file must contain a manifest.json file with firmware metadata and at
/// least one firmware binaries. Read more about the Distribution packet on
/// the DFU documentation.
/// \param zipFile The Distribution packet (ZIP) data.
///
///
/// throws:
/// <code>DFUFirmwareError</code> if the file is invalid,
/// <code>DFUStreamZipError</code> if creating a Zip stream failed,
/// or an error in the Cocoa domain, if the data cannot be written
/// to a temporary location.
///
/// returns:
/// The DFU firmware object or <code>nil</code> in case of an error.
- (nullable instancetype)initWithZipFile:(NSData * _Nonnull)zipFile error:(NSError * _Nullable * _Nullable)error;
/// Creates the DFU Firmware object from a Distribution packet (ZIP).
/// Such file must contain a manifest.json file with firmware metadata and at
/// least one firmware binaries. Read more about the Distribution packet on
/// the DFU documentation.
/// \param zipFile The Distribution packet (ZIP) data.
///
/// \param type The type of the firmware to use.
///
///
/// throws:
/// <code>DFUFirmwareError</code> if the file is invalid,
/// <code>DFUStreamZipError</code> if creating a Zip stream failed,
/// or an error in the Cocoa domain, if the data cannot be written
/// to a temporary location.
///
/// returns:
/// The DFU firmware object or <code>nil</code> in case of an error.
- (nullable instancetype)initWithZipFile:(NSData * _Nonnull)zipFile type:(enum DFUFirmwareType)type error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
/// Creates the DFU Firmware object from a BIN or HEX file.
/// Setting the DAT file with an Init packet is optional, but may be required by the
/// bootloader (SDK 7.0.0+).
/// \param urlToBinOrHexFile URL to a BIN or HEX file with the firmware.
///
/// \param urlToDatFile An optional URL to a DAT file with the Init packet.
///
/// \param type The type of the firmware.
///
///
/// throws:
/// <code>DFUFirmwareError</code> if the file is invalid,
/// <code>DFUStreamHexError</code> if the hex file is invalid,
/// or an error in the Cocoa domain, if <code>url</code> cannot be read.
///
/// returns:
/// The DFU firmware object or <code>nil</code> in case of an error.
- (nullable instancetype)initWithUrlToBinOrHexFile:(NSURL * _Nonnull)urlToBinOrHexFile urlToDatFile:(NSURL * _Nullable)urlToDatFile type:(enum DFUFirmwareType)type error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
/// Creates the DFU Firmware object from a BIN data.
/// Setting the DAT file with an Init packet is optional, but may be required by the
/// bootloader (SDK 7.0.0+).
/// \param binFile Content of the new firmware as BIN.
///
/// \param datFile An optional DAT file data with the Init packet.
///
/// \param type The type of the firmware.
///
///
/// returns:
/// The DFU firmware object or <code>nil</code> in case of an error.
- (nonnull instancetype)initWithBinFile:(NSData * _Nonnull)binFile datFile:(NSData * _Nullable)datFile type:(enum DFUFirmwareType)type OBJC_DESIGNATED_INITIALIZER;
/// Creates the DFU Firmware object from a HEX data.
/// Setting the DAT file with an Init packet is optional, but may be required by the
/// bootloader (SDK 7.0.0+).
/// \param hexFile Content of the HEX file containing new firmware.
///
/// \param datFile An optional DAT file data with the Init packet.
///
/// \param type The type of the firmware.
///
///
/// throws:
/// <code>DFUStreamHexError</code> if the hex file is invalid.
///
/// returns:
/// The DFU firmware object or <code>nil</code> in case of an error.
- (nullable instancetype)initWithHexFile:(NSData * _Nonnull)hexFile datFile:(NSData * _Nullable)datFile type:(enum DFUFirmwareType)type error:(NSError * _Nullable * _Nullable)error OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// An object containing sizes of all parts of the new firmware.
/// A firmware which is composed of SoftDevice and Bootloader has only
/// the total size of the stack component, not individual sizes. To indicate that
/// the size of the bootloader is 1 and the size of SoftDevice is the total size - 1.
SWIFT_CLASS("_TtC9ZTCoreKit15DFUFirmwareSize")
@interface DFUFirmwareSize : NSObject
/// Size of the SoftDevice in bytes.
/// If not even, add it to the bootloader size to get size of
/// the system component.
@property (nonatomic, readonly) uint32_t softdevice;
/// Size of the bootloader in bytes.
/// If equal to 1 the ZIP contains SD+BL and size of SD or BL is not known exactly,
/// but their sum is known.
@property (nonatomic, readonly) uint32_t bootloader;
/// Size of the application in bytes.
@property (nonatomic, readonly) uint32_t application;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// The type of the BIN or HEX file, or selection of content from the Distribution
/// packet (ZIP) file.
/// Select <code>softdeviceBootloaderApplication</code> to sent all files from the ZIP
/// (even it there is let’s say only application). This works as a filter.
/// If you have SD+BL+App in the ZIP, but want to send only App, you may set the
/// type to <code>application</code>.
typedef SWIFT_ENUM(uint8_t, DFUFirmwareType, open) {
/// Firmware file will be sent as a new SoftDevice.
  DFUFirmwareTypeSoftdevice = 1,
/// Firmware file will be sent as a new Bootloader.
  DFUFirmwareTypeBootloader = 2,
/// Firmware file will be sent as a new Application.
  DFUFirmwareTypeApplication = 4,
/// Firmware file will be sent as a new SoftDevice + Bootloader.
  DFUFirmwareTypeSoftdeviceBootloader = 3,
/// All content of the ZIP file will be sent.
  DFUFirmwareTypeSoftdeviceBootloaderApplication = 7,
};

@class CBPeripheral;
@class NSNumber;
@class CBUUID;
/// The DFU peripheral selector delegate is used to select the device advertising in
/// DFU bootloader mode after switching from application mode.
/// When a peripheral is switching to the bootloader mode that will change its MAC
/// address the library needs to select the correct device to continue the DFU
/// process. As MAC addresses are not exposed using iOS API, the selector
/// provides a mechanism choosing the correct target.
/// The default implementation is provided by <code>DFUPeripheralSelector</code>.
/// This library supports sending both BIN files from a ZIP Distribution
/// Packet automatically. However, when sending the SoftDevice update, the
/// DFU Bootloader may remove the current application in order to make space
/// for the new SoftDevice firmware (Legacy DFU, or Secure DFU with single
/// bank enabled when new SD+BL are larger then space available) or may
/// advertise in Bootloader mode for number of seconds (Secure DFU). When the
/// new SoftDevice is flashed the bootloader restarts the device and starts
/// advertising in DFU Bootloader mode.
/// Since SDK 8.0.0, to solve caching problem on a host that is not bonded
/// (in case there is no Service Changed characteristic), the bootloader
/// starts to advertise with an address incremented by 1. The DFU Library has
/// to scan for a peripheral with this new address. However, as iOS does not
/// expose the device address in the public CoreBluetooth API, address matching,
/// used on Android, can not be used. Instead, this selector is used. The DFU
/// Service will start scanning for peripherals with a UUID filter, where the
/// list of required UUID is returned by the <code>filterBy(hint:)</code> method. If your
/// device in the Bootloader mode does not advertise with any service UUIDs,
/// or this is not enough, you may select a target device by their advertising
/// packet or RSSI using this delegate.
/// In SDK 14.0.0 a new feature was added to the Buttonless DFU for non-bonded
/// devices which allows to send a unique name to the device before it is
/// switched to bootloader mode. After jump, the bootloader will advertise
/// with this name as the Complete Local Name making it easy to select proper
/// device. In this case you don’t have to override the default peripheral
/// selector.
/// Read more about the new feature on <a href="https://infocenter.nordicsemi.com/topic/sdk_nrf5_v17.1.0/ble_sdk_app_buttonless_dfu.html?cp=9_1_4_4_1">Infocenter</a>.
SWIFT_PROTOCOL("_TtP9ZTCoreKit29DFUPeripheralSelectorDelegate_")
@protocol DFUPeripheralSelectorDelegate
/// Returns whether the given peripheral is a device in DFU Bootloader mode.
/// \param peripheral The peripheral to be checked.
///
/// \param advertisementData Scanned advertising data.
///
/// \param RSSI Received signal strength indication in dBm.
///
/// \param name An optional name to look for in the
/// advertisement packet (see Buttonless DFU in SDK 14).
///
///
/// returns:
/// True (YES) if given peripheral is what service is looking for.
- (BOOL)select:(CBPeripheral * _Nonnull)peripheral advertisementData:(NSDictionary<NSString *, id> * _Nonnull)advertisementData RSSI:(NSNumber * _Nonnull)RSSI hint:(NSString * _Nullable)name SWIFT_WARN_UNUSED_RESULT;
/// Returns an optional list of services that the scanner will use to filter
/// advertising packets when scanning for a device in DFU Bootloader mode.
/// To find out what UUID you should return, switch your device to DFU Bootloader
/// mode (with a button!) and check the advertisement packet. The result of this
/// method will be applied to
/// <code>centralManager.scanForPeripherals(withServices: [CBUUID]?, options: [String : AnyObject]?)</code>.
/// \param dfuServiceUUID The UUID of the DFU service that was used to
/// flash SoftDevice and/or Bootloader. Usually, this
/// service UUID is present in the DFU Bootloader’s
/// advertising packet. Then this method may simply
/// return <code>[dfuServiceUUID]</code>.
///
///
/// returns:
/// An optional list of services or nil.
- (NSArray<CBUUID *> * _Nullable)filterByHint:(CBUUID * _Nonnull)dfuServiceUUID SWIFT_WARN_UNUSED_RESULT;
@end

/// The default implementation of <code>DFUPeripheralSelectorDelegate</code>.
/// Selects the first device with Legacy or Secure DFU Service UUID in the advertising packet.
SWIFT_CLASS("_TtC9ZTCoreKit21DFUPeripheralSelector")
@interface DFUPeripheralSelector : NSObject <DFUPeripheralSelectorDelegate>
- (BOOL)select:(CBPeripheral * _Nonnull)peripheral advertisementData:(NSDictionary<NSString *, id> * _Nonnull)advertisementData RSSI:(NSNumber * _Nonnull)RSSI hint:(NSString * _Nullable)name SWIFT_WARN_UNUSED_RESULT;
- (NSArray<CBUUID *> * _Nullable)filterByHint:(CBUUID * _Nonnull)dfuServiceUUID SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// The progress delegates may be used to notify user about progress updates.
/// The only method of the delegate is only called when the service is in the
/// Uploading state.
SWIFT_PROTOCOL("_TtP9ZTCoreKit19DFUProgressDelegate_")
@protocol DFUProgressDelegate
/// Callback called in the <code>DFUState/uploading</code> state during firmware upload.
/// Gives detailed information about the progress and speed of transmission.
/// This method is always called at least two times (for 0% and 100%) if upload has
/// started and did not fail and is not called multiple times for the same number of
/// percentage.
/// This method is called in the thread set as <code>progressQueue</code> in
/// <code>DFUServiceInitiator/init(queue:delegateQueue:progressQueue:loggerQueue:centralManagerOptions:)</code>.
/// \param part Number of part that is currently being transmitted. Parts
/// start from 1 and may have value either 1 or 2. Part 2 is
/// used only when there were Soft Device and/or Bootloader AND
/// an Application in the Distribution Packet and the DFU target
/// does not support sending all files in a single connection.
/// First the SD and/or BL will be sent, then the service will
/// disconnect, reconnect again to the (new) bootloader and send
/// the Application.
///
/// \param totalParts Total number of parts that are to be send (this is always
/// equal to 1 or 2).
///
/// \param progress The current progress of uploading the current part in
/// percentage (values 0-100).
/// Each value will be called at most once - in case of a large
/// file a value e.g. 3% will be called only once, despite that
/// it will take more than one packet to reach 4%. In case of
/// a small firmware file some values may be omitted.
/// For example, if firmware file would be only 20 bytes you
/// would get a callback 0% (called always) and then 100% when done.
///
/// \param currentSpeedBytesPerSecond The current speed in bytes per second.
///
/// \param avgSpeedBytesPerSecond The average speed in bytes per second.
///
- (void)dfuProgressDidChangeFor:(NSInteger)part outOf:(NSInteger)totalParts to:(NSInteger)progress currentSpeedBytesPerSecond:(double)currentSpeedBytesPerSecond avgSpeedBytesPerSecond:(double)avgSpeedBytesPerSecond;
@end

/// The controller allows pausing, resuming or aborting the ongoing DFU operation.
/// Use of the controller is optional. An application does not have to allow users to do any of the actions.
SWIFT_CLASS("_TtC9ZTCoreKit20DFUServiceController")
@interface DFUServiceController : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Call this method to pause uploading during the transmission process.
/// The transmission can be resumed only when connection remains. If service
/// has already started sending firmware data it will pause after receiving
/// next Packet Receipt Notification. Otherwise it will continue to send
/// Op Codes and pause before sending the first bytes of the firmware. With
/// Packet Receipt Notifications disabled it is the only moment when upload
/// may be paused.
- (void)pause;
/// Call this method to resume the paused transfer, otherwise does nothing.
- (void)resume;
/// Aborts the upload.
/// As a result, the phone will disconnect from peripheral. The peripheral
/// will try to recover the last firmware. Had the application been removed, the device
/// will restart in the DFU bootloader mode.
/// Aborting DFU does not cancel pending connection attempt. It is only when the service
/// is sending firmware or an Op Code that the operation can be stopped.
///
/// returns:
/// <code>True</code> if DFU has been aborted; <code>false</code> otherwise.
- (BOOL)abort SWIFT_WARN_UNUSED_RESULT;
/// Starts again aborted DFU operation.
- (void)restart;
/// Returns <code>true</code> if DFU operation has been paused.
@property (nonatomic, readonly) BOOL paused;
/// Returns <code>true</code> if DFU operation has been aborted.
@property (nonatomic, readonly) BOOL aborted;
@end

enum DFUState : NSInteger;
/// The service delegate reports about state changes and errors.
SWIFT_PROTOCOL("_TtP9ZTCoreKit18DFUServiceDelegate_")
@protocol DFUServiceDelegate
/// Callback called when state of the DFU Service has changed.
/// This method is called in the <code>delegateQueue</code> specified in the
/// <code>DFUServiceInitiator/init(queue:delegateQueue:progressQueue:loggerQueue:centralManagerOptions:)</code>.
/// \param state The new state of the service.
///
- (void)dfuStateDidChangeTo:(enum DFUState)state;
/// Called after an error occurred.
/// The device will be disconnected and DFU operation has been cancelled.
/// note:
/// When an error is received the DFU state will not change to <code>DFUState/aborted</code>.
/// This method is called in the <code>delegateQueue</code> specified in the
/// <code>DFUServiceInitiator/init(queue:delegateQueue:progressQueue:loggerQueue:centralManagerOptions:)</code>.
/// \param error The error code.
///
/// \param message Error description.
///
- (void)dfuError:(enum DFUError)error didOccurWithMessage:(NSString * _Nonnull)message;
@end

@protocol LoggerDelegate;
@class DFUUuidHelper;
@class CBCentralManager;
@class NSUUID;
/// The initiator object should be used to initiate updating firmware
/// on a remote Bluetooth LE target compatible with the Nordic Semiconductor’s Legacy or
/// Secure DFU (Device Firmware Update) protocol from nRF5 SDK.
/// A <code>delegate</code>, <code>progressDelegate</code> and <code>logger</code> may be specified in
/// order to receive status information.
/// \code
/// let initiator = DFUServiceInitiator()
/// initiator.logger = self // - to get logs
/// initiator.delegate = self // - to be informed about current state and errors
/// initiator.progressDelegate = self // - to get progress updates
/// // TODO: Check out other properties of the initiator.
///
/// let controller = initiator.with(firmware: selectedFirmware).start(target: peripheral)
///
/// \endcodeUsing the <code>DFUServiceController</code> you may pause, resume or abort the DFU operation.
SWIFT_CLASS("_TtC9ZTCoreKit19DFUServiceInitiator")
@interface DFUServiceInitiator : NSObject
/// The service delegate is an object that will be notified about state changes
/// of the DFU Service.
/// Setting it is optional but recommended.
@property (nonatomic, weak) id <DFUServiceDelegate> _Nullable delegate;
/// An optional progress delegate will be called only during upload.
/// t notifies about current upload percentage and speed.
@property (nonatomic, weak) id <DFUProgressDelegate> _Nullable progressDelegate;
/// The logger delegate receives logs from the service.
@property (nonatomic, weak) id <LoggerDelegate> _Nullable logger;
/// The selector object is used when the device needs to disconnect and start
/// advertising with a different address to avoid caching problems, for example
/// after switching to the Bootloader mode, or during sending a firmware containing
/// a SoftDevice (or SoftDevice and Bootloader) and the Application.
/// After flashing the first part (containing the SoftDevice), the device restarts
/// in the DFU Bootloader mode and may (since SDK 8.0.0) start advertising with an
/// address incremented by 1. The peripheral specified in the <code>start(target:)</code>
/// may no longer be used as there is no device advertising with its address.
/// The DFU Service will scan for a new device and connect to the first device
/// returned by the selector.
/// The default selector (<code>DFUPeripheralSelector</code>) returns the first device
/// with the required DFU Service UUID in the advertising packet
/// (Secure or Legacy DFU Service UUID).
/// Set own selector if your DFU bootloader advertises using custom data.
@property (nonatomic, strong) id <DFUPeripheralSelectorDelegate> _Nonnull peripheralSelector;
/// The number of packets of firmware data to be received by the DFU target before
/// sending a new Packet Receipt Notification.
/// If this value is 0, the packet receipt notification will be disabled by the DFU target.
/// Default value is 12.
/// note:
/// PRNs are no longer required on iOS 11 and MacOS 10.13 or newer, but
/// make sure your device is able to be updated without. Old SDKs, before SDK 7
/// had very slow memory management and could not handle packets that fast.
/// If your device is based on such SDK it is recommended to leave the default value.
/// Disabling PRNs increases upload speed but may cause failures on devices with slow flash
/// memory.
/// On older versions, higher values of PRN (~20+), or disabling it, may speed up
/// the upload process, but also cause a buffer overflow and hang the Bluetooth adapter.
/// Maximum verified values were 29 for iPhone 6 Plus or 22 for iPhone 7, both iOS 10.1.
@property (nonatomic) uint16_t packetReceiptNotificationParameter;
/// Should the Legacy DFU service assume the device is in bootloader mode despite
/// absence of the DFU Version characteristic.
/// important:
/// This property is only meaningful for devices supporting Legacy DFU without
/// DFU Version characteristic  (nRF5 SDK 4.3 - 7) and is ignored otherwise.
/// Setting this property to <code>true</code> will prevent from jumping to the DFU Bootloader
/// mode in case there is no DFU Version characteristic. Use it if the DFU operation
/// can be handled by your device running in the application mode. If the DFU Version
/// characteristic exists, the information whether to begin DFU operation, or jump to
/// bootloader, is taken from the characteristic’s value. The value returned equal to
/// <code>0x0100</code> (read as: minor=1, major=0, or version 0.1) means that the device is in the
/// application mode and buttonless jump to DFU Bootloader is supported.
/// Currently, the following values of the DFU Version characteristic are supported:
/// <em>No DFU Version characteristic</em> - one of the first implementations of DFU Service.
/// The device may support only Application update (version from SDK 4.3.0), may support
/// Soft Device, Bootloader and Application update but without buttonless jump to
/// bootloader (SDK 6.0.0) or with buttonless jump (SDK 6.1.0).
/// The DFU Library determines whether the device is in application mode or in DFU
/// Bootloader mode by counting number of services: if no DFU Service found - device
/// is in app mode and does not support buttonless jump, if the DFU Service is the only
/// service found (except General Access and General Attribute services) - it assumes
/// it is in DFU Bootloader mode and may start DFU immediately, if there is at least
/// one service except DFU Service - the device is in application mode and supports
/// buttonless jump. In the last case, you want to perform DFU operation without
/// jumping - set the <code>forceDfu</code> property to <code>true</code>.
/// <em>0.1</em> - Device is in a mode that supports buttonless jump to the DFU Bootloader.
/// <em>0.5</em> - Device can handle DFU operation. Extended Init packet is required.
/// Bond information is lost in the bootloader mode and after updating an app.
/// Released in SDK 7.0.0.
/// <em>0.6</em> - Bond information is kept in bootloader mode and may be kept after
/// updating application (DFU Bootloader must be configured to preserve the bond
/// information).
/// <em>0.7</em> - The SHA-256 firmware hash is used in the Extended Init Packet instead
/// of CRC-16. This feature is transparent for the DFU Service.
/// <em>0.8</em> - The Extended Init Packet is signed using the private key. The bootloader,
/// using the public key, is able to verify the content. Released in SDK 9.0.0 as
/// experimental feature.
/// Caution! The firmware type (Application, Bootloader, SoftDevice or SoftDevice +
/// Bootloader) is not encrypted as it is not a part of the Extended Init Packet.
/// A change in the protocol will be required to fix this issue.
/// By default the DFU Library will try to switch the device to the DFU Bootloader
/// mode if it finds more services then one (DFU Service). It assumes it is already
/// in the bootloader mode if the only service found is the DFU Service. Setting the
/// <code>forceDfu</code> to <code>true</code> will prevent from jumping in these both cases.
@property (nonatomic) BOOL forceDfu;
/// Should the Legacy DFU service scan for the device after switching to bootloader mode.
/// By default, the Legacy DFU bootloader, starting from SDK 7.1, when enabled using
/// buttonless service, advertises with the same Bluetooth address as the application
/// using direct advertisement. This complies with the Bluetooth specification.
/// However, on iOS 13.x, iPhones and iPads use random addresses on each
/// connection and do not expect direct advertising unless bonded. This causes those
/// packets being missed and not reported to the library, making reconnection to the
/// bootloader and proceeding with DFU impossible.
/// A solution requires modifying either the bootloader not to use the direct advertising,
/// or the application not to share the peer data with bootloader, in which case it will
/// advertise indirectly using address +1, like it does when the switch to bootloader mode
/// is initiated with a button. After such modification, setting this flag to true will make the
/// library scan for the bootloader using <code>DFUPeripheralSelector</code>.
/// Setting this flag to <code>true</code> without modifying the bootloader behavior will break the DFU,
/// as the direct advertising packets are empty and will not pass the default
/// <code>DFUPeripheralSelector</code>.
/// since:
/// 4.8.0
@property (nonatomic) BOOL forceScanningForNewAddressInLegacyDfu;
/// Connection timeout.
/// When the DFU target does not connect before the time runs out, a timeout error
/// is reported.
/// since:
/// 4.8.0
@property (nonatomic) NSTimeInterval connectionTimeout;
/// Duration of a delay, that the service will wait before sending each data object in
/// Secure DFU.
/// The delay will be done after a data object is created, and before
/// any data byte is sent. The default value is 0, which disables this feature for the
/// second and following data objects, but the first one will be delayed by 0.4 sec.
/// It has been found, that a delay of at least 0.3 sec reduces the risk of packet lose
/// (the bootloader needs some time to prepare flash memory) on DFU bootloader from
/// SDK 15, 16 and 17. The delay does not have to be longer than 0.4 sec, as according to
/// performed tests, such delay is sufficient.
/// The longer the delay, the more time DFU will take to complete (delay will be repeated for
/// each data object (4096 bytes)). However, with too small delay a packet lose may occur,
/// causing the service to enable PRN and set them to 1 making DFU process very, very slow
/// (but reliable).
/// The recommended delay is from 0.3 to 0.4 second if your DFU bootloader is from
/// SDK 15, 16 or 17. Older bootloaders do not need this delay.
/// This variable is ignored in Legacy DFU.
/// since:
/// 4.8.0
@property (nonatomic) NSTimeInterval dataObjectPreparationDelay;
/// Should the bootloader use random name to make it distinguishable from other devices.
/// In SDK 14.0.0 a new feature was added to the Buttonless DFU for non-bonded
/// devices which allows to send a unique name to the device before it is switched
/// to bootloader mode. After jump, the bootloader will advertise with this name
/// as the Complete Local Name making it easy to select proper device. In this case
/// you don’t have to override the default peripheral selector.
/// Read more at <a href="http://infocenter.nordicsemi.com/topic/com.nordic.infocenter.sdk5.v14.0.0/service_dfu.html">SDK 14.0 documentation at Infocenter</a>.
/// Setting this flag to <code>false</code> you will disable this feature. iOS DFU Library will
/// not send the <code>0x02-[len]-[new name]</code> command prior jumping and will
/// rely on the <code>peripheralSelector</code> just like it used to in previous SDK.
/// This flag is ignored in Legacy DFU.
/// <em>It is recommended to keep this flag set to true unless necessary.</em>
/// For more information read <a href="https://github.com/NordicSemiconductor/IOS-nRF-Connect/issues/16">Issue 16</a>.
@property (nonatomic) BOOL alternativeAdvertisingNameEnabled;
/// The name the bootloader should use in advertisement.
/// If <code>alternativeAdvertisingNameEnabled</code> is <code>true</code> then this specifies the
/// alternative name to use. If <code>nil</code> (default) then a random name is generated.
/// The maximum length of the alternative advertising name is 20 bytes.
/// Longer name will be truncated. UTF-8 characters can be cut in the middle.
@property (nonatomic, copy) NSString * _Nullable alternativeAdvertisingName;
/// Should the library discover Experimental Buttonless Service from nRF5 SDK version 12.
/// Set this flag to <code>true</code> to enable experimental buttonless feature in Secure DFU.
/// When the experimental Buttonless DFU Service is found on a device, the service
/// will use it to switch the device to the bootloader mode, connect to it in that
/// mode and proceed with DFU.
/// In the SDK 12.x the Buttonless DFU feature for Secure DFU was experimental.
/// It is NOT recommended to use it: it was not properly tested, had implementation bugs
/// (e.g. <a href="https://devzone.nordicsemi.com/question/100609/sdk-12-bootloader-erased-after-programming/">this one</a>)
/// and does not required encryption and therefore may lead to DOS attack (anyone can
/// use it to switch the device to bootloader mode). However, as there is no other way
/// to trigger bootloader mode on devices without a button, this DFU Library supports
/// this service, but the feature must be explicitly enabled here. Be aware, that setting
/// this flag to <code>false</code> will no protect your devices from this kind of attacks, as
/// an attacker may use another app for that purpose.
/// Spec:
/// Buttonless DFU Service UUID: <code>8E400001-F315-4F60-9FB8-838830DAEA50</code>
/// Buttonless DFU characteristic UUID: <code>8E400001-F315-4F60-9FB8-838830DAEA50</code> (the same)
/// Enter Bootloader Op Code: <code>0x01</code>
/// Correct return value: <code>0x20-01-01</code> , where:
/// <code>0x20</code> - Response Op Code
/// <code>0x01</code> - Request Code
/// <code>0x01</code> - Success
/// The device should disconnect and restart in DFU mode after sending the notification.
/// In SDK 13 this issue was be fixed by a proper implementation (bonding supported,
/// passing bond information to the bootloader, encryption, well tested).
/// It is recommended to migrate to SDK 13 or newer
@property (nonatomic) BOOL enableUnsafeExperimentalButtonlessServiceInSecureDfu;
/// UUIDs used during the DFU Process.
/// This allows you to pass in Custom UUIDs for the DFU Service/Characteristics.
@property (nonatomic, strong) DFUUuidHelper * _Nonnull uuidHelper;
/// Disable the ability for the Secure DFU process to resume from where it was.
/// By default this is set to <code>false</code>. This property applies only to Secure DFU.
/// since:
/// 4.3.0
@property (nonatomic) BOOL disableResume;
/// Creates the <code>DFUServiceInitializer</code> which allows updating firmware on
/// Bluetooth LE devices supporting Legacy or Secure DFU from nRF5 SDK from
/// Nordic Semiconductor..
/// This constructor takes control over the central manager and peripheral objects.
/// Their delegates will be set to internal library objects and will NOT be reverted to
/// original objects, instead they will be set to nil when DFU is complete, aborted or
/// has failed with an error. An app should restore the delegates (if needed) after
/// receiving state <code>DFUState/completed</code> or <code>DFUState/aborted</code>,
/// or receiving an error.
/// important:
/// This constructor has been deprecated in favor of
/// <code>init(queue:delegateQueue:progressQueue:loggerQueue:centralManagerOptions:)</code>,
/// which does not take control over the given peripheral, using a copy instead.
/// seealso:
/// <code>peripheralSelector</code> - a selector used when scanning for a device
/// in DFU Bootloader mode in case you want to update a SoftDevice and
/// Application from a single ZIP Distribution Packet.
/// \param centralManager Manager that will be used to connect to the peripheral
///
/// \param target The DFU target peripheral.
///
///
/// returns:
/// The initiator instance.
- (nonnull instancetype)initWithCentralManager:(CBCentralManager * _Nonnull)centralManager target:(CBPeripheral * _Nonnull)target OBJC_DESIGNATED_INITIALIZER SWIFT_DEPRECATED_MSG("Use init(queue: DispatchQueue?) instead.");
/// Creates the <code>DFUServiceInitializer</code> which allows updating firmware on
/// Bluetooth LE devices supporting Legacy or Secure DFU from nRF5 SDK from
/// Nordic Semiconductor..
/// version:
/// Added in version 4.2 of the iOS DFU Library. Extended in 4.3 to allow
/// setting delegate queues.
/// seealso:
/// <code>peripheralSelector</code> - a selector used when scanning for a
/// device in DFU Bootloader mode in case you want to update a SoftDevice
/// and Application from a single ZIP Distribution Packet.
/// \param queue The dispatch queue to run BLE operations on.
///
/// \param delegateQueue The dispatch queue to invoke all delegate callbacks on.
///
/// \param progressQueue The dispatch queue to invoke all progress delegate
/// callbacks on.
///
/// \param loggerQueue The dispatch queue to invoke all logger events on.
///
/// \param centralManagerOptions An optional dictionary that contains initialization options for <code>CBCentralManager</code>.
///
///
/// returns:
/// The initiator instance.
- (nonnull instancetype)initWithQueue:(dispatch_queue_t _Nullable)queue delegateQueue:(dispatch_queue_t _Nonnull)delegateQueue progressQueue:(dispatch_queue_t _Nonnull)progressQueue loggerQueue:(dispatch_queue_t _Nonnull)loggerQueue centralManagerOptions:(NSDictionary<NSString *, id> * _Nullable)centralManagerOptions OBJC_DESIGNATED_INITIALIZER;
/// Sets the file with the firmware.
/// The file must be specified before calling <code>start(target:)</code>
/// or <code>start(targetWithIdentifier:)</code> method.
/// \param file The firmware wrapper object.
///
///
/// returns:
/// The initiator instance to allow chain use.
- (DFUServiceInitiator * _Nonnull)withFirmware:(DFUFirmware * _Nonnull)file SWIFT_WARN_UNUSED_RESULT;
/// Starts sending the specified firmware to the DFU target specified in
/// <code>init(centralManager:target:)</code>.
/// When started, the service will automatically connect to the target, switch to
/// DFU Bootloader mode (if necessary), and send all the content of the specified
/// firmware file in one or two connections.
/// Two connections will be used if a ZIP file contains a SoftDevice and/or
/// Bootloader and an Application. First the SoftDevice and/or Bootloader will
/// be transferred, then the service will disconnect, reconnect to the (new)
/// Bootloader again and send the Application (unless the target supports
/// receiving all files in a single connection). The peripheral will NOT be
/// reconnected after the DFU is completed, aborted or has failed.
/// important:
/// Use <code>start(target:)</code> or <code>start(targetWithIdentifier:)</code> instead.
///
/// returns:
/// A <code>DFUServiceController</code> object that can be used to control the
/// DFU operation, or <code>nil</code>, if the file was not set, or the target
/// peripheral was not set.
- (DFUServiceController * _Nullable)start SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("Use start(target: CBPeripheral) instead.");
/// Starts sending the specified firmware to the given DFU target.
/// When started, the service will automatically connect to the target, switch to
/// DFU Bootloader mode (if necessary), and send all the content of the specified
/// firmware file in one or two connections. Two connections will be used if a ZIP
/// file contains a SoftDevice and/or Bootloader and an Application. First, the
/// SoftDevice and/or Bootloader will be transferred, then the service will disconnect,
/// reconnect to the (new) Bootloader again and send the Application (unless the
/// target supports receiving all files in a single connection). The peripheral
/// will NOT be reconnected after the DFU is completed, aborted or has failed.
/// This method does not take control over the peripheral.
/// A new central manager is used, from which a copy of the peripheral is retrieved.
/// Be warned, that the original peripheral delegate may receive a lot of calls, and
/// it will restart during the process. The app should not send any data to DFU
/// characteristics when DFU is in progress.
/// \param target The DFU target peripheral.
///
///
/// returns:
/// A <code>DFUServiceController</code> object that can be used to control the DFU
/// operation, or <code>nil</code>, if the file was not set, or the peripheral instance
/// could not be retrieved.
- (DFUServiceController * _Nullable)startWithTarget:(CBPeripheral * _Nonnull)target SWIFT_WARN_UNUSED_RESULT;
/// Starts sending the specified firmware to the DFU target with given identifier.
/// When started, the service will automatically connect to the target, switch to
/// DFU Bootloader mode (if necessary), and send all the content of the specified
/// firmware file in one or two connections. Two connections will be used if a ZIP
/// file contains a SoftDevice and/or Bootloader and an Application. First, the
/// SoftDevice and/or Bootloader will be transferred, then the service will disconnect,
/// reconnect to the (new) Bootloader again and send the Application (unless the
/// target supports receiving all files in a single connection). The peripheral
/// will NOT be reconnected after the DFU is completed, aborted or has failed.
/// This method does not take control over the peripheral.
/// A new central manager is used, from which a copy of the peripheral is retrieved.
/// Be warned, that the original peripheral delegate may receive a lot of calls, and
/// it will restart during the process. The app should not send any data to DFU
/// characteristics when DFU is in progress.
/// \param uuid The UUID associated with the peer.
///
///
/// returns:
/// A <code>DFUServiceController</code> object that can be used to control the DFU
/// operation, or <code>nil</code>, if the file was not set, or the peripheral instance
/// could not be retrieved.
- (DFUServiceController * _Nullable)startWithTargetWithIdentifier:(NSUUID * _Nonnull)uuid SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// The state of the DFU Service.
/// The new state is returned using <code>DFUServiceDelegate/dfuStateDidChange(to:)</code>
/// set as <code>DFUServiceInitiator/delegate</code>.
/// When the DFU operation ends with an error, the error is reported using
/// <code>DFUServiceDelegate/dfuError(_:didOccurWithMessage:)</code>.
/// In that case the state change is not reported.
typedef SWIFT_ENUM(NSInteger, DFUState, open) {
/// Service is connecting to the DFU target.
  DFUStateConnecting = 0,
/// DFU Service is initializing DFU operation.
  DFUStateStarting = 1,
/// DFU Service is switching the device to DFU mode.
  DFUStateEnablingDfuMode = 2,
/// DFU Service is uploading the firmware.
  DFUStateUploading = 3,
/// The DFU target is validating the firmware. This state occurs only in Legacy DFU.
  DFUStateValidating = 4,
/// The iDevice is disconnecting or waiting for disconnection.
  DFUStateDisconnecting = 5,
/// DFU operation is completed and successful.
  DFUStateCompleted = 6,
/// DFU operation was aborted.
  DFUStateAborted = 7,
};

enum DFUUuidType : NSInteger;
/// DFU UUID object.
SWIFT_CLASS("_TtC9ZTCoreKit7DFUUuid")
@interface DFUUuid : NSObject
/// UUID For the DFU UUID Object.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull uuid;
/// Type of DFU UUID.
@property (nonatomic, readonly) enum DFUUuidType type;
- (nonnull instancetype)initWithUUID:(CBUUID * _Nonnull)withUUID forType:(enum DFUUuidType)forType OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// UUID Helper for DFU Process.
/// The UUID can be modified for each of the DFU types supported by
/// the Nordic devices.
SWIFT_CLASS("_TtC9ZTCoreKit13DFUUuidHelper")
@interface DFUUuidHelper : NSObject
/// UUID for Legacy DFU Service.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull legacyDFUService;
/// UUID for Legacy DFU Control Point Characteristic.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull legacyDFUControlPoint;
/// UUID for Legacy DFU Packet Characteristic.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull legacyDFUPacket;
/// UUID for Legacy DFU Version Characteristic.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull legacyDFUVersion;
/// UUID for Secure DFU Service.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull secureDFUService;
/// UUID for Secure DFU Control Characteristic.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull secureDFUControlPoint;
/// UUID for Secure DFU Packet Characteristic.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull secureDFUPacket;
/// UUID for Buttonless DFU Service.
/// This UUID is also used for the Characteristic.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull buttonlessExperimentalService;
/// UUID for Buttonless DFU Characteristic.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull buttonlessExperimentalCharacteristic;
/// UUID for Buttonless DFU Without Bond Sharing Characteristic.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull buttonlessWithoutBonds;
/// UUID for Buttonless DFU With Bond Sharing Characteristic.
@property (nonatomic, readonly, strong) CBUUID * _Nonnull buttonlessWithBonds;
/// Creates the DFU Helper with Default UUIDs.
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Create the DFU UUID Helper with Custom UUIDs.
/// \param uuids Array of Custom UUIDs.
///
- (nonnull instancetype)initWithCustomUuids:(NSArray<DFUUuid *> * _Nonnull)uuids;
@end

/// UUID Types for DFU.
typedef SWIFT_ENUM(NSInteger, DFUUuidType, open) {
/// Legacy DFU Service.
  DFUUuidTypeLegacyService = 0,
/// Legacy DFU Control Point Characteristic.
  DFUUuidTypeLegacyControlPoint = 1,
/// Legacy DFU Packet Characteristic.
  DFUUuidTypeLegacyPacket = 2,
/// Legacy DFU Version Characteristic.
  DFUUuidTypeLegacyVersion = 3,
/// Secure DFU Service.
  DFUUuidTypeSecureService = 4,
/// Secure DFU Control Characteristic.
  DFUUuidTypeSecureControl = 5,
/// Secure DFU Packet Characteristic.
  DFUUuidTypeSecurePacket = 6,
/// Buttonless DFU Service.
  DFUUuidTypeButtonlessService = 7,
/// Buttonless DFU Characteristic.
  DFUUuidTypeButtonlessCharacteristic = 8,
/// Buttonless DFU Without Bond Sharing Characteristic.
  DFUUuidTypeButtonlessWithoutBondSharing = 9,
/// Buttonless DFU With Bond Sharing Characteristic.
  DFUUuidTypeButtonlessWithBondSharing = 10,
};

/// This converter converts Intel HEX file to BIN.
/// The <a href="https://en.wikipedia.org/wiki/Intel_HEX">Intel HEX</a> specification can be found here:
/// <a href="http://www.interlog.com/~speff/usefulinfo/Hexfrmt.pdf">link</a>.
/// note:
/// Not all Intel HEX features are supported. The converter does not support gaps in the firmware.
/// The returned BIN contains data until the first found gap.
/// Supported Record Types:
/// \code
/// 0x04 - Extended Linear Address Record
/// 0x02 - Extended Segment Address Record
/// 0x01 - End of File
/// 0x00 - Data Record
///
/// \endcodeIf MBR size is provided, the values from addresses <code>0..<MBR Size</code> will be ignored.
SWIFT_CLASS("_TtC9ZTCoreKit21IntelHex2BinConverter")
@interface IntelHex2BinConverter : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// This initiator can be used to start a DFU process using Legacy DFU service.
/// The default <code>DFUServiceInitiator</code> will select the proper executor based
/// on the discovered services. If you know your device supports the Legacy DFU you may
/// consider using this initiator instead to skip that part.
SWIFT_CLASS("_TtC9ZTCoreKit25LegacyDFUServiceInitiator")
@interface LegacyDFUServiceInitiator : DFUServiceInitiator
- (DFUServiceController * _Nullable)startWithTargetWithIdentifier:(NSUUID * _Nonnull)uuid SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithCentralManager:(CBCentralManager * _Nonnull)centralManager target:(CBPeripheral * _Nonnull)target OBJC_DESIGNATED_INITIALIZER SWIFT_DEPRECATED_MSG("Use init(queue: DispatchQueue?) instead.");
- (nonnull instancetype)initWithQueue:(dispatch_queue_t _Nullable)queue delegateQueue:(dispatch_queue_t _Nonnull)delegateQueue progressQueue:(dispatch_queue_t _Nonnull)progressQueue loggerQueue:(dispatch_queue_t _Nonnull)loggerQueue centralManagerOptions:(NSDictionary<NSString *, id> * _Nullable)centralManagerOptions OBJC_DESIGNATED_INITIALIZER;
@end

/// Log levels used by the <code>LoggerDelegate</code>.
/// Logger application may filter log entries based on their level.
/// Levels allow to categorize message by importance.
typedef SWIFT_ENUM(NSInteger, LogLevel, open) {
/// Lowest priority. Usually names of called methods or callbacks received.
  LogLevelDebug = 0,
/// Low priority messages what the service is doing.
  LogLevelVerbose = 1,
/// Messages about completed tasks.
  LogLevelInfo = 5,
/// Messages about application level events, in this case DFU message
/// in human-readable form.
  LogLevelApplication = 10,
/// Important messages.
  LogLevelWarning = 15,
/// Highest priority messages with errors.
  LogLevelError = 20,
};

/// The Logger delegate.
SWIFT_PROTOCOL("_TtP9ZTCoreKit14LoggerDelegate_")
@protocol LoggerDelegate
/// This method is called on every log event..
/// The logger implementation should save log entries or present them to the user.
/// It is NOT safe to update any UI from this method as multiple threads may log.
/// \param level The log level.
///
/// \param message The message.
///
- (void)logWith:(enum LogLevel)level message:(NSString * _Nonnull)message;
@end

/// This initiator can be used to start a DFU process using Secure DFU service.
/// The default <code>DFUServiceInitiator</code> will select the proper executor based
/// on the discovered services. If you know your device supports the Secure DFU you may
/// consider using this initiator instead to skip that part.
SWIFT_CLASS("_TtC9ZTCoreKit25SecureDFUServiceInitiator")
@interface SecureDFUServiceInitiator : DFUServiceInitiator
- (DFUServiceController * _Nullable)startWithTargetWithIdentifier:(NSUUID * _Nonnull)uuid SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithCentralManager:(CBCentralManager * _Nonnull)centralManager target:(CBPeripheral * _Nonnull)target OBJC_DESIGNATED_INITIALIZER SWIFT_DEPRECATED_MSG("Use init(queue: DispatchQueue?) instead.");
- (nonnull instancetype)initWithQueue:(dispatch_queue_t _Nullable)queue delegateQueue:(dispatch_queue_t _Nonnull)delegateQueue progressQueue:(dispatch_queue_t _Nonnull)progressQueue loggerQueue:(dispatch_queue_t _Nonnull)loggerQueue centralManagerOptions:(NSDictionary<NSString *, id> * _Nullable)centralManagerOptions OBJC_DESIGNATED_INITIALIZER;
@end

@class NSEntityDescription;
@class NSManagedObjectContext;
SWIFT_CLASS_NAMED("ZTActivity")
@interface ZTActivity : NSManagedObject
- (nonnull instancetype)initWithEntity:(NSEntityDescription * _Nonnull)entity insertIntoManagedObjectContext:(NSManagedObjectContext * _Nullable)context OBJC_DESIGNATED_INITIALIZER;
@end

@class ZTPacket;
@class NSSet;
@interface ZTActivity (SWIFT_EXTENSION(ZTCoreKit))
- (void)addPacketsObject:(ZTPacket * _Nonnull)value;
- (void)removePacketsObject:(ZTPacket * _Nonnull)value;
- (void)addPackets:(NSSet * _Nonnull)values;
- (void)removePackets:(NSSet * _Nonnull)values;
@end

@class NSDate;
@interface ZTActivity (SWIFT_EXTENSION(ZTCoreKit))
@property (nonatomic, copy) NSString * _Nullable activityIdentifier;
@property (nonatomic, copy) NSString * _Nullable activityType;
@property (nonatomic) int64_t anchorTimestamp;
@property (nonatomic, copy) NSString * _Nullable appId;
@property (nonatomic) int16_t chunkCount;
@property (nonatomic) int16_t customActivityFirstChunkId;
@property (nonatomic) int64_t customActivityStartTimestamp;
@property (nonatomic, copy) NSDate * _Nullable endDate;
@property (nonatomic) int64_t endTimestamp;
@property (nonatomic) int16_t firstChunkId;
@property (nonatomic) BOOL forceStop;
@property (nonatomic, copy) NSString * _Nullable fwVersion;
@property (nonatomic, copy) NSString * _Nullable id;
@property (nonatomic) BOOL invalid;
@property (nonatomic) BOOL isAutomatic;
@property (nonatomic) BOOL isInterrupted;
@property (nonatomic) BOOL isRawDataMode;
@property (nonatomic) int16_t lastChunkId;
@property (nonatomic, copy) NSData * _Nullable metaDataRawValue;
@property (nonatomic, copy) NSString * _Nullable shoesSerial;
@property (nonatomic, copy) NSDate * _Nullable startDate;
@property (nonatomic) int64_t startTimestamp;
@property (nonatomic) int16_t status;
@property (nonatomic, copy) NSData * _Nullable stopReasonRawValue;
@property (nonatomic, copy) NSString * _Nullable tz;
@property (nonatomic, strong) NSSet * _Nullable packets;
@end

/// BLE Manager responsible for finding and connecting to peripherals. It can be subscribed to be notified about
/// <ul>
///   <li>
///     onBluetoothStateChange (Bluetooth state changed)
///   </li>
///   <li>
///     onDeviceDiscovered (Device discovered)
///   </li>
///   <li>
///     onDeviceStateChange (Device connected / disconnected)
///   </li>
///   <li>
///     onDeviceConnectionFailed ()
///   </li>
/// </ul>
SWIFT_CLASS("_TtC9ZTCoreKit12ZTBleManager")
@interface ZTBleManager : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@interface ZTBleManager (SWIFT_EXTENSION(ZTCoreKit)) <CBCentralManagerDelegate>
/// :nodoc:
- (void)centralManager:(CBCentralManager * _Nonnull)central willRestoreState:(NSDictionary<NSString *, id> * _Nonnull)dict;
- (void)centralManager:(CBCentralManager * _Nonnull)central connectionEventDidOccur:(CBConnectionEvent)event forPeripheral:(CBPeripheral * _Nonnull)peripheral;
/// :nodoc:
- (void)centralManager:(CBCentralManager * _Nonnull)central didDiscoverPeripheral:(CBPeripheral * _Nonnull)peripheral advertisementData:(NSDictionary<NSString *, id> * _Nonnull)advertisementData RSSI:(NSNumber * _Nonnull)RSSI;
/// :nodoc:
- (void)centralManager:(CBCentralManager * _Nonnull)central didFailToConnectPeripheral:(CBPeripheral * _Nonnull)peripheral error:(NSError * _Nullable)error;
/// :nodoc:
- (void)centralManager:(CBCentralManager * _Nonnull)central didConnectPeripheral:(CBPeripheral * _Nonnull)peripheral;
/// :nodoc:
- (void)centralManager:(CBCentralManager * _Nonnull)central didDisconnectPeripheral:(CBPeripheral * _Nonnull)peripheral error:(NSError * _Nullable)error;
/// :nodoc:
- (void)centralManagerDidUpdateState:(CBCentralManager * _Nonnull)central;
@end

/// Instance of peripheral device
SWIFT_CLASS("_TtC9ZTCoreKit8ZTDevice")
@interface ZTDevice : NSObject
/// :nodoc:
- (void)observeValueForKeyPath:(NSString * _Nullable)keyPath ofObject:(id _Nullable)object change:(NSDictionary<NSKeyValueChangeKey, id> * _Nullable)change context:(void * _Nullable)context;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CBDescriptor;
@class CBService;
@class CBCharacteristic;
@class CBL2CAPChannel;
@interface ZTDevice (SWIFT_EXTENSION(ZTCoreKit)) <CBPeripheralDelegate>
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didWriteValueForDescriptor:(CBDescriptor * _Nonnull)descriptor error:(NSError * _Nullable)error;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didDiscoverServices:(NSError * _Nullable)error;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didDiscoverCharacteristicsForService:(CBService * _Nonnull)service error:(NSError * _Nullable)error;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didUpdateValueForCharacteristic:(CBCharacteristic * _Nonnull)characteristic error:(NSError * _Nullable)error;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didWriteValueForCharacteristic:(CBCharacteristic * _Nonnull)characteristic error:(NSError * _Nullable)error;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic * _Nonnull)characteristic error:(NSError * _Nullable)error;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didReadRSSI:(NSNumber * _Nonnull)RSSI error:(NSError * _Nullable)error;
/// :nodoc:
- (void)peripheralDidUpdateName:(CBPeripheral * _Nonnull)peripheral;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didModifyServices:(NSArray<CBService *> * _Nonnull)invalidatedServices;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didDiscoverIncludedServicesForService:(CBService * _Nonnull)service error:(NSError * _Nullable)error;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic * _Nonnull)characteristic error:(NSError * _Nullable)error;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didUpdateValueForDescriptor:(CBDescriptor * _Nonnull)descriptor error:(NSError * _Nullable)error;
/// :nodoc:
- (void)peripheralIsReadyToSendWriteWithoutResponse:(CBPeripheral * _Nonnull)peripheral;
/// :nodoc:
- (void)peripheral:(CBPeripheral * _Nonnull)peripheral didOpenL2CAPChannel:(CBL2CAPChannel * _Nullable)channel error:(NSError * _Nullable)error;
@end

SWIFT_CLASS_NAMED("ZTPacket")
@interface ZTPacket : NSManagedObject
- (nonnull instancetype)initWithEntity:(NSEntityDescription * _Nonnull)entity insertIntoManagedObjectContext:(NSManagedObjectContext * _Nullable)context OBJC_DESIGNATED_INITIALIZER;
@end

@interface ZTPacket (SWIFT_EXTENSION(ZTCoreKit))
@property (nonatomic) int16_t activityTypeRawValue;
@property (nonatomic) int16_t bmTimestampTypeRawValue;
@property (nonatomic, copy) NSDate * _Nullable createdAt;
@property (nonatomic) int16_t duration;
@property (nonatomic, copy) NSDate * _Nullable fulfilledAt;
@property (nonatomic, copy) NSString * _Nullable fwVersion;
@property (nonatomic) int16_t id;
@property (nonatomic) int64_t originalTimestamp;
@property (nonatomic) int16_t packetsNumber;
@property (nonatomic) int16_t packetTypeRawValue;
@property (nonatomic, copy) NSData * _Nullable rawData;
@property (nonatomic) int16_t retryCount;
@property (nonatomic, copy) NSDate * _Nullable scheduledDeleted;
@property (nonatomic, copy) NSDate * _Nullable sentAt;
@property (nonatomic) int16_t statusRawValue;
@property (nonatomic) int64_t timestamp;
@property (nonatomic) int16_t timestampTypeRawValue;
@property (nonatomic, strong) ZTActivity * _Nullable activity;
@end

#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
